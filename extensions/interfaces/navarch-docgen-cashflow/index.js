import{useApi as e,defineInterface as t}from"@directus/extensions-sdk";import{defineComponent as a,ref as o,inject as n,resolveComponent as i,openBlock as r,createElementBlock as l,Fragment as s,createCommentVNode as c,createVNode as d,withCtx as u,createTextVNode as m,createBlock as f,toDisplayString as p}from"vue";var y=(e=>(e.BRACKET="Bracket",e.MIN_DEDUCTION="Minimum Deduction",e.MAX_CAP="Maximum Cap",e))(y||{}),h=(e=>(e.PERCENTAGE="Percentage",e.FRACTIONAL="Fractional",e))(h||{}),v=(e=>(e.WET_WEIGHT="wet_weight",e.MOISTURE="moisture",e.DRY_WEIGHT="dry_weight",e))(v||{}),_=(e=>(e.METHOD="method",e.WET_WEIGHT_UOM="wet_weight_uom",e.MOISTURE_UOM="moisture_uom",e.DRY_WEIGHT_UOM="dry_weight_uom",e))(_||{}),g=a({props:{value:{type:Object,default:null}},emits:["input"],setup(t,{emit:a}){const i=o(""),r=o(!1),l=o(!1),s=e(),c=n("values",o({}));function d(e){if(console.log("[evaluateWeightData]"),0===e.length)return;const t=m(e,v.DRY_WEIGHT),a=m(e,v.WET_WEIGHT);return{method:u(e,_.METHOD),lots:e,dry_weight_uom:u(e,_.DRY_WEIGHT_UOM),wet_weight_uom:u(e,_.WET_WEIGHT_UOM),dry_weight:t,wet_weight:a,moisture:(a-t)/a*100}}function u(e,t){if(console.log("[getFirstValueAsSharedValue]"),0!==e.length)return console.log(`lots[0][${t.toString()}]=${e[0][t.toString()]}`),e[0][t.toString()]}function m(e,t){return console.log("[evaluateAggregateValue]"),e.reduce(((e,a)=>{var o;return e+parseFloat(null!=(o=a[t.toString()])?o:"0")}),0)}function f(e){return null==e}function p(e,t=2,a=!0){if(console.log("[formatNumber]"),isNaN(e)||null===e)return"-";const o=Math.round(e*Math.pow(10,t))/Math.pow(10,t),[n,i]=o.toString().split("."),r=n.replace(/\B(?=(\d{3})+(?!\d))/g,",");if(!i&&!a)return r;return`${r}.${(null!=i?i:"").padEnd(t,"0")}`}function g(e,t=2,a=!1){if(f(e)||isNaN(e))return null;const o=a&&e<0;return o&&(e*=-1),Math.round(e*Math.pow(10,t))/Math.pow(10,t)*(o?-1:1)}function $(e){if(console.log("[parseNumber]"),"number"==typeof e)return e;if(!e||"-"===e)return 0;const t=parseFloat(e.replace(/[^\d.-]/g,""));return console.log(`[parseNumber] number: ${e} to ${t}`),t}function w(e,t){return console.log("[findBracket]"),e.find((e=>{var a,o;const n=t>(null!=(a=e.lower_threshold)?a:0)&&(f(e.upper_threshold)||t<e.upper_threshold)||e.lower_threshold_inclusive&&t===(null!=(o=e.lower_threshold)?o:0)||e.upper_threshold_inclusive&&t===e.upper_threshold;return console.log(`[findBracket] value=${t} for bracket: ${JSON.stringify(e)}? match=${!!n}`),n}))}function D(e,t){var a,o,n,i,r,l,s,c,d,u,m;console.log("[evaluateFinalValueFromBrackets]");const f=(e-(null!=(a=t.initial_adjustment)?a:0)*(t.initial_adjustment_conversion_by_multiplication?null!=(o=t.initial_adjustment_conversion_factor)?o:1:1/(null!=(n=t.initial_adjustment_conversion_factor)?n:1)))*(null!=(i=t.rate)?i:0)*(t.rate_type===h.PERCENTAGE?.01:1)+(null!=(r=t.final_adjustment)?r:0)*(t.final_adjustment_conversion_factor?null!=(l=t.final_adjustment_conversion_factor)?l:1:1/(null!=(s=t.final_adjustment_conversion_factor)?s:1));switch(t.bracket_type){case y.MIN_DEDUCTION:if(null===t.comparator||void 0===t.comparator)throw new Error("Minimum deduction not found");const a=t.comparator*(t.comparator_conversion_by_multiplication?null!=(c=t.comparator_conversion_factor)?c:1:1/(null!=(d=t.comparator_conversion_factor)?d:1));return e-f<a?g(e-a,4):f;case y.MAX_CAP:if(null===t.comparator||void 0===t.comparator)throw new Error("Maximum cap not found");const o=t.comparator*(t.comparator_conversion_by_multiplication?null!=(u=t.comparator_conversion_factor)?u:1:1/(null!=(m=t.comparator_conversion_factor)?m:1));return g(f>o?o:f,4);case y.BRACKET:return g(f,4);default:throw new Error(`bracket type ${t.bracket_type} is not supported`)}}async function b(e,t,a,o){var n,i,r,l,s,c,d,u;if(console.log("[evaluatePayableAssay]"),!a||0===a.length)return{};const m=w(a,e);if(!m)throw new Error(`Unable to find the range for analytical assay value of ${e}, please ensure the payable assay rates for the commodity ${o} are defined in the contract cover all range of possible values`);let f,v,_=1,g=!0;if(m.initial_adjustment_uom&&void 0!==m.initial_adjustment_uom&&null!==m.initial_adjustment_uom&&m.initial_adjustment_uom!==t){const e=await U(m.initial_adjustment_uom,t);_=e.value,f=B(m.initial_adjustment_uom,t,e.isConvertByMultiplication),g=e.isConvertByMultiplication}let $,b=1,E=!0;if(m.bracket_type===y.MAX_CAP){if(v=null!=(n=m.maximum_cap)?n:0,void 0!==m.maximum_cap_uom&&null!==m.maximum_cap_uom&&m.maximum_cap_uom!==t){const e=await U(m.maximum_cap_uom,t);b=e.value,$=B(m.maximum_cap_uom,t,e.isConvertByMultiplication),E=e.isConvertByMultiplication}}else if(m.bracket_type===y.MIN_DEDUCTION&&(v=null!=(i=m.minimum_deduction)?i:0,void 0!==m.minimum_deduction_uom&&null!==m.minimum_deduction_uom&&m.minimum_deduction_uom!==t)){const e=await U(m.minimum_deduction_uom,t);b=e.value,$=B(m.minimum_deduction_uom,t,e.isConvertByMultiplication),E=e.isConvertByMultiplication}const P={bracket_type:m.bracket_type,rate:null!=(r=m.rate)?r:1,rate_type:null!=(l=m.rate_type)?l:h.FRACTIONAL,initial_adjustment:null!=(s=m.initial_adjustment)?s:0,initial_adjustment_conversion_factor:_,initial_adjustment_conversion_by_multiplication:g,comparator:v,comparator_conversion_factor:b,comparator_conversion_by_multiplication:E};console.log(`[evaluatePayableAssay] bracketForEvaluation: ${JSON.stringify(P)}`);const C=D(e,P);let S="";const A=void 0!==m.initial_adjustment&&null!==m.initial_adjustment;if(m.bracket_type===y.BRACKET)S=`${A?"(":""}${p(e,4)}${null!=t?t:""}${A?` - ${p(m.initial_adjustment,4)}${null!=(c=m.initial_adjustment_uom)?c:`${null!=t?t:""}`}`:""}${A&&1!==_?` ${g?"*":"/"} ${p(_,4)}${f}`:""}${A?")":""} * ${p(m.rate,4)}${m.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`;else if(m.bracket_type===y.MIN_DEDUCTION){S=C===e-v*b?`${p(e,4)}${null!=t?t:""} - ${p(v,4)}${null!=t?t:""}${1!==b?` ${E?"*":"/"} ${p(b,4)}${$}`:""}`:`${A?"(":""}${p(e,4)}${null!=t?t:""}${A?` - ${p(m.initial_adjustment,4)}${null!=(d=m.initial_adjustment_uom)?d:`${null!=t?t:""}`}`:""}${A&&1!==_?` ${g?"*":"/"} ${p(_,4)}${f}`:""}${A?")":""} * ${p(m.rate,4)}${m.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`}else{if(m.bracket_type!==y.MAX_CAP)throw new Error(`[buildPayableAssayExpression] unknown bracket method: ${m.bracket_type}`);S=C===v*b?`${p(v,4)}${null!=t?t:""}${1!==b?` ${E?"*":"/"} ${p(b,4)}${$}`:""}`:`${A?"(":""}${p(e,4)}${null!=t?t:""}${A?` - ${p(m.initial_adjustment,4)}${null!=(u=m.initial_adjustment_uom)?u:`${null!=t?t:""}`}`:""}${A&&1!==_?` ${g?"*":"/"} ${p(_,4)}${f}`:""}${A?")":""} * ${p(m.rate,4)}${m.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`}return{payableAssay:C,expression:S}}console.log("[main] formValues=",c);const E="above the lower threshold, plus",P="below the upper threshold, minus";function C(e,t,a,o,n){var i,r,l,s,c,d,u;if(console.log("[evaluateCharge]"),!a||!a.length)return;const m=w(a,e);if(!m)throw new Error(`Unable to find the range for the price rate value of ${e}, please ensure the ${n} rates for commodity ${o} are defined in the contract cover all range of possible values`);let f=0,p=1;if(m.use_btc)p=0,f=0;else{const e=null!=(i=m.escalator_reference)?i:1;if(p=(null!=(r=m.rate)?r:1)/e,m.for_every_unit===E)f=null!=(l=m.lower_threshold)?l:0;else{if(m.for_every_unit!==P)throw new Error(`[evaluateCharge] unknown for_every_unit: ${m.for_every_unit}`);f=null!=(s=m.upper_threshold)?s:0}}const v={bracket_type:y.BRACKET,rate:p,rate_type:h.FRACTIONAL,initial_adjustment:f,final_adjustment:(null!=(c=m.base_treatment_charge)?c:0)+(null!=(d=m.base_charge_adjustment)?d:0)};return console.log(`[evaluateCharge] bracketForEvaluation: ${JSON.stringify(v)}`),{finalValue:D(e,v),baseTreatmentCharge:m.base_treatment_charge+(null!=(u=m.base_charge_adjustment)?u:0)}}function S(e,t,a,o,n){var i,r,l,s;if(console.log("[evaluatePenalty]"),!t||!t.length)return{};const c=w(t,e);if(!c)throw new Error(`Unable to find the range for the analytical assay value of ${e}, please ensure the penalty rates for commodity ${n} are defined in the contract cover all range of possible values`);let d=0,u=1;if(c.no_penalty)u=0,d=0;else{const e=null!=(i=c.escalator_reference)?i:1;if(u=(null!=(r=c.rate)?r:1)/e,c.for_every_unit===E)d=null!=(l=c.lower_threshold)?l:0;else{if(c.for_every_unit!==P)throw new Error(`[evaluatePenalty] unknown for_every_unit: ${c.for_every_unit}`);d=null!=(s=c.upper_threshold)?s:0}}const m={bracket_type:y.BRACKET,rate:u,rate_type:h.FRACTIONAL,initial_adjustment:d,final_adjustment:0};console.log(`[evaluatePenalty] bracketForEvaluation: ${JSON.stringify(m)}`);const f=D(e,m),v=null!=m.initial_adjustment;let _="";return _=c.rate&&0!==c.rate?`${v?"(":""}${p(e,4)}${v?` - ${p(d,4)})`:""} / ${p(1,4)} * ${null!=a?a:""} ${p(u,4)}/${null!=o?o:""}`:"No penalty",{penalty:f,expression:_,bracket:c}}function A(e){const t=e.getDate(),a=e.getMonth(),o=e.getFullYear();return`${t} ${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][a]} ${o}`}function N(e,t=!0){const a=e.getMonth()+1,o=e.getDate();return`${e.getFullYear()}${t?"-":" "}${a<10?"0":""}${a}${t?"-":" "}${o<10?"0":""}${o}`}function M(e){return 0===e.getDay()||6===e.getDay()}function O(e,t,a=!1){const o=new Date(e.valueOf());let n=t-(a?1:0),i=!0;for(;M(o);)o.setDate(o.getDate()+1),i&&(n-=1,i=!1);for(;n>0;)o.setDate(o.getDate()+1),M(o)||(n-=1);for(o.getHours()>=12&&o.setDate(o.getDate()+1);M(o);)o.setDate(o.getDate()+1);return o}function T(e,t){const a=new Date(e.valueOf());return a.setMonth(a.getMonth()+t+1,0),a}async function I(e,t){var a,o;if(e===t)return{value:1,isConvertByMultiplication:!0};const n=await s.get(`/items/${Et}?filter[${Pt}]=${e}`,{params:{fields:[Mt]}});if(0===n.data.data.length||null===n.data.data[0][Mt]||void 0===n.data.data[0][Mt])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const i=await s.get(`/items/${Et}?filter[${Pt}]=${t}`,{params:{fields:[Mt]}});if(0===i.data.data.length||null===i.data.data[0][Mt]||void 0===i.data.data[0][Mt])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for the target weight unit ${t}. Ensure that the symbol is correct and is a weight unit symbol`);const r=parseFloat(n.data.data[0][Mt]);if(isNaN(r))throw new Error(`[getWeightUnitConversionValue] source weight unit ${e} conversion value=${r} is not a number`);const l=parseFloat(i.data.data[0][Mt]);if(isNaN(l))throw new Error(`[getWeightUnitConversionValue] target weight unit ${t} conversion value=${l} is not a number`);return r<l?{value:null!=(a=g(l/r,4))?a:1,isConvertByMultiplication:!1}:{value:null!=(o=g(r/l,4))?o:1,isConvertByMultiplication:!0}}async function U(e,t){var a,o;if(null==e||null==t)return{value:1,isConvertByMultiplication:!0};if(e===t)return{value:1,isConvertByMultiplication:!0};const n=await s.get(`/items/${Ot}?filter[${Tt}]=${e}`,{params:{fields:[It]}});if(0===n.data.data.length||void 0===n.data.data[0][It]||null===n.data.data[0][It])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const i=await s.get(`/items/${Ot}?filter[${Tt}]=${t}`,{params:{fields:[It]}});if(0===i.data.data.length||void 0===i.data.data[0][It]||null===i.data.data[0][It])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for the target weight unit ${t}. Ensure that the symbol is correct and is a weight unit symbol`);const r=parseFloat(n.data.data[0][It]);if(isNaN(r))throw new Error(`[getAssayUnitConversionValue] source weight unit ${e} conversion value=${r} is not a number`);console.log(`[getAssayUnitConversionValue] source unit conversion value=${r}`);const l=parseFloat(i.data.data[0][It]);if(isNaN(l))throw new Error(`[getAssayUnitConversionValue] target weight unit ${e} conversion value=${l} is not a number`);return console.log(`[getAssayUnitConversionValue] target unit conversion value=${l}`),console.log("[getAssayUnitConversionValue] returning "+r/l),r<l?{value:null!=(a=g(l/r,4))?a:1,isConvertByMultiplication:!1}:{value:null!=(o=g(r/l,4))?o:1,isConvertByMultiplication:!0}}function B(e,t,a){if(void 0===e||void 0===t||null===e||null===t)return;const o=e.split("/"),n=t.split("/");if(o.length>2||n.length>2)throw new Error(`[getConversionUnit] sourceUnit=${e} and targetUnit=${t} must be in the format of 'unit1/unit2', an extra '/' was found`);if(1===o.length&&1===n.length)return a?`${n[0]}/${o[0]}`:`${o[0]}/${n[0]}`;if(1===o.length){const e=n[0]===o[0]?"":`${n[1]}(${o[1]})`,t=n[1];return""===t?a?e:`/${e}`:a?`${e}/${t}`:`${t}/${e}`}if(1===n.length){const e=o[1],t=o[0]===n[0]?"":`${o[1]}(${n[0]})`;return""===t?a?e:`/${e}`:a?`${e}/${t}`:`${t}/${e}`}{const e=o[0]===n[0],t=o[1]===n[1],i=e||""===o[0],r=e||""===n[0],l=t||""===o[1],s=t||""===n[1],c=!l&&!r,d=!i&&!s,u=`${l?"":o[1]}${c?"(":""}${r?"":`${n[0]}`}${c?")":""}`,m=`${i?"":o[0]}${d?"(":""}${s?"":`${n[1]}`}${d?")":""}`;return""===m?a?u:`/${u}`:a?`${u}/${m}`:`${m}/${u}`}}async function k(e,t,a){const o=await s.get(`/items/${Et}?filter[${Ct}]=${t}`,{params:{fields:[Pt]}});if(!o.data.data||!o.data.data[0]||!o.data.data[0][Pt])throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] Dry weight uom not found for symbol ${t}`);const n=o.data.data[0][Pt];if("%"===a){if(n===e)return{};const t=await I(n,e),a=B(n,e,t.isConvertByMultiplication);if(!a)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and target weight unit ${e}`);return{finalConversion:{conversionFactor:t.value,conversionUom:a,isConvertByMultiplication:t.isConvertByMultiplication}}}let i=a.split("/");if(1==i.length){const e=await async function(e){const t=await s.get(`/items/${Ot}`,{params:{fields:[Tt,Ut],filter:{[Ut]:{_nnull:!0},[Tt]:{_eq:e}}}});if(200!==t.status||!t.data||0===t.data.data.length)throw new Error("[getAssayUnitComposition] no assay units found with composition");return t.data.data[0][Ut]}(a);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${a} does not have a composition`);i=e.split("/")}if(i.length>2||0===i.length)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${a} is not in the format of 'unit1/unit2'`);const r=i[0],l=i[1],c={};if(l!==n){const e=await I(n,l),t=B(n,l,e.isConvertByMultiplication);if(!t)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and assay unit denominator unit ${l}`);c.initialConversion={conversionFactor:e.value,conversionUom:t,isConvertByMultiplication:e.isConvertByMultiplication}}if(r!==e){const t=await I(r,e),a=B(r,e,t.isConvertByMultiplication);if(!a)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for target weight unit ${e} and assay unit numerator unit ${r}`);c.finalConversion={conversionFactor:t.value,conversionUom:a,isConvertByMultiplication:t.isConvertByMultiplication}}return c}const j="id",F="foreign_key",V="lot_number",R="method",J="navarch_cashflow",x="navarch_parcel",q="contract",L="counterparty",W="assay_results",G="weight_result",H="actual_arrival_date",Q="estimate_arrival_date",K="bl_date",Y="estimated_shipment_date",X="qp_selection",z="vessel",Z="origin",ee="destination",te="shipment_code",ae="adjustments",oe="parcel_finalisation_date",ne="navarch_assay_lot",ie="commodity",re="dry_weight",le="dry_weight_uom",se="buyer_assay",ce="seller_assay",de="final_assay",ue="assay_uom",me="lot_number",fe="navarch_weight_lot",pe="dry_weight",ye="wet_weight",he="moisture",ve="wet_weight_uom",_e="dry_weight_uom",ge="navarch_contract",$e="contract_currency",we="name",De="navarch_contract_payment_information",be="related_contract",Ee="invoice_type",Pe="pay_percent",Ce="pa_days",Se="pa_day_type",Ae="pa_ref_day",Ne="pp_days",Me="pp_day_type",Oe="pp_ref_day",Te="navarch_commodity_in_contract",Ie="contract",Ue="commodity",Be="primary_commodity",ke="payable_commodity",je="price_method",Fe="price_fix_to_use",Ve="price_per_uom",Re="treatment_charge_per_uom",Je="refining_charge_rate_uom",xe="quotational_periods",qe="payable_assay_rates",Le="penalty_rates",We="penalty_per_uom",Ge="navarch_payable_assay_bracket",He="initial_adjustment",Qe="initial_adjustment_uom",Ke="minimum_deduction",Ye="minimum_deduction_uom",Xe="maximum_cap",ze="maximum_cap_uom",Ze="related_commodity_in_contract",et="bracket_type",tt="lower_threshold",at="lower_threshold_inclusive",ot="upper_threshold",nt="upper_threshold_inclusive",it="rate",rt="rate_type",lt="navarch_treatment_charge_bracket",st="base_treatment_charge",ct="base_charge_adjustment",dt="use_btc",ut="escalator_reference",mt="for_every_unit",ft="related_contract_commodity_tc",pt="related_contract_commodity_rc",yt="navarch_penalty_bracket",ht="no_penalty",vt="escalator_reference",_t="for_every_unit",gt="navarch_commodity",$t="name",wt="code",Dt="navarch_currency",bt="code",Et="navarch_unit",Pt="symbol",Ct="dry_symbol",St="wet_symbol",At="dry_unit",Nt="wet_unit",Mt="conversionToGram",Ot="navarch_assay_unit",Tt="unit",It="conversion_to_ppb",Ut="composition",Bt="navarch_counterparty",kt="codename",jt="name",Ft="navarch_vessel",Vt="name",Rt="price_am",Jt="price_pm",xt="average_price",qt="date",Lt="navarch_invoices",Wt="parcel",Gt="invoice",Ht="invoice_date",Qt="amount_paid",Kt="invoice_type",Yt="navarch_forecast_price",Xt="commodity",zt="price",Zt="start_date",ea="end_date",ta={Advance:0,"Second Advance":1,"Third Advance":2,"Fourth Advance":3,Provisional:4,"Second Provisional":5,"Third Provisional":6,"Fourth Provisional":7,Final:8};function aa(e){const t=[...new Set(e.flatMap((e=>Object.keys(e))))],a=e.map((e=>t.map((t=>{const a=e[t]||"";return"string"==typeof a&&a.includes(",")?`"${a}"`:a})).join(",")));return[t.join(","),...a].join("\n")}function oa(e){const t=new Blob([e],{type:"text/csv"}),a=URL.createObjectURL(t),o=document.createElement("a");o.href=a,o.download=`Cashflow-[${function(){const e=new Date,t=60*e.getTimezoneOffset()*1e3,a=e.getTime()-t,o=new Date(a),n=o.toISOString().slice(0,19),i=e.getTimezoneOffset()/60*-1;return`${n}GMT${i>0?"+":""}${i}`.replace(/:/g,"")}()}]-Valuation_Period-(${N(new Date(c.value.start_date),!1)}~${N(new Date(c.value.end_date),!1)}).csv`,document.body.appendChild(o),o.click(),document.body.removeChild(o)}class na extends Error{constructor(e){super(e),this.name="NonFatalError",Object.setPrototypeOf(this,na.prototype)}}return{isGeneraingDoc:r,invoiceUrl:c.value,generateCashflow:async function(){i.value="";try{r.value=!0;const e=await async function(){const e=new Date(c.value.start_date);if("Invalid Date"===e.toString())throw i.value="Start date is invalid",new Error("Start date is invalid");const t=new Date(c.value.end_date);if("Invalid Date"===t.toString())throw i.value="End date is invalid",new Error("End date is invalid");const a=await s.get(`/items/${ge}`,{params:{fields:[we,j,"invoice_type"]}}),o={};await Promise.all(a.data.data.map((async a=>{var n,i,r,l,c;const d=await s.get(`/items/${De}`,{params:{filter:{[be]:{_eq:a[j]}},fields:[Ee,Ce,Se,Ae]}}),u=await s.get(`/items/${x}`,{params:{filter:{[q]:{_eq:a[j]}},fields:[j,te,H,Q,K,Y,oe]}});for(const m of d.data.data){const d={days:m[Ce],day_type:m[Se],ref_day:"Final"===m[Kt]?"QP Month + n days":m[Ae]};if(!d)throw new Error(`Contract ${a[we]} does not have a payment advice for invoice type ${m[Kt]}`);let f,p="";for(const y of u.data.data){switch(d.ref_day){case"Arrival Date":p="Actual Arrival Date from the Parcel form",f=null!=(n=y[H])?n:y[Q];break;case"B/L Date":p="B/L Date (or Estimated Shipment Date) from the Parcel form",f=null!=(i=y[K])?i:y[Y];break;case"Invoice Date":p="Invoice Date (using the B/L Date or Estimated Shipment Date from the Parcel form)",f=null!=(r=y[K])?r:y[Y];break;case"Estimated Shipment Date":p="Estimated Shipment Date from the Parcel form",f=y[Y];break;case"QP Month + n days":const e=await s.get(`items/${Te}`,{params:{filter:{[Ie]:{_eq:a[j]},[ke]:{_eq:!0}},fields:[xe]}});if(!Array.isArray(e.data.data)||0===e.data.data.length)throw new Error(`Contract ${a[we]} does not have any payable commodities`);const t=e.data.data.map((e=>e[xe].find((e=>!!e.default)))),o=t.reduce(((e,t)=>t.qp_period>e.qp_period?t:e),t[0]);let u;switch(o.qp_code){case"MAMA":p="Actual Arrival Date (or Estimated Arrival Date) from the Parcel form",u=null!=(l=y[H])?l:y[Q];break;case"MOSS":case"MOS":case"MOAS":p="B/L Date (or Estimated Shipment Date) from the Parcel form",u=null!=(c=y[K])?c:y[Y];break;default:throw new Error(`Unsupported QP code ${o.qp_code}, currently only supports MAMA, MOS, MOSS, and MOAS`)}const m=T(new Date(u),o.qp_period);if(!m||"Invalid Date"===m.toString())throw new Error(`Invalid date for last date of QP month: ${m}, please ensure all fields for QP for contract ${a[we]} and the ${p} in parcel ${y[te]} are filled in`);f=m.toISOString();break;default:throw new Error(`Invalid reference day for payment advice: ${d.ref_day}; please contact Navarch for support`)}if(null==f)throw new Error(`Reference day for payment advice ${p} is empty in parcel ${y[te]}`);const u=new Date(f),h=parseInt(d.days);let v;switch(d.day_type){case"Business Day(s)":v=O(u,h);break;case"Calendar Day(s)":v=new Date(u.valueOf()),v.getHours()>=12?v.setDate(v.getDate()+h+1):v.setDate(v.getDate()+h);break;default:throw new Error(`Please provide a valid Day Type (Cashflow) for ${a[we]}:Final Invoice Type`)}v>=e&&v<=t&&(o[y[j]]||(o[y[j]]=[]),o[y[j]].push({invoiceType:m[Ee],dueDate:v,parcelId:y[j],contractName:a[we]}))}}})));const n=Object.keys(o);let r;for(let e=0;e<n.length;e+=15){const t=n.slice(e,e+15),a=await s.get(`/items/${x}`,{params:{filter:{[j]:{_in:t}},fields:[j,q,L,W,G,H,Q,K,Y,X,z,Z,ee,te,ae,"parcel_finalised",oe,W]}});r?r.data.data=r.data.data.concat(a.data.data):r=a}if(!r.data.data||r.data.data.length!==n.length)throw new Error("Experiencing some network issues, please try again. If the issue persists, contact Navarch for support");const l={parcelData:r.data.data.reduce(((e,t)=>(e[t[j]]=t,e)),{}),contractNameByParcelId:n.reduce(((e,t)=>(e[t]=o[t][0].contractName,e)),{}),invoiceTypeParcel:n.flatMap((e=>o[e])),parcelIds:n};return console.log(`[getApplicableParcels] returnObject=${JSON.stringify(l)}`),l}(),t=await async function(e){const t=[];let a;for(let t=0;t<e.parcelIds.length;t+=15){const o=e.parcelIds.slice(t,t+15),n=await s.get(`/items/${Lt}`,{params:{filter:{[Wt]:{_in:o},[Gt]:{_nnull:!0}},fields:[Wt,Kt,Gt,Ht,Qt]}});a?a.data.data=a.data.data.concat(n.data.data):a=n}a.data.data.sort(((e,t)=>{const a=ta[e[Kt]]-ta[t[Kt]];return 0===a?new Date(t[Ht]).valueOf()-new Date(e[Ht]).valueOf():a}));for(const o of e.invoiceTypeParcel){const n=a.data.data.find((e=>e[Wt]===o.parcelId&&e[Kt]===o.invoiceType));n?t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,invoiceData:{...n[Gt],amount_paid:n[Qt]}}):t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,parcelData:e.parcelData[o.parcelId]})}return console.log(`[generateInvoiceParamForParcel] invoiceParams=${JSON.stringify(t)}`),t}(e);console.log(`[generateCashflow] form values=${JSON.stringify(c.value)}`);const o=await Promise.all(t.map((async e=>(console.log(`[generateCashflow] invoiceParam=${JSON.stringify(e)}`),await async function(e){var t,a,o,n,l,c,u,m,f,y,h,v,_,w,D,E,P,N,M,O,T,I,U,B,J,X,oe,we,Mt,Ot,Tt,It,Ut,Rt,Jt,xt,qt,Ht;i.value="",r.value=!0;try{if(e.invoiceData){console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] using existing invoice=${JSON.stringify(e.invoiceData)}`);const t=e.invoiceData,a=await s.get(`/items/${Bt}`,{params:{filter:{[jt]:{_eq:t.buyer}},fields:[kt]}});pa(a.data.data[0]);const o=await s.get(`/items/${x}`,{params:{filter:{[j]:{_eq:e.parcelId}},fields:[K,H,Q]}});console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] parcel date data=${JSON.stringify(o.data.data)}`);const n=o.data.data[0];return{Counterparty:a.data.data[0][kt],Vessel:"N/A"===t.vessel?"Vessel TBA":t.vessel,"Shipment Date":t.bl_date,"Arrival Date":n[H]?A(new Date(n[H])):n[Q]?A(new Date(n[Q])):"N/A",Status:o[K]?"Unfinalised":"Planned",Revision:"Original",Invoice:`${t.invoice_type}:Original`,Parcel:t.parcel,"Invoice Due Date":A(e.dueDate),"Dry Weight":`${p(t.dry_weight,4)} ${t.dry_weight_uom}`,"Total Revenues USD":p(t.total_revenue),"Total Penalties USD":p(t.total_deductions),...await la(t.commodities,{dryWeight:t.dry_weight,dryWeightUom:t.dry_weight_uom}),"Total Adjustments USD":t.adjustments?p(t.adjustments.total_adjustments):"0.00","Parcel Value USD":p(t.invoice_value),"Parcel Payable Value(Below Line) USD":p(t.payable_amount),"Payments USD":t.amount_paid,"Due Total":p(t.balance_in_sellers_favor),metadata:{invoiceTypeRanking:ta[t.invoice_type]}}}if(void 0===e.parcelData)throw new na(`Something went wrong, no parcel or invoice data for Invoice of parcel id ${e.parcelId.substring(0,5)} and invoice type ${e.invoiceType}`);const r=e.parcelId;if(!r)return void console.error(`[generateInvoice] A parcel id is not defined for invoice type ${e.invoiceType}`);const Qt=e.invoiceType,Kt=e.parcelData,Yt=e.contractName;console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] parcel data=${JSON.stringify(Kt)}`),function(e){if(!e)throw new Error("Parcel data not found, please ensure the selected parcel still exists");if(!e[te])throw new Error("One of the parcels does not have a shipment code, please ensure that all parcels have a shipment code");if(!e[q])throw new Error(`The parcel ${e[te]} does not have a contract, please ensure that the contract field for the parcel is not empty`);if(!e[L])throw new Error(`The parcel ${e[te]} does not havea counterparty, please ensure that the counterparty field for the parcel is not empty`);if(!e[W])throw new na(`The parcel ${e[te]} does not have assay results`);if(!e[G])throw new na(`The parcel ${e[te]} does not have weight results`);if(!e[Z])throw new Error(`The parcel ${e[te]} does not havean origin port`);if(!e[ee])throw new Error(`The parcel ${e[te]} does not havea destination port`)}(Kt);const Xt=Kt[W],zt=Kt[G],Zt=Kt[q];if(!Zt)throw new Error(`Contract not found for parcel ${Kt[te]}`);const ea=await s.get(`/items/${De}`,{params:{filter:{[be]:{_eq:Zt},[Ee]:{_eq:Qt}},fields:[Ee,Pe,Ce,Se,Ae,Ne,Me,Oe]}});if(ea.data.data&&0===ea.data.data.length)throw new Error(`No invoice type found for the contract ${Yt}`);const aa=ea.data.data.find((e=>e[Ee]===Qt));if(!aa)throw new Error(`Cannot find payment information for ${Qt} in the contract ${Yt}, please ensure that data for it has been entered and saved`);const oa=await s.get(`/items/${fe}?filter[${F}]=${zt}&sort[]=${V}`,{params:{fields:[j,pe,ye,R,he,ve,_e]}});console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] weight lots data=${JSON.stringify(oa.data.data)}`),function(e){if(!e||0===e.length)throw new na("No weight lots found for the selected parcel")}(oa.data.data);const ia=function(e){console.log("[evaluateWeights]");const t={};for(const a of e)t[a.method]||(console.log(`adding method ${a.method} to weightData object`),t[a.method]=[]),console.log(`adding lot ${a.id} to weightData.${a.method} array`),t[a.method.toString()].push(a);const a=[];for(const e of Object.keys(t)){if(!t[e]){console.log(`method=${e} does not exist in weightData object`);continue}console.log(`adding lots and other values to weights for method=${e}`);const o=d(t[e]);o&&a.push(o)}return a}(oa.data.data);let sa;if(sa||(sa=ia.find((e=>"Outturn"===e.method))),sa||(sa=ia.find((e=>"Inturn Final"===e.method))),sa||(sa=ia.find((e=>"Inturn"===e.method))),sa||(sa=ia.find((e=>"Estimated"===e.method))),sa||(sa=ia.find((e=>"Planned"===e.method))),!sa)throw new Error(`No weight lots with valid method found for parcel ${Kt[te]}`);if(void 0===sa.dry_weight||null===sa.dry_weight||void 0===sa.wet_weight||null===sa.wet_weight||void 0===sa.moisture||null===sa.moisture||void 0===sa.dry_weight_uom||null===sa.dry_weight_uom||void 0===sa.wet_weight_uom||null===sa.wet_weight_uom||void 0===sa.method||null===sa.method)throw new Error(`One of the fields for the latest weight lots data is undefined for parcel ${Kt[te]}`);const ya=await s.get(`/items/${Et}?filter[${Ct}]=${sa.dry_weight_uom}`,{params:{fields:[At]}}),ha=await s.get(`/items/${Et}?filter[${St}]=${sa.wet_weight_uom}`,{params:{fields:[Nt]}});if(!ya.data.data||!ya.data.data[0]||!ya.data.data[0][At])throw new Error(`Dry weight uom not found for symbol ${sa.dry_weight_uom} for parcel ${Kt[te]}`);if(!ha.data.data||!ha.data.data[0]||!ha.data.data[0][Nt])throw new Error(`Wet weight uom not found for symbol ${sa.wet_weight_uom} for parcel ${Kt[te]}`);const va=await s.get(`/items/${ne}?filter[${F}]=${Xt}&sort[]=${V}`,{params:{fields:[j,ie,R,re,le,se,ce,de,me,ue]}});console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] assay lots data=${JSON.stringify(va.data.data)}`),function(e){if(!e||0===e.length)throw new na("No assay lots found for the selected parcel")}(va.data.data);const _a=function(e){var t;console.log("[evaluateAnalyticalAssay]");const a={};for(const t of e)a[t.method]||(a[t.method]={}),a[t.method][t.commodity]||(a[t.method][t.commodity]=[]),null!==t.lot_number?(1===a[t.method][t.commodity].length&&null===a[t.method][t.commodity][0].lot_number&&(a[t.method][t.commodity]=[]),a[t.method][t.commodity].push(t)):null===t.lot_number&&0===a[t.method][t.commodity].length&&a[t.method][t.commodity].push(t);console.log(`[evaluateAnalyticalAssay] group: ${JSON.stringify(a)}}`);const o={};for(const e in a){console.log(`[evaluateAnalyticalAssay] methodKey: ${e}, group[methodKey]: ${JSON.stringify(a[e])}`);for(const n in a[e]){console.log(`[evaluateAnalyticalAssay] commodityKey: ${n}, group[methodKey][commodityKey]: ${JSON.stringify(a[e][n])}`),o[e]=null!=(t=o[e])?t:{},o[e][n]={};const r=a[e][n].reduce(((e,t)=>e+parseFloat(t.dry_weight)),0);if(console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${r} from ${JSON.stringify(a[e][n])}`),0===r||isNaN(r))throw i.value=`Please provide dry weight for ${n} commodity in ${e} method, total dry weight cannot be ${r}`,new Error("[evaluateAnalyticalAssay] totalDryWeight is 0");console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${r}`),o[e][n].analytical_assay=a[e][n].reduce(((t,a)=>{var o,r,l;const s=parseFloat(null!=(r=a.final_assay)?r:null!=(o=a.seller_assay)?o:a.buyer_assay);if(null==s)throw i.value=`Please provide Final, Seller or Buyer assay value for ${n} commodity in ${e} method`,new Error("[evaluateAnalyticalAssay] assay value is not defined for assay lot");const c=t+s*parseFloat(null!=(l=a.dry_weight)?l:"0");return console.log(`[evaluateAnalyticalAssay] evaluated analytical assay: ${c} for method=${e}, commodity=${n}; with values accumulator=${t}, assayValue=${s}, dryWeight=${a.dry_weight}`),c}),0)/r,console.log(`[evaluateAnalyticalAssay] analytical assay: ${o[e][n].analytical_assay}`),a[e][n].length>0&&(o[e][n][ue]=a[e][n][0][ue])}}return console.log(`[evaluateAnalyticalAssay] analyticalAssay: ${JSON.stringify(o)}`),o}(va.data.data);let ga;if(ga||(ga=_a.Outturn),ga||(ga=_a["Inturn Final"]),ga||(ga=_a.Inturn),ga||(ga=_a.Estimated),ga||(ga=_a.Planned),!ga)throw new Error(`No assay lot data with a valid method found for parcel ${Kt[te]}`);console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] weight lots for invoice evaluation=${JSON.stringify(sa)}`),console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] assay lots for invoice evaluation=${JSON.stringify(ga)}`);const $a=await s.get(`/items/${ge}/${Zt}`,{params:{fields:[$e]}});!function(e){if(!e)throw new Error("Contract data not found, please ensure the selected contract still exists");if(!e[$e])throw new Error("The selected contract does not have a set currency, please ensure that the currency field for the contract is not empty")}($a.data.data);const wa=await s.get(`/items/${Dt}/${$a.data.data.contract_currency}`,{params:{fields:[bt]}});!function(e){if(!e)throw new Error("Currency data not found, please ensure the selected currency still exists");if(!e[bt])throw new Error("The selected currency in the contract is not valid")}(wa.data.data);const Da=wa.data.data.code,ba=await s.get(`/items/${Te}?filter[${Ie}]=${Zt}`,{params:{fields:["id",Ue,Be,ke,je,Fe,xe,qe,Le,We,Ve,Re,Je]}});!function(e){if(!e||0===e.length)throw new Error("No commodity data found in selected contract for parcel");if(!e.every((e=>e[Ue])))throw new Error("The selected contract has an undefined commodity, please ensure that the 'Commodity' field for all commodites in the contract is not empty");if(!e.every((e=>!e[ke]||e[Ve])))throw new Error("The selected contract has an undefined base price Uom for commodity, please ensure that the 'Base Price Uom' field for all commodites in the contract is not empty")}(ba.data.data),console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] contract commodity data=${JSON.stringify(ba.data.data)}`);const Ea=[],Pa=[];let Ca="";for(const{id:e,commodity:i,primary_commodity:r,price_method:d,price_fix_to_use:$,quotational_periods:F,price_per_uom:V,penalty_per_uom:R,treatment_charge_per_uom:x,refining_charge_rate_uom:q}of ba.data.data){const L=await s.get(`/items/${gt}/${i}`,{params:{fields:[$t,wt,j]}});if(da(L.data.data,i),!ga[L.data.data.code]){console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}::comm=${L.data.data[$t]}] no analytical assay for commodity ${L.data.data.code} found, skipping...`);continue}if(r&&(Ca=L.data.data[$t]),null!==F){const i=F;console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}::comm=${L.data.data[$t]}] qp=${JSON.stringify(i)}`);const r=Array.isArray(i)?i.find((e=>e.default)):null;if(!r)throw new Error(`No default quotational period found for commodity ${L.data.data.code}`);const S=i.filter((e=>!e.default)).map((e=>`${e.qp_period} ${e.qp_code}`)),R=[`${r.qp_period} ${r.qp_code}`,...S].join(", ");console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}::comm=${L.data.data[$t]}] evaluate payable assay for ${L.data.data.code} with an analytical assay=${null==(t=ga[L.data.data.code])?void 0:t.analytical_assay}`);const W=await s.get(`/items/${Ge}?filter[${Ze}]=${e}`,{params:{fields:[et,tt,at,ot,nt,it,rt,He,Qe,Ke,Ye,Xe,ze]}}),{payableAssay:G,expression:H}=await b(null==(a=ga[L.data.data.code])?void 0:a.analytical_assay,null==(o=ga[L.data.data.code])?void 0:o.assay_uom,W.data.data,L.data.data[$t]);let Q=null,K=null,Y=null;if("Final"!==Qt){const e=await ra(L.data.data.code,L.data.data.name,Kt,d);if(null===e)throw new Error(`[generateInvoice] Provisional pricing dates not found for commodity ${L.data.data.code}`);if(null===e.provisionalPricingStartDate||!(e.provisionalPricingStartDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing start date for commodity ${L.data.data.code} of invoice type ${Qt}`);if(Q=e.provisionalPricingStartDate,null===e.provisionalPricingEndDate||!(e.provisionalPricingEndDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing end date for commodity ${L.data.data.code} of invoice type ${Qt}`);K=e.provisionalPricingEndDate,Y=e.expectedNoOfBusinessDays}else{const e=await ra(L.data.data.code,L.data.data.name,Kt,d);if(null===e)throw new Error(`[generateInvoice] Provisional pricing dates not found for commodity ${L.data.data.code}`);if(null===e.provisionalPricingStartDate||!(e.provisionalPricingStartDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing start date for commodity ${L.data.data.code} of invoice type ${Qt}`);if(Q=e.provisionalPricingStartDate,null===e.provisionalPricingEndDate||!(e.provisionalPricingEndDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing end date for commodity ${L.data.data.code} of invoice type ${Qt}`);K=e.provisionalPricingEndDate}console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}::comm=${L.data.data[$t]}] provisional pricing date range: ${Q.toString()} - ${K.toString()}`);const z=await ca(L.data.data.code,L.data.data[j],d,Q,K,Y,$),Z=z.averagePrice;let ee;Q=z.startDate,K=z.endDate,console.log(`[generateInvoice] average price within period: ${Z} with start date=${Q} and end date=${K}`);const ae=await s.get(`/items/${lt}?filter[${ft}]=${e}`,{params:{fields:[tt,at,ot,nt,st,ct,dt,ut,mt,it]}});let ne,ie;if(void 0!==ae.data.data&&null!==ae.data.data&&ae.data.data.length>0&&(ee=await C(Z,null==(n=ga[L.data.data.code])||n.assay_uom,ae.data.data,L.data.data[$t],"treatment charge")),ee){if(!x)throw new Error(`Treatment Charge Rate UOM is not defined for commodity ${L.data.data[$t]}`);const e=await s.get(`/items/${Et}/${x}`,{params:{fields:[Pt]}});ma(e.data.data,L.data.data[$t]),ne=e.data.data[Pt]}const re=await s.get(`/items/${lt}?filter[${pt}]=${e}`,{params:{fields:[tt,at,ot,nt,st,ct,dt,ut,mt,it]}});let le;if(void 0!==re.data.data&&null!==re.data.data&&re.data.data.length>0&&(ie=await C(Z,null==(l=ga[L.data.data.code])||l.assay_uom,re.data.data,L.data.data[$t],"refining charge")),ie){if(!q)throw new Error(`Refining Charge Rate UOM is not defined for commodity ${L.data.data[$t]}`);const e=await s.get(`/items/${Et}/${q}`,{params:{fields:[Pt]}});ma(e.data.data,L.data.data[$t]),le=e.data.data[Pt]}const se=await s.get(`/items/${Et}/${V}`,{params:{fields:[Pt]}});ua(se.data.data,L.data.data[$t]);const ce=se.data.data[Pt],de=await k(ce,sa.dry_weight_uom,null==(c=ga[L.data.data.code])?void 0:c.assay_uom);console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}::comm=${L.data.data[$t]}] payableMetalConversion for commodity ${L.data.data.name}: ${JSON.stringify(de)}`),de.initialConversion=1===(null==(u=de.initialConversion)?void 0:u.conversionFactor)?void 0:de.initialConversion,de.finalConversion=1===(null==(m=de.finalConversion)?void 0:m.conversionFactor)?void 0:de.finalConversion;const ue=(null==(f=de.initialConversion)?void 0:f.isConvertByMultiplication)?null!=(h=null==(y=de.initialConversion)?void 0:y.conversionFactor)?h:1:1/(null!=(_=null==(v=de.initialConversion)?void 0:v.conversionFactor)?_:1),me=(null==(w=de.finalConversion)?void 0:w.isConvertByMultiplication)?null!=(E=null==(D=de.finalConversion)?void 0:D.conversionFactor)?E:1:1/(null!=(N=null==(P=de.finalConversion)?void 0:P.conversionFactor)?N:1),fe=null!=(O=g(sa.dry_weight*ue*(null!=G?G:1)*me*("%"!==(null==(M=ga[L.data.data.code])?void 0:M.assay_uom)?1:.01),4))?O:1;console.log(`[generateInvoice] PAYABLE_METAL for commodity ${L.data.data.name}: ${fe}`);const pe=fe*Z;Ea.push({commodity:L.data.data.name,analytical_assay:p(null==(T=ga[L.data.data.code])?void 0:T.analytical_assay,4),deduction_expression:H,payable_assay:p(G,4),assay_uom:null==(I=ga[L.data.data.code])?void 0:I.assay_uom,payable_metal:p(fe,4),payable_metal_expression:`${p(sa.dry_weight,4)}${sa.dry_weight_uom}${de.initialConversion?` ${de.initialConversion.isConvertByMultiplication?"*":"/"} ${p(de.initialConversion.conversionFactor,4)}${de.initialConversion.conversionUom}`:""} * ${p(null!=G?G:1,4)}${"%"!==(null==(U=ga[L.data.data.code])?void 0:U.assay_uom)?`${null==(B=ga[L.data.data.code])?void 0:B.assay_uom}`:" / 100"}${de.finalConversion?` ${de.finalConversion.isConvertByMultiplication?"*":"/"} ${p(de.finalConversion.conversionFactor,4)}${de.finalConversion.conversionUom}`:""}`,payable_metal_uom:ce,qp:R,qp_start_date:A(Q),qp_end_date:A(K),price_method:d,price_rate:p(Z,4),price_per_uom:ce,price:p(pe),treatment_charge:ee?{rate:p(ee.baseTreatmentCharge,4),discount:p((null!=(J=ee.baseTreatmentCharge)?J:0)-(null!=(X=ee.finalValue)?X:0),4),final_rate:p(ee.finalValue,4),per_uom:ne,final_amount:p(g(sa.dry_weight*(null!=(oe=ee.finalValue)?oe:1)*-1,2,!0))}:void 0,refining_charge:ie?{rate:p(ie.baseTreatmentCharge,4),discount:p((null!=(we=ie.baseTreatmentCharge)?we:0)-(null!=(Mt=ie.finalValue)?Mt:0),4),final_rate:p(ie.finalValue,4),per_uom:le,final_amount:p(g(fe*(null!=(Ot=ie.finalValue)?Ot:1)*-1,2,!0))}:void 0,final_total:g(pe-(ee?1:0)*(null!=(It=g(sa.dry_weight*(null!=(Tt=null==ee?void 0:ee.finalValue)?Tt:1),2))?It:1)-(ie?1:0)*(null!=(Rt=g(sa.dry_weight*(null!=(Ut=null==ie?void 0:ie.finalValue)?Ut:1),2))?Rt:1))})}const W=await s.get(`/items/${yt}?filter[${Ze}]=${e}`,{params:{fields:[tt,at,ot,nt,ht,vt,_t,it]}});if(W.data.data.length>0){if(null===R)throw new Error(`Please fill in the field for Penalty Per UOM in contract ${Yt} for commodity ${L.data.data[$t]}`);const e=await s.get(`/items/${Et}/${R}`,{params:{fields:[Pt]}});fa(e.data.data,L.data.data[$t]);const t=e.data.data[Pt],{penalty:a,expression:o,bracket:n}=await S(null==(Jt=ga[L.data.data.code])?void 0:Jt.analytical_assay,W.data.data,Da,t,L.data.data[$t]);console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}::comm=${L.data.data[$t]}] evaluated penalty with an analytical assay=${null==(xt=ga[L.data.data.code])?void 0:xt.analytical_assay}, penaltyRate=${null==n?void 0:n.rate}, finalPenaltyRate=${a}, expression='${o}'`),Pa.push({commodity:L.data.data.name,analytical_assay:p(null==(qt=ga[L.data.data.code])?void 0:qt.analytical_assay,4),deduction_expression:o,assay_uom:null==(Ht=ga[L.data.data.code])?void 0:Ht.assay_uom,penalty_rate:p(null==n?void 0:n.rate,4),penalty_per_uom:t,final_penalty_rate:p(a,4),final_penalty:p((null!=a?a:1)*sa.dry_weight)})}}console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] evaluated commodities=${JSON.stringify(Ea)}`),console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] evaluated penalties${JSON.stringify(Pa)}`);const Sa=Ea.reduce(((e,t)=>e+$(t.price)),0),Aa=Ea.reduce(((e,t)=>{var a;return e+$(null==(a=t.treatment_charge)?void 0:a.final_amount)}),0),Na=Ea.reduce(((e,t)=>{var a;return e+$(null==(a=t.refining_charge)?void 0:a.final_amount)}),0),Ma=Pa.reduce(((e,t)=>e+$(t.final_penalty)),0);console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] TOTAL_REVENUE=${Sa}, TOTAL_TREATMENT_CHARGE=${Aa}, TOTAL_REFINING_CHARGE=${Na}, TOTAL_PENALTIES=${Ma}`);let Oa,Ta=0;const Ia=!!Kt[ae];Ia&&(Ta=Kt[ae].reduce(((e,t)=>e+t.amount),0),Oa={adjustments:Kt[ae].map((e=>({description:e.description,amount:p(e.amount)}))),total_adjustments:p(Ta)});const Ua=aa[Pe],Ba=Sa-Aa-Na-Ma+Ta,ka=null!=Ua?Ba*Ua/100:void 0,ja=await s.get(`/items/${Bt}/${Kt[L]}`,{params:{fields:[kt]}});pa(ja.data.data);const Fa=Kt[z];let Va;Fa&&(Va=await s.get(`/items/${Ft}/${Fa}`,{params:{fields:[Vt]}}),function(e){if(console.log("[validateVessel]"),!e)throw new Error("Vessel for parcel not found");if(!e[Vt])throw new Error("No name defined for vessel of the selected parcel")}(Va.data.data));let Ra=(await s.get(`/items/${Lt}?filter[${Wt}]=${r}`,{params:{fields:["id",Gt]}})).data.data.reduce(((e,t)=>e+(t[Gt]?1:0)),0)+1,Ja=r;const xa=Ra.toString().padStart(2,"0"),qa=(Kt[te],Ja.toString().padStart(2,"0")),La={Counterparty:ja.data.data[kt],Vessel:Va?Va.data.data[Vt]:"Vessel TBA","Shipment Date":Kt[K]?A(new Date(Kt[K])):Kt[Y]?A(new Date(Kt[Y])):"N/A","Arrival Date":Kt[H]?A(new Date(Kt[H])):Kt[Q]?A(new Date(Kt[Q])):"N/A",Status:Kt[K]?"Unfinalised":"Planned",Revision:"Valuation",Invoice:`${Qt}:Valuation`,Parcel:`${Kt[te]} (#${qa})`,"Invoice Due Date":A(e.dueDate),"Dry Weight":`${p(sa.dry_weight,2)}`,"Total Revenues USD":p(Sa),"Total Penalties USD":p(Ma+Aa+Na),...await la(Ea,{dryWeight:sa.dry_weight,dryWeightUom:sa.dry_weight_uom}),"Total Adjustments USD":Ia?Oa.total_adjustments:"0.00","Parcel Value USD":p(Ba),"Parcel Payable Value(Below Line) USD":p(ka),"Payments USD":"-","Due Total":"-",metadata:{invoiceTypeRanking:ta[Qt]}};return console.log(`[generateInvoice][parcel=${Kt[te]}::invoice type=${Qt}] generated forecast invoice=${JSON.stringify(La)}`),La}catch(t){if(t instanceof na)return void console.error(`[generateInvoice][parcel=${e.parcelId}::invoice type=${e.invoiceType}]Non-fatal error: ${t.message}`);throw t}}(e))))),n=function(e){const t=e.reduce(((e,t)=>(e[t.Parcel]||(e[t.Parcel]=[]),e[t.Parcel].push(t),e)),{});Object.keys(t).forEach((e=>{t[e].sort(((e,t)=>e.metadata.invoiceTypeRanking<t.metadata.invoiceTypeRanking?-1:e.metadata.invoiceTypeRanking>t.metadata.invoiceTypeRanking?1:0))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(t)}`),Object.keys(t).forEach((e=>{t[e].forEach(((a,o)=>{if(!a["Parcel Payable Value(Below Line) USD"]||"-"===a["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${a.Invoice} does not have a Parcel Payable Value(Below Line) USD`);const n=$(a["Parcel Payable Value(Below Line) USD"]);if(isNaN(n))throw new Error(`Parcel ${e} for invoice ${a.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${a["Parcel Payable Value(Below Line) USD"]}`);if(0===o){a["Payments USD"]=a["Payments USD"]&&"-"!==a["Payments USD"]?a["Payments USD"]:"0.00";const e=$(a["Payments USD"]);a["Due Total"]=p(n-e)}else{if(!t[e][o-1]["Parcel Payable Value(Below Line) USD"]||"-"===t[e][o-1]["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${a.Invoice} does not have a Parcel Payable Value(Below Line) USD for the previous invoice`);const i=$(t[e][o-1]["Parcel Payable Value(Below Line) USD"]);if(isNaN(i))throw new Error(`Parcel ${e} for invoice ${a.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${t[e][o-1]["Parcel Payable Value(Below Line) USD"]} for the previous invoice`);a["Due Total"]=p(n-i),a["Payments USD"]&&"-"!==a["Payments USD"]||(a["Payments USD"]=t[e][o-1]["Payments USD"])}}))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(t)}`);const a=Object.keys(t).flatMap((e=>t[e]));return console.log(`[evaluateDuePaymentsForCashflow] cashflowAsJsonWithDueTotal=${JSON.stringify(a)}`),a}(o.filter((e=>!!e))),l=n.map((e=>(delete e.metadata,e))),u=aa(l);a("input",l),console.log(`[generateCashflow] cashflow response: ${JSON.stringify(l)}`),console.log(`[generateCashflow] cashflow as csv: ${u}`),r.value=!1,ia(u)}catch(e){i.value=e.message}finally{r.value=!1}},downloadDoc:ia,copy:async function(){l.value=!0;const{id:e,user_created:t,date_created:a,user_updated:o,date_updated:n,cashflow:r,forecast_price:d,...u}=c.value,m=await s.get(`/items/${Yt}`,{params:{filter:{[j]:d},fields:[Xt,Zt,ea,zt]}}),f=await s.post(`items/${Yt}`,m.data.data);if(200!==f.status)return console.log(`[cashflow::copy] duplicate forecast prices response status: ${f.status}`),void(i.value=`Failed to duplicate forecast prices with status ${f.status}`);const p=f.data.data.map((e=>e.id));console.log(`[cashflow::copy] duplicated forecast prices id=${JSON.stringify(p)}`),console.log(`[cashflow::copy] requestBody=${JSON.stringify(u)}`);const y=await s.post("/items/"+J,{forecast_price:p,...u});if(200!==y.status)return console.log(`[cashflow::copy] copy response status: ${y.status}`),void(i.value=`Failed to duplicate cashflow with status ${y.status}`);l.value=!1,window.open(`/admin/content/${J}/${y.data.data.id}`)},isCopying:l,failureReason:i};function ia(e){let t;t=f(e)?aa(c.value.cashflow):e,console.log(`[downloadDoc] csvData=${t}`),oa(t)}async function ra(e,t,a,o,n=!1){if(f(a[X])||f(a[X][e]))throw new Error(`QP Selection is not set for commodity ${t} in the parcel ${a[te]}, please ensure all contract commodities have a QP selection`);const i=await async function(e,t,a,o){var n,i;if(o&&!e.declared)return null;const r=null==e?void 0:e.qp_selected;if(!r)return null;const l=r.split(" "),s={qp_period:parseInt(l[0]),qp_code:l[1]};let c,d,u,m;switch(s.qp_code){case"MAMA":c=null!=(n=t[H])?n:t[Q],d="Actual/Estimated Arrival Date";break;case"MOSS":c=t[Y],d="Estimated Shipment Date";break;case"MOS":case"MOAS":c=null!=(i=t[K])?i:t[Y],d="B/L Date (or Estimated Shipment Date)";break;default:throw new Error(`Unsupported QP code ${s.qp_code} in the contract commodities, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}if(f(c))throw new Error(`Please fill in a date for the field '${d}' for the Parcel form, for QP: ${r}`);const p=new Date(c);if(u=function(e,t){const a=new Date(e.valueOf());return a.setMonth(a.getMonth()+t,1),a}(p,s.qp_period),u.valueOf()>Date.now())return null;return m=T(p,s.qp_period),{provisionalPricingStartDate:u,provisionalPricingEndDate:m,expectedNoOfBusinessDays:null}}(a[X][e],a,0,n);return i}async function la(e,t){console.log(`[mapOutCommoditiesForCashflow] commodities=${JSON.stringify(e)};;containedMetalParam=${JSON.stringify(t)}`);return(await Promise.all(e.map((async e=>{var a,o,n,i,r,l,s;const c=await k(e.payable_metal_uom,t.dryWeightUom,e.assay_uom);console.log(`[mapOutCommoditiesForCashflow] commodity=${e.commodity}, containedMetalUnitConversion=${JSON.stringify(c)}`);const d=(null!=(o=null==(a=c.initialConversion)?void 0:a.conversionFactor)?o:1)*(null!=(i=null==(n=c.finalConversion)?void 0:n.conversionFactor)?i:1),u=("%"===e.assay_uom?.01:1)*e.analytical_assay;return{[`${e.commodity} Payable Metal (${e.payable_metal_uom})`]:e.payable_metal,[`${e.commodity} Contained Metal (${e.payable_metal_uom})`]:p(t.dryWeight*u*d),[`${e.commodity} Revenue (USD)`]:e.price,[`${e.commodity} QP Month`]:sa(new Date(e.qp_start_date)),[`${e.commodity} Price (USD/${e.price_per_uom})`]:e.price_rate,[`${e.commodity} TC (USD)`]:null==(r=e.treatment_charge)?void 0:r.final_amount,[`${e.commodity} TC (USD/${null==(l=e.treatment_charge)?void 0:l.per_uom})`]:null==(s=e.treatment_charge)?void 0:s.final_rate}})))).reduce(((e,t)=>({...e,...t})),{})}function sa(e){return`${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]} ${e.getFullYear()}`}async function ca(e,t,a,o,n,i,r=null,l=1){var d;if(console.log(`[getCommodityAvgPrice] commodity=${e}, commodityId=${t}, source=${a}, startDate=${o}, endDate=${n}, currency=${l}`),f(e))throw new Error(`Commodity ${e} is not defined for price calcualtion`);if(f(a))throw new Error(`Price method for commodity ${e} is not defined for price calcualtion`);if(f(o))throw new Error(`Start date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);if(f(n))throw new Error(`End date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);const u=new Date(o.valueOf());null===i||isNaN(i)||u.setDate(u.getDate()-10);const m=await s.get(`/items/navarch_commodity_price?filter[_and][0][price_method][_eq]=${a}&filter[_and][0][currency][_eq]=${l}&filter[_and][1][date][_between][0]=${N(u)}&filter[_and][1][date][_between][1]=${N(n)}&sort[]=-${qt}`,{params:{fields:[Rt,Jt,xt,qt,"price_method"]}});if((null==(d=m.data)?void 0:d.data)&&Array.isArray(m.data.data)&&m.data.data.length>0){const t=m.data.data[m.data.data.length-1],l=new Date(t[qt]);if(console.log(`[getCommodityAvgPrice] commodity prices=${JSON.stringify(m.data.data)}`),l>=n){if(null!=i&&m.data.data.length<i)throw new Error(`Not enough commodity prices found for commodity ${e} between ${N(o)} and ${N(n)}, please contact Navarch for support`);const t=null===i||isNaN(i)?m.data.data:m.data.data.slice(0,i),l=t.reduce(((t,o)=>{if(!o[xt]&&!o[Jt]&&!o[Rt])throw new Error(`Commodity ${e} for Price Method #${a} on the date of ${o[qt]} does not have a price, please contact Navarch for assistance`);let n;if("PM"===r){if(null===o[Jt])throw new Error(`The price data for the commodity ${e} does not have a Closing Price (PM) for the date of ${o[qt]}, please choose another price fix or provide a Price PM for this date`);n=Number(o[Jt])}else if("AM"===r){if(null===o[Rt])throw new Error(`The price data for the commodity ${e} does not have an Opening Price (AM) for the date of ${o[qt]}, please choose another price fix or provide a Price AM for this date`);n=Number(o[Rt])}else if("Average"===r){if(null===o[xt])throw new Error(`The price data for the commodity ${e} does not have an Average Price for the date of ${o[qt]}, please choose another price fix or provide an Average Price for this date`);n=Number(o[xt])}else if(null!==o[xt])n=Number(o[xt]);else if(null!==o[Jt])n=Number(o[Jt]);else{if(null===o[Rt])throw new Error(`The commodity price for ${e} of Price Method #${a} for the date of ${o[qt]} is not a valid number, please contact Navarch for assistance`);n=Number(o[Rt])}return t+n}),0)/t.length;return console.log(`[getCommodityAvgPrice] average price=${l} for commodity ${e} between ${N(o)} (with over-adjusted start date of ${N(u)}) and ${N(n)}`),{averagePrice:l,startDate:new Date(t[t.length-1][qt]),endDate:new Date(t[0][qt])}}console.log(`[getCommodityAvgPrice] latest comm price date=${l} is before end date=${n}, getting forecast price`)}if(!c.value[j])throw new Error("Please save the Cashflow form first before generating the cashflow doc");const p=await s.get(`/items/${Yt}`,{params:{filter:{[Xt]:{_eq:t},cashflow_forecast_id:{_eq:c.value[j]}},fields:[zt,Xt,Zt,ea]}});!function(e,t){if(!e||!Array.isArray(e)||0===e.length)throw new Error(`No forecast price found for ${t}, please ensure prices have been provided`)}(p.data.data,e);const y=p.data.data.find((e=>{const t=new Date(e[Zt]),a=new Date(e[ea]);return t<=o&&a>=n}));if(!y)throw new Error(`No single forecast price found for commodity ${e} between ${N(o)} and ${N(n)}, please ensure there is only one price value for this range`);return console.log(`[getCommodityAvgPrice] forecast price=${y[zt]} for commodity ${e} between ${N(o)} and ${N(n)}`),{averagePrice:y[zt],startDate:new Date(y[Zt]),endDate:new Date(y[ea])}}function da(e,t){var a,o,n;if(console.log("[validateCommodityData]"),!e)throw new Error("commodity data response is null");if(!e[$t])throw new Error(`Commodity name for commodity ${null!=(a=e[wt])?a:t} is undefined, please contact Navarch for assistance`);if(!e[wt])throw new Error(`Commodity code for commodity ${null!=(o=e[$t])?o:t} is not defined, please contact Navarch for assistance`);if(!e[j])throw new Error(`Commodity ID for commodity ${null!=(n=e[$t])?n:t} is not defined, please contact Navarch for assistance`)}function ua(e,t){if(!e)throw new Error(`Price per UOM for commodity ${t} is not a valid`);if(!e[Pt])throw new Error(`Price per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function ma(e,t){if(!e)throw new Error(`Charge per UOM for commodity ${t} is not a valid`);if(!e[Pt])throw new Error(`Charge per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function fa(e,t){if(!e)throw new Error(`Penalty per UOM for commodity ${t} is not a valid`);if(!e[Pt])throw new Error(`Penalty per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function pa(e){if(console.log("[validateCounterparty]"),!e)throw new Error("Counterparty for parcel not found");if(!e[kt])throw new Error("No codename defined for counterparty of the selected parcel")}}});const $={key:0},w={key:1};var D=[],b=[];!function(e,t){if(e&&"undefined"!=typeof document){var a,o=!0===t.prepend?"prepend":"append",n=!0===t.singleTag,i="string"==typeof t.container?document.querySelector(t.container):document.getElementsByTagName("head")[0];if(n){var r=D.indexOf(i);-1===r&&(r=D.push(i)-1,b[r]={}),a=b[r]&&b[r][o]?b[r][o]:b[r][o]=l()}else a=l();65279===e.charCodeAt(0)&&(e=e.substring(1)),a.styleSheet?a.styleSheet.cssText+=e:a.appendChild(document.createTextNode(e))}function l(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),t.attributes)for(var a=Object.keys(t.attributes),n=0;n<a.length;n++)e.setAttribute(a[n],t.attributes[a[n]]);var r="prepend"===o?"afterbegin":"beforeend";return i.insertAdjacentElement(r,e),e}}(".margin-top-16px[data-v-64969d30] {\n  margin-top: 16px;\n}",{}),g.render=function(e,t,a,o,n,y){const h=i("v-button"),v=i("v-notice");return r(),l(s,null,[c(' <input :value="value" @input="handleChange($event.target.value)" /> '),c(" create a button only interface for Directus"),e.value?(r(),l("div",w,[d(h,{onClick:t[1]||(t[1]=()=>e.downloadDoc())},{default:u((()=>[m("Download Cashflow ")])),_:1})])):(r(),l("div",$,[d(h,{onClick:t[0]||(t[0]=()=>e.generateCashflow()),loading:e.isGeneraingDoc},{default:u((()=>[m("Generate Cashflow")])),_:1},8,["loading"]),e.failureReason?(r(),f(v,{key:0},{default:u((()=>[m(p(e.failureReason),1)])),_:1})):c("v-if",!0)])),d(h,{class:"margin-top-16px",onClick:t[2]||(t[2]=()=>e.copy()),loading:e.isCopying},{default:u((()=>[m("Copy")])),_:1},8,["loading"])],64)},g.__scopeId="data-v-64969d30",g.__file="src/interface.vue";var E=t({id:"navarch-docgen-cashflow",name:"Navarch Cashflow Generator Button",icon:"receipt_long",description:"This is my custom interface for Navarch's Cashflow Doc!",component:g,options:null,types:["json"],group:"standard"});export{E as default};
