import{useApi as e,defineInterface as t}from"@directus/extensions-sdk";import{defineComponent as a,ref as o,inject as n,resolveComponent as r,openBlock as i,createElementBlock as l,Fragment as s,createCommentVNode as c,createVNode as d,withCtx as u,createTextVNode as f,createBlock as m,toDisplayString as p}from"vue";var y=(e=>(e.BRACKET="Bracket",e.MIN_DEDUCTION="Minimum Deduction",e.MAX_CAP="Maximum Cap",e))(y||{}),h=(e=>(e.PERCENTAGE="Percentage",e.FRACTIONAL="Fractional",e))(h||{}),v=(e=>(e.WET_WEIGHT="wet_weight",e.MOISTURE="moisture",e.DRY_WEIGHT="dry_weight",e))(v||{}),_=(e=>(e.METHOD="method",e.WET_WEIGHT_UOM="wet_weight_uom",e.MOISTURE_UOM="moisture_uom",e.DRY_WEIGHT_UOM="dry_weight_uom",e))(_||{});const g={dwt:1.5551739,g:1,kg:1e3,kt:1e9,mt:1e6,mg:.001,Mt:1e12,lb:453.59238,st:907185,t:1e6,oz:31.103477},$={Dwt:["dwt","t"],"g/t":["g","t"],"oz/t":["oz","t"],ppb:["g","t"],ppm:["kg","t"]},w={"%":1e-7,Dwt:1.5551739,"g/t":1,"oz/t":31.103477,ppb:1,ppm:1e3};function D(e){return null==e}function b(e,t=2,a=!1){if(null==e||isNaN(e))return null;const o=a&&e<0;return o&&(e*=-1),Math.round(e*Math.pow(10,t))/Math.pow(10,t)*(o?-1:1)}function E(e,t,a=!0){var o,n;if(e===t)return{conversionValue:1,isConvertByMultiplication:!0};const r=g[e],i=g[t];return r<i?{conversionValue:a?null!=(o=b(i/r,4))?o:1:i/r,isConvertByMultiplication:!1}:{conversionValue:a?null!=(n=b(r/i,4))?n:1:r/i,isConvertByMultiplication:!0}}function S(e,t){var a,o;if(e===t||D(e)||D(t))return{conversionValue:1,isConvertByMultiplication:!0};const n=w[e],r=w[t];return n<r?{conversionValue:null!=(a=b(r/n,4))?a:1,isConvertByMultiplication:!1}:{conversionValue:null!=(o=b(n/r,4))?o:1,isConvertByMultiplication:!0}}function P(e,t,a){if(void 0===e||void 0===t||null===e||null===t)return;const o=e.split("/"),n=t.split("/");if(o.length>2||n.length>2)throw new Error(`[getConversionUnit] sourceUnit=${e} and targetUnit=${t} must be in the format of 'unit1/unit2', an extra '/' was found`);if(1===o.length&&1===n.length)return a?`${n[0]}/${o[0]}`:`${o[0]}/${n[0]}`;if(1===o.length){const e=n[0]===o[0]?"":`${n[1]}(${o[1]})`,t=n[1];return""===t?a?e:`/${e}`:a?`${e}/${t}`:`${t}/${e}`}if(1===n.length){const e=o[1],t=o[0]===n[0]?"":`${o[1]}(${n[0]})`;return""===t?a?e:`/${e}`:a?`${e}/${t}`:`${t}/${e}`}{const e=o[0]===n[0],t=o[1]===n[1],r=e||""===o[0],i=e||""===n[0],l=t||""===o[1],s=t||""===n[1],c=!l&&!i,d=!r&&!s,u=`${l?"":o[1]}${c?"(":""}${i?"":`${n[0]}`}${c?")":""}`,f=`${r?"":o[0]}${d?"(":""}${s?"":`${n[1]}`}${d?")":""}`;return""===f?a?u:`/${u}`:a?`${u}/${f}`:`${f}/${u}`}}function C(e,t,a,o=!0){if("%"===e){if(t===a)return{initialAssayConversion:{conversionValue:100,isConvertByMultiplication:!1}};const e=E(t,a,o);return e.conversionUOM=P(t,a,e.isConvertByMultiplication),{initialAssayConversion:{conversionValue:100,isConvertByMultiplication:!1},finalWeightConversion:e}}let n=e.split("/");if(1===n.length&&(n=$[e],!n))throw new Error(`[getConversionFactorForAssayUnitToMultiplySourceWeightUnitIntoTargetWeightUnit] assay unit composition for assayUnit=${e} is undefined`);if(2!==n.length)throw new Error(`[getConversionFactorForAssayUnitToMultiplySourceWeightUnitIntoTargetWeightUnit] assay unit composition for assayUnit=${e} must be in the format of 'weightUnit1/weightUnit2'`);const[r,i]=n,l={};return i!==t&&(l.initialAssayConversion=E(t,i,o),l.initialAssayConversion.conversionUOM=P(t,i,l.initialAssayConversion.isConvertByMultiplication)),r!==a&&(l.finalWeightConversion=E(r,a,o),l.finalWeightConversion.conversionUOM=P(r,a,l.finalWeightConversion.isConvertByMultiplication)),l}var A=a({props:{value:{type:Object,default:null}},emits:["input"],setup(t,{emit:a}){const r=o(""),i=o(!1),l=o(!1),s=e(),c=n("values",o({}));console.log("[main] formValues=",c);const d=new Map;function u(e){if(console.log("[evaluateWeightData]"),0===e.length)return;const t=m(e,v.DRY_WEIGHT),a=m(e,v.WET_WEIGHT);return{method:f(e,_.METHOD),lots:e,dry_weight_uom:f(e,_.DRY_WEIGHT_UOM),wet_weight_uom:f(e,_.WET_WEIGHT_UOM),dry_weight:t,wet_weight:a,moisture:(a-t)/a*100}}function f(e,t){if(console.log("[getFirstValueAsSharedValue]"),0!==e.length)return console.log(`lots[0][${t.toString()}]=${e[0][t.toString()]}`),e[0][t.toString()]}function m(e,t){return console.log("[evaluateAggregateValue]"),e.reduce(((e,a)=>{var o;return e+parseFloat(null!=(o=a[t.toString()])?o:"0")}),0)}function p(e){return null==e}function g(e,t=2,a=!0){if(console.log("[formatNumber]"),isNaN(e)||null===e)return"-";const o=Math.round(e*Math.pow(10,t))/Math.pow(10,t),[n,r]=o.toString().split("."),i=n.replace(/\B(?=(\d{3})+(?!\d))/g,",");if(!r&&!a)return i;return`${i}.${(null!=r?r:"").padEnd(t,"0")}`}function $(e,t=2,a=!1){if(p(e)||isNaN(e))return null;const o=a&&e<0;return o&&(e*=-1),Math.round(e*Math.pow(10,t))/Math.pow(10,t)*(o?-1:1)}function w(e){if(console.log("[parseNumber]"),"number"==typeof e)return e;if(!e||"-"===e)return 0;const t=parseFloat(e.replace(/[^\d.-]/g,""));return console.log(`[parseNumber] number: ${e} to ${t}`),t}function D(e,t){return console.log("[findBracket]"),e.find((e=>{var a,o;const n=t>(null!=(a=e.lower_threshold)?a:0)&&(p(e.upper_threshold)||t<e.upper_threshold)||e.lower_threshold_inclusive&&t===(null!=(o=e.lower_threshold)?o:0)||e.upper_threshold_inclusive&&t===e.upper_threshold;return console.log(`[findBracket] value=${t} for bracket: ${JSON.stringify(e)}? match=${!!n}`),n}))}function b(e,t,a=!1){var o,n,r,i,l,s,c,d,u,f,m;console.log("[evaluateFinalValueFromBrackets]");let p=(e-(null!=(o=t.initial_adjustment)?o:0)*(t.initial_adjustment_conversion_by_multiplication?null!=(n=t.initial_adjustment_conversion_factor)?n:1:1/(null!=(r=t.initial_adjustment_conversion_factor)?r:1)))*(null!=(i=t.rate)?i:0)*(t.rate_type===h.PERCENTAGE?.01:1)+(null!=(l=t.final_adjustment)?l:0)*(t.final_adjustment_conversion_factor?null!=(s=t.final_adjustment_conversion_factor)?s:1:1/(null!=(c=t.final_adjustment_conversion_factor)?c:1));switch(p=a&&p<0?0:p,t.bracket_type){case y.MIN_DEDUCTION:if(null===t.comparator||void 0===t.comparator)throw new Error("Minimum deduction not found");const o=t.comparator*(t.comparator_conversion_by_multiplication?null!=(d=t.comparator_conversion_factor)?d:1:1/(null!=(u=t.comparator_conversion_factor)?u:1));return e-p<o?$(a&&e-o<0?0:e-o,4):p;case y.MAX_CAP:if(null===t.comparator||void 0===t.comparator)throw new Error("Maximum cap not found");const n=t.comparator*(t.comparator_conversion_by_multiplication?null!=(f=t.comparator_conversion_factor)?f:1:1/(null!=(m=t.comparator_conversion_factor)?m:1));return $(p>n?n:p,4);case y.BRACKET:return $(p,4);default:throw new Error(`bracket type ${t.bracket_type} is not supported`)}}async function E(e,t,a,o){var n,r,i,l,s,c,d,u;if(console.log("[evaluatePayableAssay]"),!a||0===a.length)return{};const f=D(a,e);if(!f)throw new Error(`Unable to find the range for analytical assay value of ${e}, please ensure the payable assay rates for the commodity ${o} are defined in the contract cover all range of possible values`);let m,p,v=1,_=!0;if(f.initial_adjustment_uom&&void 0!==f.initial_adjustment_uom&&null!==f.initial_adjustment_uom&&f.initial_adjustment_uom!==t){const e=S(f.initial_adjustment_uom,t);v=e.conversionValue,m=P(f.initial_adjustment_uom,t,e.isConvertByMultiplication),_=e.isConvertByMultiplication}let w,E=1,C=!0;if(f.bracket_type===y.MAX_CAP){if(p=null!=(n=f.maximum_cap)?n:0,void 0!==f.maximum_cap_uom&&null!==f.maximum_cap_uom&&f.maximum_cap_uom!==t){const e=S(f.maximum_cap_uom,t);E=e.conversionValue,w=P(f.maximum_cap_uom,t,e.isConvertByMultiplication),C=e.isConvertByMultiplication}}else if(f.bracket_type===y.MIN_DEDUCTION&&(p=null!=(r=f.minimum_deduction)?r:0,void 0!==f.minimum_deduction_uom&&null!==f.minimum_deduction_uom&&f.minimum_deduction_uom!==t)){const e=S(f.minimum_deduction_uom,t);E=e.conversionValue,w=P(f.minimum_deduction_uom,t,e.isConvertByMultiplication),C=e.isConvertByMultiplication}const A={bracket_type:f.bracket_type,rate:null!=(i=f.rate)?i:1,rate_type:null!=(l=f.rate_type)?l:h.FRACTIONAL,initial_adjustment:null!=(s=f.initial_adjustment)?s:0,initial_adjustment_conversion_factor:v,initial_adjustment_conversion_by_multiplication:_,comparator:p,comparator_conversion_factor:E,comparator_conversion_by_multiplication:C};console.log(`[evaluatePayableAssay] bracketForEvaluation: ${JSON.stringify(A)}`);const T=b(e,A,!0);let O="";const I=void 0!==f.initial_adjustment&&null!==f.initial_adjustment;if(f.bracket_type===y.BRACKET)O=`${I?"(":""}${g(e,4)}${null!=t?t:""}${I?` - ${g(f.initial_adjustment,4)}${null!=(c=f.initial_adjustment_uom)?c:`${null!=t?t:""}`}`:""}${I&&1!==v?` ${_?"*":"/"} ${g(v,4)}${m}`:""}${I?")":""} * ${g(f.rate,4)}${f.rate_type===h.PERCENTAGE?"/100":`/${g(1,4)}`}`;else if(f.bracket_type===y.MIN_DEDUCTION){O=T===$(e-(null!=p?p:0)*(C?null!=E?E:1:1/(null!=E?E:1)),4)?`${g(e,4)}${null!=t?t:""} - ${g(p,4)}${null!=t?t:""}${1!==E?` ${C?"*":"/"} ${g(E,4)}${w}`:""}`:`${I?"(":""}${g(e,4)}${null!=t?t:""}${I?` - ${g(f.initial_adjustment,4)}${null!=(d=f.initial_adjustment_uom)?d:`${null!=t?t:""}`}`:""}${I&&1!==v?` ${_?"*":"/"} ${g(v,4)}${m}`:""}${I?")":""} * ${g(f.rate,4)}${f.rate_type===h.PERCENTAGE?"/100":`/${g(1,4)}`}`}else{if(f.bracket_type!==y.MAX_CAP)throw new Error(`[buildPayableAssayExpression] unknown bracket method: ${f.bracket_type}`);O=T===$((null!=p?p:0)*(C?null!=E?E:1:1/(null!=E?E:1)),4)?`${g(p,4)}${null!=t?t:""}${1!==E?` ${C?"*":"/"} ${g(E,4)}${w}`:""}`:`${I?"(":""}${g(e,4)}${null!=t?t:""}${I?` - ${g(f.initial_adjustment,4)}${null!=(u=f.initial_adjustment_uom)?u:`${null!=t?t:""}`}`:""}${I&&1!==v?` ${_?"*":"/"} ${g(v,4)}${m}`:""}${I?")":""} * ${g(f.rate,4)}${f.rate_type===h.PERCENTAGE?"/100":`/${g(1,4)}`}`}return{payableAssay:T,expression:O}}const A="above the lower threshold, plus",T="below the upper threshold, minus";function O(e,t,a,o,n,r){var i,l,s,c,d,u,f;if(console.log("[evaluateCharge]"),!a||!a.length)return;const m=D(a,e);if(!m)throw new Error(`Unable to find the bracket range for the ${r} value of ${e}, please ensure the ${n} rates for commodity ${o} are defined in the contract cover all range of possible values`);let p=0,v=1;if(m.use_btc)v=0,p=0;else{const e=null!=(i=m.escalator_reference)?i:1;if(v=(null!=(l=m.rate)?l:1)/e,m.for_every_unit===A)p=null!=(s=m.lower_threshold)?s:0;else{if(m.for_every_unit!==T)throw new Error(`[evaluateCharge] unknown for_every_unit: ${m.for_every_unit}`);p=null!=(c=m.upper_threshold)?c:0}}const _={bracket_type:y.BRACKET,rate:v,rate_type:h.FRACTIONAL,initial_adjustment:p,final_adjustment:(null!=(d=m.base_treatment_charge)?d:0)+(null!=(u=m.base_charge_adjustment)?u:0)};return console.log(`[evaluateCharge] bracketForEvaluation: ${JSON.stringify(_)}`),{finalValue:b(e,_),baseTreatmentCharge:m.base_treatment_charge+(null!=(f=m.base_charge_adjustment)?f:0)}}function I(e,t,a,o,n){var r,i,l,s;if(console.log("[evaluatePenalty]"),!t||!t.length)return{};const c=D(t,e);if(!c)throw new Error(`Unable to find the range for the analytical assay value of ${e}, please ensure the penalty rates for commodity ${n} are defined in the contract cover all range of possible values`);let d=0,u=1;if(c.no_penalty)u=0,d=0;else{const e=null!=(r=c.escalator_reference)?r:1;if(u=(null!=(i=c.rate)?i:1)/e,c.for_every_unit===A)d=null!=(l=c.lower_threshold)?l:0;else{if(c.for_every_unit!==T)throw new Error(`[evaluatePenalty] unknown for_every_unit: ${c.for_every_unit}`);d=null!=(s=c.upper_threshold)?s:0}}const f={bracket_type:y.BRACKET,rate:u,rate_type:h.FRACTIONAL,initial_adjustment:d,final_adjustment:0};console.log(`[evaluatePenalty] bracketForEvaluation: ${JSON.stringify(f)}`);const m=b(e,f),p=null!=f.initial_adjustment;let v="";return v=c.rate&&0!==c.rate?`${p?"(":""}${g(e,4)}${p?` - ${g(d,4)})`:""} / ${g(1,4)} * ${null!=a?a:""} ${g(u,4)}/${null!=o?o:""}`:"No penalty",{penalty:m,expression:v,bracket:c}}function N(e){const t=e.getDate(),a=e.getMonth(),o=e.getFullYear();return`${t} ${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][a]} ${o}`}function M(e,t=!0){const a=e.getMonth()+1,o=e.getDate();return`${e.getFullYear()}${t?"-":" "}${a<10?"0":""}${a}${t?"-":" "}${o<10?"0":""}${o}`}function U(e){return 0===e.getDay()||6===e.getDay()}function k(e,t,a=!1){const o=new Date(e.valueOf());let n=t-(a?1:0),r=!0;for(;U(o);)o.setDate(o.getDate()+1),r&&(n-=1,r=!1);for(;n>0;)o.setDate(o.getDate()+1),U(o)||(n-=1);for(o.getHours()>=12&&o.setDate(o.getDate()+1);U(o);)o.setDate(o.getDate()+1);return o}function j(e,t){const a=new Date(e.valueOf());return a.setMonth(a.getMonth()+t,1),a}function V(e,t){const a=new Date(e.valueOf());return a.setMonth(a.getMonth()+t+1,0),a}const B="id",F="related_parcel",W="lot_number",J="method",R="navarch_cashflow",q="navarch_parcel",x="contract",G="counterparty",L="actual_arrival_date",H="estimate_arrival_date",Q="bl_date",K="invoice_due_date",Y="estimated_shipment_date",z="qp_selection",X="vessel",Z="origin",ee="destination",te="shipment_code",ae="adjustments",oe="parcel_finalisation_date",ne="navarch_assay_lot",re="commodity",ie="dry_weight",le="dry_weight_uom",se="buyer_assay",ce="seller_assay",de="final_assay",ue="assay_uom",fe="lot_number",me="navarch_weight_lot",pe="dry_weight",ye="wet_weight",he="moisture",ve="wet_weight_uom",_e="dry_weight_uom",ge="navarch_contract",$e="contract_currency",we="name",De="gst_applicable",be="gst_rate",Ee="navarch_contract_payment_information",Se="related_contract",Pe="invoice_type",Ce="pay_percent",Ae="pa_days",Te="pa_day_type",Oe="pa_ref_day",Ie="pp_days",Ne="pp_day_type",Me="pp_ref_day",Ue="navarch_commodity_in_contract",ke="contract",je="commodity",Ve="primary_commodity",Be="payable_commodity",Fe="price_method",We="price_fix_to_use",Je="price_per_uom",Re="treatment_charge_per_uom",qe="tc_reference",xe="refining_charge_rate_uom",Ge="quotational_periods",Le="payable_assay_rates",He="penalty_rates",Qe="penalty_per_uom",Ke="navarch_payable_assay_bracket",Ye="initial_adjustment",ze="initial_adjustment_uom",Xe="minimum_deduction",Ze="minimum_deduction_uom",et="maximum_cap",tt="maximum_cap_uom",at="related_commodity_in_contract",ot="bracket_type",nt="lower_threshold",rt="lower_threshold_inclusive",it="upper_threshold",lt="upper_threshold_inclusive",st="rate",ct="rate_type",dt="navarch_treatment_charge_bracket",ut="base_treatment_charge",ft="base_charge_adjustment",mt="use_btc",pt="escalator_reference",yt="for_every_unit",ht="related_contract_commodity_tc",vt="related_contract_commodity_rc",_t="navarch_penalty_bracket",gt="no_penalty",$t="escalator_reference",wt="for_every_unit",Dt="navarch_commodity",bt="name",Et="code",St="navarch_currency",Pt="code",Ct="navarch_unit",At="symbol",Tt="dry_symbol",Ot="wet_symbol",It="dry_unit",Nt="wet_unit",Mt="navarch_counterparty",Ut="codename",kt="navarch_vessel",jt="name",Vt="price_am",Bt="price_pm",Ft="date",Wt="navarch_invoices",Jt="parcel",Rt="invoice",qt="invoice_date",xt="amount_paid",Gt="invoice_type",Lt="end_date",Ht="start_date",Qt="navarch_forecast_price",Kt="commodity",Yt="price",zt="start_date",Xt="end_date",Zt=new Date("0000"),ea={Advance:0,"Second Advance":1,"Third Advance":2,"Fourth Advance":3,Provisional:4,"Second Provisional":5,"Third Provisional":6,"Fourth Provisional":7,Final:8};function ta(e){const t=[...new Set(e.flatMap((e=>Object.keys(e))))],a=["Total Penalties USD","Total Adjustments USD","Total Revenues USD","Parcel Value USD","Parcel Payable Value USD","Payments USD","GST Payable USD","Due Total"];for(const e of a){const a=t.indexOf(e);-1!==a&&(t.splice(a,1),t.push(e))}const o=e.map((e=>t.map((t=>{const a=e[t]||"";return"string"==typeof a&&a.includes(",")?`"${a}"`:a})).join(",")));return[t.join(","),...o].join("\n")}function aa(e){const t=new Blob([e],{type:"text/csv"}),a=URL.createObjectURL(t),o=document.createElement("a");o.href=a,o.download=`Cashflow-[${function(){const e=new Date,t=60*e.getTimezoneOffset()*1e3,a=e.getTime()-t,o=new Date(a),n=o.toISOString().slice(0,19),r=e.getTimezoneOffset()/60*-1;return`${n}GMT${r>0?"+":""}${r}`.replace(/:/g,"")}()}]-Valuation_Period-(${M(new Date(c.value.start_date),!1)}~${M(new Date(c.value.end_date),!1)}).csv`,document.body.appendChild(o),o.click(),document.body.removeChild(o)}class oa extends Error{constructor(e){super(e),this.name="NonFatalError",Object.setPrototypeOf(this,oa.prototype)}}return{isGeneraingDoc:i,invoiceUrl:c.value,generateCashflow:async function(){r.value="";try{i.value=!0,d.clear(),console.log("[generateCashflow] API cache cleared");const e=await async function(){var e,t,a,o,n,i,l,d,u;const f=new Date(c.value[Ht]);if("Invalid Date"===f.toString())throw r.value="Start date is invalid",new Error("Start date is invalid");const m=new Date(c.value[Lt]);if("Invalid Date"===m.toString())throw r.value="End date is invalid",new Error("End date is invalid");const y=await s.get(`/items/${ge}`,{params:{fields:[we,B,"invoice_type"]}}),h={};for(const r of y.data.data){const c=await s.get(`/items/${Ee}`,{params:{filter:{[Se]:{_eq:r[B]}},fields:[Pe,Ae,Te,Oe]}});console.log(`[getApplicableParcelsData] allPaymentInformation.data.data=${JSON.stringify(c.data.data)}::${r[we]}`);const y=await s.get(`/items/${q}`,{params:{filter:{[x]:{_eq:r[B]}},fields:[B,te,L,H,Q,Y,oe,K]}}),v=c.data.data.map((e=>e[Pe])).sort(((e,t)=>ea[e]-ea[t]));console.log(`[getApplicableParcelsData] 1-sortedListOfPossibleInvTypes=${JSON.stringify(v)}::${r[we]}`);for(const _ of c.data.data){const c={days:_[Ae],day_type:_[Te],ref_day:"Final"===_[Gt]?"QP Month + n days":_[Oe]};if(!c)throw new Error(`Contract ${r[we]} does not have a payment advice for invoice type ${_[Gt]}`);let g,$="";for(const w of y.data.data){const y=await s.get(`/items/${Wt}`,{params:{filter:{[Jt]:{_eq:w[B]},[Gt]:{_eq:_[Pe]},[Rt]:{_nnull:!0}},fields:[Rt]}});let D;if((null==(t=null==(e=y.data)?void 0:e.data)?void 0:t.length)>0&&(null==(a=y.data)?void 0:a.data[0][Rt])){D=new Date(y.data.data[0][Rt].due_date),console.log(`[getApplicableParcelsData] exsiting invoice found with due date=${D}::${r[we]}:${w[te]}:${_[Pe]}`),D<f&&D>m&&(D=Zt),h[w[B]]||(h[w[B]]=[]),h[w[B]].push({invoiceType:_[Pe],dueDate:D,parcelId:w[B],contractName:r[we],sortedListOfInvTypesFromContract:v});continue}switch(c.ref_day){case"Arrival Date":$="Actual Arrival Date from the Parcel form",g=null!=(o=w[L])?o:w[H];break;case"B/L Date":$="B/L Date (or Estimated Shipment Date) from the Parcel form",g=null!=(n=w[Q])?n:w[Y];break;case"End of Month of Delivery":$="B/L Date (or Estimated Shipment Date) from the Parcel form",g=null!=(i=w[Q])?i:w[Y];const e=new Date(g);e.setMonth(e.getMonth()+1,0),g=M(e);break;case"Invoice Date":$="Invoice Date (using the B/L Date or Estimated Shipment Date from the Parcel form)",g=null!=(l=w[Q])?l:w[Y];break;case"Estimated Shipment Date":$="Estimated Shipment Date from the Parcel form",g=w[Y];break;case"QP Month + n days":const t=await s.get(`items/${Ue}`,{params:{filter:{[ke]:{_eq:r[B]},[Be]:{_eq:!0}},fields:[Ge]}});if(!Array.isArray(t.data.data)||0===t.data.data.length)throw new Error(`Contract ${r[we]} does not have any payable commodities`);const a=t.data.data.map((e=>e[Ge].find((e=>!!e.default)))),f=a.reduce(((e,t)=>t.qp_period>e.qp_period?t:e),a[0]);let m;switch(f.qp_code){case"MAMA":$="Actual Arrival Date (or Estimated Arrival Date) from the Parcel form",m=null!=(d=w[L])?d:w[H];break;case"MOSS":case"MOS":case"MOAS":$="B/L Date (or Estimated Shipment Date) from the Parcel form",m=null!=(u=w[Q])?u:w[Y];break;default:throw new Error(`Unsupported QP code ${f.qp_code}, currently only supports MAMA, MOS, MOSS, and MOAS`)}if(p(m))throw new Error(`Invalid reference date, please ensure the ${$} field(s) in parcel ${w[te]} are filled in`);g=V(new Date(m),f.qp_period).toISOString();break;default:throw new Error(`Invalid reference day for payment advice: ${c.ref_day}; please contact Navarch for support`)}if(null==g)throw new Error(`Reference day for payment advice ${$} is empty in parcel ${w[te]}`);const b=new Date(g),E=parseInt(c.days),S=c.day_type;switch(S){case"Business Day(s)":D=k(b,E);break;case"Calendar Day(s)":D=new Date(b.valueOf()),D.getHours()>=12?D.setDate(D.getDate()+E+1):D.setDate(D.getDate()+E);break;default:throw new Error(`Please provide a valid Day Type (Cashflow) for ${r[we]}:Final Invoice Type`)}if(console.log(`[getApplicableParcels] payment advice ref date: ${b.toString()} plus ${E} ${S} equals due date: ${D.toString()}::${r[we]}:${w[te]}:${_[Pe]}`),D>=f&&D<=m&&(h[w[B]]||(h[w[B]]=[]),h[w[B]].push({invoiceType:_[Pe],dueDate:D,parcelId:w[B],contractName:r[we],sortedListOfInvTypesFromContract:v})),w[K]){const e=w[K][_[Pe]];if(e&&e.due_date){const t=e.inv_type,a=new Date(e.due_date);if("Invalid Date"===a.toString())throw new Error(`Invoice Due Date field in the parcel ${w[te]} has an invalid due date for invoice type ${t}`);if(a>=f&&a<=m){h[w[B]]||(h[w[B]]=[]);const e={invoiceType:t,dueDate:a,parcelId:w[B],contractName:r[we],sortedListOfInvTypesFromContract:v},o=h[w[B]].findIndex((e=>e.invoiceType===t));-1!==o?h[w[B]][o]=e:h[w[B]].push(e)}else if(h[w[B]]){const e=h[w[B]].findIndex((e=>e.invoiceType===t));-1!==e&&h[w[B]].splice(e,1)}}}}}}console.log(`[getApplicableParcels] invoice types by parcel id: ${JSON.stringify(h)}`),Object.values(h).forEach((e=>{var t;if(!e||0===e.length)return;const a=e.reduce(((e,t)=>e&&ea[t.invoiceType]<ea[e.invoiceType]?t:e),e[0]);if(console.log(`[getApplicableParcels] earliestInvoiceType=${JSON.stringify(a)}`),!a)throw new Error(`Could not find the earliest invoice type for parcel with ID: ${null==(t=e[0])?void 0:t.parcelId}`);if(new Date(a.dueDate)<f)return;console.log(`[getApplicableParcelsData] sorted list of possible inv types=${JSON.stringify(a.sortedListOfInvTypesFromContract)}`);const o=a.sortedListOfInvTypesFromContract.findIndex((e=>e===a.invoiceType));if(-1===o)throw new Error(`Could not find the invoice type ${a.invoiceType} in the list of Contract Payment Information (${a.sortedListOfInvTypesFromContract.join(", ")}) for parcel with ID: ${a.parcelId}`);if(o>0){if(!h[a.parcelId])throw new Error(`No invoice data recorded for parcel with ID: ${a.parcelId} when evaluating due dates for each invoice type`);h[a.parcelId].push({invoiceType:a.sortedListOfInvTypesFromContract[o-1],dueDate:Zt,parcelId:a.parcelId,contractName:a.contractName,sortedListOfInvTypesFromContract:a.sortedListOfInvTypesFromContract})}}));const v=Object.keys(h);let _;for(let e=0;e<v.length;e+=15){const t=v.slice(e,e+15),a=await s.get(`/items/${q}`,{params:{filter:{[B]:{_in:t}},fields:[B,x,G,L,H,Q,Y,z,X,Z,ee,te,ae,"parcel_finalised",oe]}});_?_.data.data=_.data.data.concat(a.data.data):_=a}if(!_.data.data||_.data.data.length!==v.length)throw new Error("Experiencing some network issues, please try again. If the issue persists, contact Navarch for support");const g={parcelData:_.data.data.reduce(((e,t)=>(e[t[B]]=t,e)),{}),contractNameByParcelId:v.reduce(((e,t)=>(e[t]=h[t][0].contractName,e)),{}),invoiceTypeParcel:v.flatMap((e=>h[e])),parcelIds:v};return console.log(`[getApplicableParcels] returnObject=${JSON.stringify(g)}`),g}(),t=await async function(e){const t=[];let a;for(let t=0;t<e.parcelIds.length;t+=15){const o=e.parcelIds.slice(t,t+15),n=await s.get(`/items/${Wt}`,{params:{filter:{[Jt]:{_in:o},[Rt]:{_nnull:!0}},fields:[Jt,Gt,Rt,qt,xt]}});a?a.data.data=a.data.data.concat(n.data.data):a=n}a.data.data.sort(((e,t)=>{const a=ea[e[Gt]]-ea[t[Gt]];return 0===a?new Date(t[qt]).valueOf()-new Date(e[qt]).valueOf():a}));for(const o of e.invoiceTypeParcel){const n=a.data.data.find((e=>e[Jt]===o.parcelId&&e[Gt]===o.invoiceType));n?t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:n[xt]?Zt:o.dueDate,invoiceData:{...n[Rt],amount_paid:n[xt]}}):t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,parcelData:e.parcelData[o.parcelId]})}return console.log(`[generateInvoiceParamForParcel] invoiceParams=${JSON.stringify(t)}`),t}(e);console.log(`[generateCashflow] form values=${JSON.stringify(c.value)}`);const o=await Promise.all(t.map((async e=>(console.log(`[generateCashflow] invoiceParam=${JSON.stringify(e)}`),await async function(e){var t,a,o,n,l,c,d,f,m,y,h,v,_,D,b,S,P,A,T,M,U,k,j,V,R,K,z,oe,Vt,Bt,Ft,qt,xt,Gt,Lt,Ht,Qt,Kt,Yt;r.value="",i.value=!0;try{if(e.invoiceData){console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] using existing invoice=${JSON.stringify(e.invoiceData)}`);const a=e.invoiceData;if(!a.buyer_id)throw new Error(`Invoice ${a.invoice_number} does not have a buyer ID`);const o=await s.get(`/items/${Mt}/${a.buyer_id}`,{params:{fields:[Ut]}});pa(o.data.data);const n=await s.get(`/items/${q}`,{params:{filter:{[B]:{_eq:e.parcelId}},fields:[Q,L,H]}});console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] parcel date data=${JSON.stringify(n.data.data)}`);const r=n.data.data[0];return{parcelId:e.parcelId,Parcel:a.parcel,Counterparty:o.data.data[Ut],Vessel:"N/A"===a.vessel?"Vessel TBA":a.vessel,"Shipment Date":a.bl_date,"Arrival Date":r[L]?N(new Date(r[L])):r[H]?N(new Date(r[H])):"N/A",Status:n[Q]?"Unfinalised":"Planned",Revision:"Original",Invoice:`${a.invoice_type}:Original`,"Invoice Due Date":N(e.dueDate),"Dry Weight":`${g(a.dry_weight,2)}`,"Dry Weight UOM":a.dry_weight_uom,...await la(a.commodities,{dryWeight:a.dry_weight,dryWeightUom:a.dry_weight_uom}),"Total Penalties USD":g(a.total_deductions),"Total Adjustments USD":a.adjustments?g(a.adjustments.total_adjustments):"0.00","Total Revenues USD":g(a.total_revenue),"Parcel Value USD":g(a.invoice_value),"Parcel Payable Value USD":g(a.payable_amount),"Payments USD":a.amount_paid,"GST Payable USD":g(null==(t=a.balance_of_gst_payable)?void 0:t.gst_in_usd),"Due Total":g(a.balance_in_sellers_favor),metadata:{invoiceTypeRanking:ea[a.invoice_type]}}}if(void 0===e.parcelData)throw new oa(`Something went wrong, no parcel or invoice data for Invoice of parcel id ${e.parcelId.substring(0,5)} and invoice type ${e.invoiceType}`);const i=e.parcelId;if(!i)return void console.error(`[generateInvoice] A parcel id is not defined for invoice type ${e.invoiceType}`);const Xt=e.invoiceType,Zt=e.parcelData,ta=e.contractName;console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] parcel data=${JSON.stringify(Zt)}`),function(e){if(!e)throw new Error("Parcel data not found, please ensure the selected parcel still exists");if(!e[te])throw new Error("One of the parcels does not have a shipment code, please ensure that all parcels have a shipment code");if(!e[x])throw new Error(`The parcel ${e[te]} does not have a contract, please ensure that the contract field for the parcel is not empty`);if(!e[G])throw new Error(`The parcel ${e[te]} does not havea counterparty, please ensure that the counterparty field for the parcel is not empty`);if(!e[Z])throw new Error(`The parcel ${e[te]} does not havean origin port`);if(!e[ee])throw new Error(`The parcel ${e[te]} does not havea destination port`)}(Zt);const aa=Zt[x];if(!aa)throw new Error(`Contract not found for parcel ${Zt[te]}`);const na=await s.get(`/items/${Ee}`,{params:{filter:{[Se]:{_eq:aa},[Pe]:{_eq:Xt}},fields:[Pe,Ce,Ae,Te,Oe,Ie,Ne,Me]}});if(na.data.data&&0===na.data.data.length)throw new Error(`No invoice type found for the contract ${ta}`);const sa=na.data.data.find((e=>e[Pe]===Xt));if(!sa)throw new Error(`Cannot find payment information for ${Xt} in the contract ${ta}, please ensure that data for it has been entered and saved`);const ya=await s.get(`/items/${me}?filter[${F}]=${i}&filter[${W}][_nnull]=true&sort[]=${W}`,{params:{fields:[B,pe,ye,J,he,ve,_e]}});console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] weight lots data=${JSON.stringify(ya.data.data)}`),function(e){if(!e||0===e.length)throw new oa("No weight lots found for the selected parcel")}(ya.data.data);const ha=function(e){console.log("[evaluateWeights]");const t={};for(const a of e)t[a.method]||(console.log(`adding method ${a.method} to weightData object`),t[a.method]=[]),console.log(`adding lot ${a.id} to weightData.${a.method} array`),t[a.method.toString()].push(a);const a=[];for(const e of Object.keys(t)){if(!t[e]){console.log(`method=${e} does not exist in weightData object`);continue}console.log(`adding lots and other values to weights for method=${e}`);const o=u(t[e]);o&&a.push(o)}return a}(ya.data.data);let va;if(va||(va=ha.find((e=>"Outturn"===e.method))),va||(va=ha.find((e=>"Inturn Final"===e.method))),va||(va=ha.find((e=>"Inturn"===e.method))),va||(va=ha.find((e=>"Estimated"===e.method))),va||(va=ha.find((e=>"Planned"===e.method))),!va)throw new Error(`No weight lots with valid method found for parcel ${Zt[te]}`);if(void 0===va.dry_weight||null===va.dry_weight||void 0===va.wet_weight||null===va.wet_weight||void 0===va.moisture||null===va.moisture||void 0===va.dry_weight_uom||null===va.dry_weight_uom||void 0===va.wet_weight_uom||null===va.wet_weight_uom||void 0===va.method||null===va.method)throw new Error(`One of the fields for the latest weight lots data is undefined for parcel ${Zt[te]}`);const _a=await s.get(`/items/${Ct}?filter[${Tt}]=${va.dry_weight_uom}`,{params:{fields:[It]}}),ga=await s.get(`/items/${Ct}?filter[${Ot}]=${va.wet_weight_uom}`,{params:{fields:[Nt]}});if(!_a.data.data||!_a.data.data[0]||!_a.data.data[0][It])throw new Error(`Dry weight uom not found for symbol ${va.dry_weight_uom} for parcel ${Zt[te]}`);if(!ga.data.data||!ga.data.data[0]||!ga.data.data[0][Nt])throw new Error(`Wet weight uom not found for symbol ${va.wet_weight_uom} for parcel ${Zt[te]}`);const $a=await s.get(`/items/${ne}?filter[${F}]=${i}&sort[]=${W}`,{params:{fields:[B,re,J,ie,le,se,ce,de,fe,ue]}});console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] assay lots data=${JSON.stringify($a.data.data)}`),function(e){if(!e||0===e.length)throw new oa("No assay lots found for the selected parcel")}($a.data.data);const wa=function(e){var t;console.log("[evaluateAnalyticalAssay]");const a={};for(const t of e)a[t.method]||(a[t.method]={}),a[t.method][t.commodity]||(a[t.method][t.commodity]=[]),null!==t.lot_number?(1===a[t.method][t.commodity].length&&null===a[t.method][t.commodity][0].lot_number&&(a[t.method][t.commodity]=[]),a[t.method][t.commodity].push(t)):null===t.lot_number&&0===a[t.method][t.commodity].length&&a[t.method][t.commodity].push(t);console.log(`[evaluateAnalyticalAssay] group: ${JSON.stringify(a)}}`);const o={};for(const e in a){console.log(`[evaluateAnalyticalAssay] methodKey: ${e}, group[methodKey]: ${JSON.stringify(a[e])}`);for(const n in a[e]){console.log(`[evaluateAnalyticalAssay] commodityKey: ${n}, group[methodKey][commodityKey]: ${JSON.stringify(a[e][n])}`),o[e]=null!=(t=o[e])?t:{},o[e][n]={};const i=a[e][n].reduce(((e,t)=>e+parseFloat(t.dry_weight)),0);if(console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${i} from ${JSON.stringify(a[e][n])}`),0===i||isNaN(i))throw r.value=`Please provide dry weight for ${n} commodity in ${e} method, total dry weight cannot be ${i}`,new Error("[evaluateAnalyticalAssay] totalDryWeight is 0");console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${i}`),o[e][n].analytical_assay=a[e][n].reduce(((t,a)=>{var o,i,l;const s=parseFloat(null!=(i=a.final_assay)?i:null!=(o=a.seller_assay)?o:a.buyer_assay);if(null==s)throw r.value=`Please provide Final, Seller or Buyer assay value for ${n} commodity in ${e} method`,new Error("[evaluateAnalyticalAssay] assay value is not defined for assay lot");const c=t+s*parseFloat(null!=(l=a.dry_weight)?l:"0");return console.log(`[evaluateAnalyticalAssay] evaluated analytical assay: ${c} for method=${e}, commodity=${n}; with values accumulator=${t}, assayValue=${s}, dryWeight=${a.dry_weight}`),c}),0)/i,console.log(`[evaluateAnalyticalAssay] analytical assay: ${o[e][n].analytical_assay}`),a[e][n].length>0&&(o[e][n][ue]=a[e][n][0][ue])}}return console.log(`[evaluateAnalyticalAssay] analyticalAssay: ${JSON.stringify(o)}`),o}($a.data.data);let Da;if(Da||(Da=wa.Outturn),Da||(Da=wa["Inturn Final"]),Da||(Da=wa.Inturn),Da||(Da=wa.Estimated),Da||(Da=wa.Planned),!Da)throw new Error(`No assay lot data with a valid method found for parcel ${Zt[te]}`);console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] weight lots for invoice evaluation=${JSON.stringify(va)}`),console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] assay lots for invoice evaluation=${JSON.stringify(Da)}`);const ba=await s.get(`/items/${ge}/${aa}`,{params:{fields:[we,$e,De,be]}});!function(e){if(!e)throw new Error("Contract data not found, please ensure the selected contract still exists");if(!e[$e])throw new Error(`The contract ${e[we]} does not have a set currency, please ensure that the currency field for the contract is not empty`);if(e[De]&&p(e[be]))throw new Error(`The contract ${e[we]} is applicable for GST but does not have a GST rate, please ensure that the GST rate field for the contract is not empty`)}(ba.data.data);const Ea=await s.get(`/items/${St}/${ba.data.data.contract_currency}`,{params:{fields:[Pt]}});!function(e){if(!e)throw new Error("Currency data not found, please ensure the selected currency still exists");if(!e[Pt])throw new Error("The selected currency in the contract is not valid")}(Ea.data.data);const Sa=Ea.data.data.code,Pa=await s.get(`/items/${Ue}?filter[${ke}]=${aa}`,{params:{fields:["id",je,Ve,Be,Fe,We,Ge,Le,He,Qe,Je,Re,qe,xe]}});!function(e){if(!e||0===e.length)throw new Error("No commodity data found in selected contract for parcel");if(!e.every((e=>e[je])))throw new Error("The selected contract has an undefined commodity, please ensure that the 'Commodity' field for all commodites in the contract is not empty");if(!e.every((e=>!e[Be]||e[Je])))throw new Error("The selected contract has an undefined base price Uom for commodity, please ensure that the 'Base Price Uom' field for all commodites in the contract is not empty")}(Pa.data.data),console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] contract commodity data=${JSON.stringify(Pa.data.data)}`);const Ca=[],Aa=[];let Ta="";for(const{id:e,commodity:t,primary_commodity:r,price_method:i,price_fix_to_use:u,quotational_periods:p,price_per_uom:w,penalty_per_uom:F,treatment_charge_per_uom:W,tc_reference:J,refining_charge_rate_uom:q}of Pa.data.data){const x=await s.get(`/items/${Dt}/${t}`,{params:{fields:[bt,Et,B]}});if(da(x.data.data,t),!Da[x.data.data.code]){console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}::comm=${x.data.data[bt]}] no analytical assay for commodity ${x.data.data.code} found, skipping...`);continue}if(r&&(Ta=x.data.data[bt]),null!==p){const t=p;console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}::comm=${x.data.data[bt]}] qp=${JSON.stringify(t)}`);const r=Array.isArray(t)?t.find((e=>e.default)):null;if(!r)throw new Error(`No default quotational period found for commodity ${x.data.data.code}`);const I=t.filter((e=>!e.default)).map((e=>`${e.qp_period} ${e.qp_code}`)),F=[`${r.qp_period} ${r.qp_code}`,...I].join(", ");console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}::comm=${x.data.data[bt]}] evaluate payable assay for ${x.data.data.code} with an analytical assay=${null==(a=Da[x.data.data.code])?void 0:a.analytical_assay}`);const G=await s.get(`/items/${Ke}?filter[${at}]=${e}`,{params:{fields:[ot,nt,rt,it,lt,st,ct,Ye,ze,Xe,Ze,et,tt]}}),{payableAssay:L,expression:H}=await E(null==(o=Da[x.data.data.code])?void 0:o.analytical_assay,null==(n=Da[x.data.data.code])?void 0:n.assay_uom,G.data.data,x.data.data[bt]);let Q=null,Y=null,X=null;if("Final"!==Xt){const e=await ra(x.data.data.code,x.data.data.name,Zt,i,(async()=>ia(r,Zt,ta,x.data.data[bt])));if(null===e)throw new Error(`Pricing dates not found for commodity ${x.data.data.code} for parcel ${Zt[te]}`);if(null===e.provisionalPricingStartDate||!(e.provisionalPricingStartDate instanceof Date))throw new Error(`Invalid provisional pricing start date for commodity ${x.data.data.code} of invoice type ${Xt} in parcel ${Zt[te]}`);if(Q=e.provisionalPricingStartDate,null===e.provisionalPricingEndDate||!(e.provisionalPricingEndDate instanceof Date))throw new Error(`Invalid provisional pricing end date for commodity ${x.data.data.code} of invoice type ${Xt} in parcel ${Zt[te]}`);Y=e.provisionalPricingEndDate,X=e.expectedNoOfBusinessDays}else{const e=await ra(x.data.data.code,x.data.data.name,Zt,i,(async()=>ia(r,Zt,ta,x.data.data[bt])));if(null===e)throw new Error(`Pricing dates not found for commodity ${x.data.data.code} for parcel ${Zt[te]}`);if(null===e.provisionalPricingStartDate||!(e.provisionalPricingStartDate instanceof Date))throw new Error(`Invalid provisional pricing start date for commodity ${x.data.data.code} of invoice type ${Xt} in parcel ${Zt[te]}`);if(Q=e.provisionalPricingStartDate,null===e.provisionalPricingEndDate||!(e.provisionalPricingEndDate instanceof Date))throw new Error(`Invalid provisional pricing end date for commodity ${x.data.data.code} of invoice type ${Xt} in parcel ${Zt[te]}`);Y=e.provisionalPricingEndDate}console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}::comm=${x.data.data[bt]}] provisional pricing date range: ${Q.toString()} - ${Y.toString()}`);const Z=await ca(x.data.data.code,x.data.data[B],i,Q,Y,X,u),ee=Z.averagePrice;let ae;Q=Z.startDate,Y=Z.endDate,console.log(`[generateInvoice][parcel=${Zt[te]}::average price within period: ${ee} with start date=${Q} and end date=${Y}`);const ne=await s.get(`/items/${dt}?filter[${ht}]=${e}`,{params:{fields:[nt,rt,it,lt,ut,ft,mt,pt,yt,st]}});if(void 0!==ne.data.data&&null!==ne.data.data&&ne.data.data.length>0){let e;if("Assay Grade"===J){if(e=$(null==(l=Da[x.data.data.code])?void 0:l.analytical_assay,4),null===e)throw new Error(`Assay Grade is not defined for commodity ${x.data.data[bt]} when evaluating treatment charge`)}else console.warn(`[generateInvoice][parcel=${Zt[te]}::tc_reference=${J} is not recognised, using price rate as reference by default`),e=ee;ae=await O(e,null==(c=Da[x.data.data.code])||c.assay_uom,ne.data.data,x.data.data[bt],"treatment charge",(null!=J?J:"price rate").toLowerCase())}let re,ie;if(ae){if(!W)throw new Error(`Treatment Charge Rate UOM is not defined for commodity ${x.data.data[bt]}`);const e=await s.get(`/items/${Ct}/${W}`,{params:{fields:[At]}});fa(e.data.data,x.data.data[bt]),re=e.data.data[At]}const le=await s.get(`/items/${dt}?filter[${vt}]=${e}`,{params:{fields:[nt,rt,it,lt,ut,ft,mt,pt,yt,st]}});if(void 0!==le.data.data&&null!==le.data.data&&le.data.data.length>0){let e=ee;ie=await O(e,null==(d=Da[x.data.data.code])||d.assay_uom,le.data.data,x.data.data[bt],"refining charge","price rate")}let se;if(ie){if(!q)throw new Error(`Refining Charge Rate UOM is not defined for commodity ${x.data.data[bt]}`);const e=await s.get(`/items/${Ct}/${q}`,{params:{fields:[At]}});fa(e.data.data,x.data.data[bt]),se=e.data.data[At]}const ce=await s.get(`/items/${Ct}/${w}`,{params:{fields:[At]}});ua(ce.data.data,x.data.data[bt]);const de=ce.data.data[At],ue=C(null==(f=Da[x.data.data.code])?void 0:f.assay_uom,va.dry_weight_uom,de);console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}::comm=${x.data.data[bt]}] payableMetalConversion for commodity ${x.data.data.name}: ${JSON.stringify(ue)}`),ue.initialAssayConversion=1===(null==(m=ue.initialAssayConversion)?void 0:m.conversionValue)?void 0:ue.initialAssayConversion,ue.finalWeightConversion=1===(null==(y=ue.finalWeightConversion)?void 0:y.conversionValue)?void 0:ue.finalWeightConversion;const fe=(null==(h=ue.initialAssayConversion)?void 0:h.isConvertByMultiplication)?null!=(_=null==(v=ue.initialAssayConversion)?void 0:v.conversionValue)?_:1:1/(null!=(b=null==(D=ue.initialAssayConversion)?void 0:D.conversionValue)?b:1),me=(null==(S=ue.finalWeightConversion)?void 0:S.isConvertByMultiplication)?null!=(A=null==(P=ue.finalWeightConversion)?void 0:P.conversionValue)?A:1:1/(null!=(M=null==(T=ue.finalWeightConversion)?void 0:T.conversionValue)?M:1),pe=null!=(U=$(va.dry_weight*fe*(null!=L?L:1)*me,4))?U:1;console.log(`[generateInvoice] PAYABLE_METAL for commodity ${x.data.data.name}: ${pe}`);const ye=$(ee,4),he=$(pe*(null!=ye?ye:ee));Ca.push({commodity:x.data.data.name,analytical_assay:g(null==(k=Da[x.data.data.code])?void 0:k.analytical_assay,4),deduction_expression:H,payable_assay:g(L,4),assay_uom:null==(j=Da[x.data.data.code])?void 0:j.assay_uom,payable_metal:g(pe,4),payable_metal_expression:`${g(va.dry_weight,4)}${va.dry_weight_uom}${ue.initialAssayConversion?` ${ue.initialAssayConversion.isConvertByMultiplication?"*":"/"} ${g(ue.initialAssayConversion.conversionValue,4)}${ue.initialAssayConversion.conversionUOM}`:""} * ${g(null!=L?L:1,4)}${"%"!==(null==(V=Da[x.data.data.code])?void 0:V.assay_uom)?`${null==(R=Da[x.data.data.code])?void 0:R.assay_uom}`:" / 100"}${ue.finalWeightConversion?` ${ue.finalWeightConversion.isConvertByMultiplication?"*":"/"} ${g(ue.finalWeightConversion.conversionValue,4)}${ue.finalWeightConversion.conversionUOM}`:""}`,payable_metal_uom:de,qp:F,qp_start_date:N(Q),qp_end_date:N(Y),price_method:i,price_rate:g(ye,4),price_per_uom:de,price:g(he),treatment_charge:ae?{rate:g(ae.baseTreatmentCharge,4),discount:g((null!=(K=ae.baseTreatmentCharge)?K:0)-(null!=(z=ae.finalValue)?z:0),4),final_rate:g(ae.finalValue,4),per_uom:re,final_amount:g($(va.dry_weight*(null!=(oe=ae.finalValue)?oe:1)*-1,2,!0))}:void 0,refining_charge:ie?{rate:g(ie.baseTreatmentCharge,4),discount:g((null!=(Vt=ie.baseTreatmentCharge)?Vt:0)-(null!=(Bt=ie.finalValue)?Bt:0),4),final_rate:g(ie.finalValue,4),per_uom:se,final_amount:g($(pe*(null!=(Ft=ie.finalValue)?Ft:1)*-1,2,!0))}:void 0,final_total:$((null!=he?he:0)+(ae&&null!=(xt=$(va.dry_weight*(null!=(qt=ae.finalValue)?qt:1)*-1,2,!0))?xt:0)+(ie&&null!=(Lt=$(pe*(null!=(Gt=ie.finalValue)?Gt:1)*-1,2,!0))?Lt:0))})}const G=await s.get(`/items/${_t}?filter[${at}]=${e}`,{params:{fields:[nt,rt,it,lt,gt,$t,wt,st]}});if(G.data.data.length>0){if(null===F)throw new Error(`Please fill in the field for Penalty Per UOM in contract ${ta} for commodity ${x.data.data[bt]}`);const e=await s.get(`/items/${Ct}/${F}`,{params:{fields:[At]}});ma(e.data.data,x.data.data[bt]);const t=e.data.data[At],{penalty:a,expression:o,bracket:n}=await I(null==(Ht=Da[x.data.data.code])?void 0:Ht.analytical_assay,G.data.data,Sa,t,x.data.data[bt]);console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}::comm=${x.data.data[bt]}] evaluated penalty with an analytical assay=${null==(Qt=Da[x.data.data.code])?void 0:Qt.analytical_assay}, penaltyRate=${null==n?void 0:n.rate}, finalPenaltyRate=${a}, expression='${o}'`),Aa.push({commodity:x.data.data.name,analytical_assay:g(null==(Kt=Da[x.data.data.code])?void 0:Kt.analytical_assay,4),deduction_expression:o,assay_uom:null==(Yt=Da[x.data.data.code])?void 0:Yt.assay_uom,penalty_rate:g(null==n?void 0:n.rate,4),penalty_per_uom:t,final_penalty_rate:g(a,4),final_penalty:g((null!=a?a:1)*va.dry_weight)})}}console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] evaluated commodities=${JSON.stringify(Ca)}`),console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] evaluated penalties${JSON.stringify(Aa)}`);const Oa=Ca.reduce(((e,t)=>e+w(t.price)),0),Ia=Ca.reduce(((e,t)=>{var a;return e+w(null==(a=t.treatment_charge)?void 0:a.final_amount)}),0),Na=Ca.reduce(((e,t)=>{var a;return e+w(null==(a=t.refining_charge)?void 0:a.final_amount)}),0),Ma=Aa.reduce(((e,t)=>e+w(t.final_penalty)),0);console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] TOTAL_REVENUE=${Oa}, TOTAL_TREATMENT_CHARGE=${Ia}, TOTAL_REFINING_CHARGE=${Na}, TOTAL_PENALTIES=${Ma}`);let Ua,ka=0;const ja=!!Zt[ae];ja&&(ka=Zt[ae].reduce(((e,t)=>e+t.amount),0),Ua={adjustments:Zt[ae].map((e=>({description:e.description,amount:g(e.amount)}))),total_adjustments:g(ka)});const Va=sa[Ce],Ba=Oa+Ia+Na+Ma,Fa=null!=Va?Ba*Va/100:void 0;let Wa,Ja=0;(zt=ba.data.data)&&"object"==typeof zt&&zt[De]&&(Ja=ba.data.data[be]/100,Wa=Ba*Ja);const Ra=await s.get(`/items/${Mt}/${Zt[G]}`,{params:{fields:[Ut]}});pa(Ra.data.data);const qa=Zt[X];let xa;qa&&(xa=await s.get(`/items/${kt}/${qa}`,{params:{fields:[jt]}}),function(e){if(console.log("[validateVessel]"),!e)throw new Error("Vessel for parcel not found");if(!e[jt])throw new Error("No name defined for vessel of the selected parcel")}(xa.data.data));let Ga=(await s.get(`/items/${Wt}?filter[${Jt}]=${i}`,{params:{fields:["id",Rt]}})).data.data.reduce(((e,t)=>e+(t[Rt]?1:0)),0)+1;const La=Ga.toString().padStart(2,"0"),Ha=(Zt[te],{parcelId:e.parcelId,Parcel:`${Zt[te]}`,Counterparty:Ra.data.data[Ut],Vessel:xa?xa.data.data[jt]:"Vessel TBA","Shipment Date":Zt[Q]?N(new Date(Zt[Q])):Zt[Y]?N(new Date(Zt[Y])):"N/A","Arrival Date":Zt[L]?N(new Date(Zt[L])):Zt[H]?N(new Date(Zt[H])):"N/A",Status:Zt[Q]?"Unfinalised":"Planned",Revision:"Valuation",Invoice:`${Xt}:Valuation`,"Invoice Due Date":N(e.dueDate),"Dry Weight":`${g(va.dry_weight,2)}`,"Dry Weight UOM":va.dry_weight_uom,...await la(Ca,{dryWeight:va.dry_weight,dryWeightUom:va.dry_weight_uom}),"Total Revenues USD":g(Oa),"Total Penalties USD":g(Ma+Ia+Na),"Total Adjustments USD":ja?Ua.total_adjustments:"0.00","Parcel Value USD":g(Ba),"Parcel Payable Value USD":g(Fa),"Payments USD":"-","GST Payable USD":g(Wa),"Due Total":"-",metadata:{invoiceTypeRanking:ea[Xt]}});return console.log(`[generateInvoice][parcel=${Zt[te]}::invoice type=${Xt}] generated forecast invoice=${JSON.stringify(Ha)}`),Ha}catch(t){if(t instanceof oa)return void console.error(`[generateInvoice][parcel=${e.parcelId}::invoice type=${e.invoiceType}]Non-fatal error: ${t.message}`);throw new Error(t.message+` (parcel ${e.parcelId}, invoice type ${e.invoiceType})`)}var zt}(e))))),n=function(e){const t=e.reduce(((e,t)=>(e[t.parcelId]||(e[t.parcelId]=[]),e[t.parcelId].push(t),e)),{});Object.keys(t).forEach((e=>{t[e].sort(((e,t)=>e.metadata.invoiceTypeRanking<t.metadata.invoiceTypeRanking?-1:e.metadata.invoiceTypeRanking>t.metadata.invoiceTypeRanking?1:0))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(t)}`),Object.keys(t).forEach((e=>{t[e].forEach(((a,o)=>{if(!a["Parcel Payable Value USD"]||"-"===a["Parcel Payable Value USD"])throw new Error(`Parcel ${e} for invoice ${a.Invoice} does not have a Parcel Payable Value USD`);const n=w(a["Parcel Payable Value USD"]);if(isNaN(n))throw new Error(`Parcel ${e} for invoice ${a.Invoice} has an invalid Parcel Payable Value USD of ${a["Parcel Payable Value USD"]}`);const r=w(a["Total Adjustments USD"]||"0.00");if(0===o){a["Payments USD"]=a["Payments USD"]&&"-"!==a["Payments USD"]?a["Payments USD"]:"0.00";const e=w(a["Payments USD"]);a["Due Total"]=g(n-e+r)}else{if(!t[e][o-1]["Parcel Payable Value USD"]||"-"===t[e][o-1]["Parcel Payable Value USD"])throw new Error(`Parcel ${e} for invoice ${a.Invoice} does not have a Parcel Payable Value USD for the previous invoice`);const i=w(t[e][o-1]["Parcel Payable Value USD"]);if(isNaN(i))throw new Error(`Parcel ${e} for invoice ${a.Invoice} has an invalid Parcel Payable Value USD of ${t[e][o-1]["Parcel Payable Value USD"]} for the previous invoice`);const l=w(t[e][o-1]["Total Adjustments USD"]||"0.00");a["Due Total"]=g(n+r-(i+l)),a["Payments USD"]&&"-"!==a["Payments USD"]||(a["Payments USD"]=t[e][o-1]["Payments USD"],a["GST Payable USD"]&&"-"!==a["GST Payable USD"]&&(a["GST Payable USD"]=g(w(a["GST Payable USD"])-w(t[e][o-1]["GST Payable USD"]))))}}))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(t)}`);const a=Object.keys(t).flatMap((e=>t[e]));return console.log(`[evaluateDuePaymentsForCashflow] cashflowAsJsonWithDueTotal=${JSON.stringify(a)}`),a}(o.filter((e=>!!e))),l=n.map((e=>(delete e.metadata,delete e.parcelId,e))),f=new Date(c.value[Ht]),m=new Date(c.value[Lt]),y=l.filter((e=>new Date(e["Invoice Due Date"])>=f&&new Date(e["Invoice Due Date"])<=m));a("input",y),console.log(`[generateCashflow] cashflow response: ${JSON.stringify(y)}`);const h=ta(y);console.log(`[generateCashflow] cashflow as csv: ${h}`),console.log(`[generateCashflow] Cache statistics: ${d.size} unique API calls cached`),i.value=!1,na(h)}catch(e){r.value=e.message}finally{i.value=!1}},downloadDoc:na,copy:async function(){l.value=!0;const{id:e,user_created:t,date_created:a,user_updated:o,date_updated:n,cashflow:i,forecast_price:d,...u}=c.value,f=await s.get(`/items/${Qt}`,{params:{filter:{[B]:{_in:d}},fields:[Kt,zt,Xt,Yt]}}),m=await s.post(`items/${Qt}`,f.data.data);if(200!==m.status)return console.log(`[cashflow::copy] duplicate forecast prices response status: ${m.status}`),void(r.value=`Failed to duplicate forecast prices with status ${m.status}`);const p=m.data.data.map((e=>e.id));console.log(`[cashflow::copy] duplicated forecast prices id=${JSON.stringify(p)}`),console.log(`[cashflow::copy] requestBody=${JSON.stringify(u)}`);const y=await s.post("/items/"+R,{forecast_price:p,...u});if(200!==y.status)return console.log(`[cashflow::copy] copy response status: ${y.status}`),void(r.value=`Failed to duplicate cashflow with status ${y.status}`);l.value=!1,window.open(`/admin/content/${R}/${y.data.data.id}`)},isCopying:l,failureReason:r};function na(e){let t;t=p(e)?ta(c.value.cashflow):e,console.log(`[downloadDoc] csvData=${t}`),aa(t)}async function ra(e,t,a,o,n,r=!1){if(null===n&&(p(a[z])||p(a[z][e])))throw new Error(`QP Selection is not set for commodity ${t} in the parcel ${a[te]}, please ensure all contract commodities have a QP selection`);if(p(a[z])||p(a[z][e]))return await n();const i=await async function(e,t,a,o){var n,r;if(o&&!e.declared)return null;if(e.qp_month)return{provisionalPricingStartDate:j(new Date(e.qp_month),0),provisionalPricingEndDate:V(new Date(e.qp_month),0),expectedNoOfBusinessDays:null};const i=null==e?void 0:e.qp_selected;if(!i)return null;const l=i.split(" "),s={qp_period:parseInt(l[0]),qp_code:l[1]};let c,d,u,f;switch(s.qp_code){case"MAMA":c=null!=(n=t[L])?n:t[H],d="Actual/Estimated Arrival Date";break;case"MOSS":c=t[Y],d="Estimated Shipment Date";break;case"MOS":case"MOAS":c=null!=(r=t[Q])?r:t[Y],d="B/L Date (or Estimated Shipment Date)";break;default:throw new Error(`Unsupported QP code ${s.qp_code} in the contract commodities, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}if(p(c))throw new Error(`Please fill in a date for the field '${d}' for the Parcel form, for QP: ${i}`);const m=new Date(c);return u=j(m,s.qp_period),f=V(m,s.qp_period),{provisionalPricingStartDate:u,provisionalPricingEndDate:f,expectedNoOfBusinessDays:null}}(a[z][e],a,0,r);return i||await n()}async function ia(e,t,a,o){var n,r;let i,l,s,c;switch(e.qp_code){case"MAMA":c=null!=(n=t[L])?n:t[H],i="Actual/Estimated Arrival Date";break;case"MOSS":case"MOS":case"MOAS":c=null!=(r=t[Q])?r:t[Y],i="B/L Date (Estimated Shipment Date)";break;default:throw new Error(`Unsupported QP code ${e.qp_code} in the contract ${a}, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}if(p(c))throw new Error(`No reference day provided for ${i} from contract ${a} for commodity ${o}`);const d=new Date(c);return l=j(d,e.qp_period),s=V(d,e.qp_period),{provisionalPricingStartDate:l,provisionalPricingEndDate:s,expectedNoOfBusinessDays:null}}async function la(e,t){console.log(`[mapOutCommoditiesForCashflow] commodities=${JSON.stringify(e)};;containedMetalParam=${JSON.stringify(t)}`);return(await Promise.all(e.map((async e=>{var a,o,n,r,i,l,s,c,d,u;const f=C(e.assay_uom,t.dryWeightUom,e.payable_metal_uom);console.log(`[mapOutCommoditiesForCashflow] commodity=${e.commodity}, containedMetalUnitConversion=${JSON.stringify(f)}`);const m=((null==(a=f.initialAssayConversion)?void 0:a.isConvertByMultiplication)?null!=(n=null==(o=f.initialAssayConversion)?void 0:o.conversionValue)?n:1:1/(null!=(i=null==(r=f.initialAssayConversion)?void 0:r.conversionValue)?i:1))*((null==(l=f.finalWeightConversion)?void 0:l.isConvertByMultiplication)?null!=(c=null==(s=f.finalWeightConversion)?void 0:s.conversionValue)?c:1:1/(null!=(u=null==(d=f.finalWeightConversion)?void 0:d.conversionValue)?u:1));return{[`${e.commodity} Payable Metal (${e.payable_metal_uom})`]:e.payable_metal,[`${e.commodity} Contained Metal (${e.payable_metal_uom})`]:g(t.dryWeight*e.analytical_assay*m),[`${e.commodity} Revenue (USD)`]:e.price,[`${e.commodity} QP Month`]:sa(new Date(e.qp_start_date)),[`${e.commodity} Price (USD/${e.price_per_uom})`]:e.price_rate,...!!e.treatment_charge&&{[`${e.commodity} TC (USD)`]:e.treatment_charge.final_amount,[`${e.commodity} TC (USD/${e.treatment_charge.per_uom})`]:e.treatment_charge.final_rate},...!!e.refining_charge&&{[`${e.commodity} RC (USD)`]:e.refining_charge.final_amount,[`${e.commodity} RC (USD/${e.refining_charge.per_uom})`]:e.refining_charge.final_rate}}})))).reduce(((e,t)=>({...e,...t})),{})}function sa(e){return`${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]} ${e.getFullYear()}`}async function ca(e,t,a,o,n,r,i=null,l=1){var d;if(console.log(`[getCommodityAvgPrice] commodity=${e}, commodityId=${t}, source=${a}, startDate=${o}, endDate=${n}, currency=${l}`),p(e))throw new Error(`Commodity ${e} is not defined for price calcualtion`);if(p(a))throw new Error(`Price method for commodity ${e} is not defined for price calcualtion`);if(p(o))throw new Error(`Start date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);if(p(n))throw new Error(`End date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);const u=new Date(o.valueOf()),f=new Date(n.valueOf());null===r||isNaN(r)?null===r&&f.setDate(f.getDate()+10):u.setDate(u.getDate()-10);const m=await s.get(`/items/navarch_commodity_price?filter[_and][0][price_method][_eq]=${a}&filter[_and][0][currency][_eq]=${l}&filter[_and][1][date][_between][0]=${M(u)}&filter[_and][1][date][_between][1]=${M(f)}&sort[]=-${Ft}`,{params:{fields:[Vt,Bt,Ft,"price_method"]}});if((null==(d=m.data)?void 0:d.data)&&Array.isArray(m.data.data)&&m.data.data.length>0){const t=m.data.data[0],a=new Date(t[Ft]);if(console.log(`[getCommodityAvgPrice] commodity prices=${JSON.stringify(m.data.data)}`),a>=n||null===r){if(null!=r&&m.data.data.length<r)throw new Error(`Not enough commodity prices found for commodity ${e} between ${M(o)} and ${M(n)}, please contact Navarch for support`);const t=null===r||isNaN(r)?m.data.data.filter((e=>{const t=new Date(e[Ft]);return t>=o&&t<=n})):m.data.data.slice(0,r),a=t.map((e=>e[Vt])).filter((e=>!p(e))),l=t.map((e=>e[Bt])).filter((e=>!p(e)));let s;if("PM"===i||("Average"===i||null===i)&&0===a.length){if(0===l.length)throw new Error(`The commodity price for the commodity ${e} does not have a Closing Price (PM) from ${o} to ${n}, please reach out to Navarch for support`);const t=$(l.reduce(((e,t)=>e+Number(t)),0)/l.length);if(null===t)throw new Error(`The average closing price for the commodity ${e} is invalid = ${t}`);s=t}else if("AM"===i||("Average"===i||null===i)&&0===l.length){if(0===a.length)throw new Error(`The commodity price for the commodity ${e} does not have a Opening Price (AM) from ${o} to ${n}, please reach out to Navarch for support`);const t=$(a.reduce(((e,t)=>e+Number(t)),0)/a.length);if(null===t)throw new Error(`The average opening price for the commodity ${e} is invalid = ${t}`);s=t}else{const t=$(a.reduce(((e,t)=>e+Number(t)),0)/a.length);if(null===t)throw new Error(`The average opening price for the commodity ${e} is invalid = ${t}`);const o=$(l.reduce(((e,t)=>e+Number(t)),0)/l.length);if(null===o)throw new Error(`The average closing price for the commodity ${e} is invalid = ${o}`);s=(t+o)/2}return console.log(`[getCommodityAvgPrice] average price=${s} for commodity ${e} between ${M(o)} (with over-adjusted start date of ${M(u)}) and ${M(n)}`),{averagePrice:s,startDate:new Date(t[t.length-1][Ft]),endDate:new Date(t[0][Ft])}}console.log(`[getCommodityAvgPrice] latest comm price date=${a} is before end date=${n}, getting forecast price`)}if(!c.value[B])throw new Error("Please save the Cashflow form first before generating the cashflow doc");const y=await s.get(`/items/${Qt}`,{params:{filter:{[Kt]:{_eq:t},cashflow_forecast_id:{_eq:c.value[B]}},fields:[Yt,Kt,zt,Xt]}});!function(e,t){if(!e||!Array.isArray(e)||0===e.length)throw new Error(`No forecast price found for ${t}, please ensure prices have been provided`)}(y.data.data,e);const h=y.data.data.find((e=>{const t=new Date(e[zt]),a=new Date(e[Xt]);return t<=o&&a>=n}));if(!h)throw new Error(`No single forecast price found for commodity ${e} between ${M(o)} and ${M(n)}, please ensure there is only one price value for this range`);return console.log(`[getCommodityAvgPrice] forecast price=${h[Yt]} for commodity ${e} between ${M(o)} and ${M(n)}`),{averagePrice:h[Yt],startDate:o,endDate:n}}function da(e,t){var a,o,n;if(console.log("[validateCommodityData]"),!e)throw new Error("commodity data response is null");if(!e[bt])throw new Error(`Commodity name for commodity ${null!=(a=e[Et])?a:t} is undefined, please contact Navarch for assistance`);if(!e[Et])throw new Error(`Commodity code for commodity ${null!=(o=e[bt])?o:t} is not defined, please contact Navarch for assistance`);if(!e[B])throw new Error(`Commodity ID for commodity ${null!=(n=e[bt])?n:t} is not defined, please contact Navarch for assistance`)}function ua(e,t){if(!e)throw new Error(`Price per UOM for commodity ${t} is not a valid`);if(!e[At])throw new Error(`Price per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function fa(e,t){if(!e)throw new Error(`Charge per UOM for commodity ${t} is not a valid`);if(!e[At])throw new Error(`Charge per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function ma(e,t){if(!e)throw new Error(`Penalty per UOM for commodity ${t} is not a valid`);if(!e[At])throw new Error(`Penalty per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function pa(e){if(console.log("[validateCounterparty]"),!e)throw new Error("Counterparty for parcel not found");if(!e[Ut])throw new Error("No codename defined for counterparty of the selected parcel")}}});const T={key:0},O={key:1};var I=[],N=[];!function(e,t){if(e&&"undefined"!=typeof document){var a,o=!0===t.prepend?"prepend":"append",n=!0===t.singleTag,r="string"==typeof t.container?document.querySelector(t.container):document.getElementsByTagName("head")[0];if(n){var i=I.indexOf(r);-1===i&&(i=I.push(r)-1,N[i]={}),a=N[i]&&N[i][o]?N[i][o]:N[i][o]=l()}else a=l();65279===e.charCodeAt(0)&&(e=e.substring(1)),a.styleSheet?a.styleSheet.cssText+=e:a.appendChild(document.createTextNode(e))}function l(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),t.attributes)for(var a=Object.keys(t.attributes),n=0;n<a.length;n++)e.setAttribute(a[n],t.attributes[a[n]]);var i="prepend"===o?"afterbegin":"beforeend";return r.insertAdjacentElement(i,e),e}}(".margin-top-16px[data-v-64969d30] {\n  margin-top: 16px;\n}",{}),A.render=function(e,t,a,o,n,y){const h=r("v-button"),v=r("v-notice");return i(),l(s,null,[c(' <input :value="value" @input="handleChange($event.target.value)" /> '),c(" create a button only interface for Directus"),e.value?(i(),l("div",O,[d(h,{onClick:t[1]||(t[1]=()=>e.downloadDoc())},{default:u((()=>[f("Download Cashflow ")])),_:1})])):(i(),l("div",T,[d(h,{onClick:t[0]||(t[0]=()=>e.generateCashflow()),loading:e.isGeneraingDoc},{default:u((()=>[f("Generate Cashflow")])),_:1},8,["loading"]),e.failureReason?(i(),m(v,{key:0},{default:u((()=>[f(p(e.failureReason),1)])),_:1})):c("v-if",!0)])),d(h,{class:"margin-top-16px",onClick:t[2]||(t[2]=()=>e.copy()),loading:e.isCopying},{default:u((()=>[f("Copy")])),_:1},8,["loading"])],64)},A.__scopeId="data-v-64969d30",A.__file="src/interface.vue";var M=t({id:"navarch-docgen-cashflow",name:"Navarch Cashflow Generator Button",icon:"receipt_long",description:"This is my custom interface for Navarch's Cashflow Doc!",component:A,options:null,types:["json"],group:"standard"});export{M as default};
