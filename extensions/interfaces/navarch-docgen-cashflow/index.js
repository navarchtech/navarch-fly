import{useApi as e,defineInterface as t}from"@directus/extensions-sdk";import{defineComponent as a,ref as o,inject as n,resolveComponent as r,openBlock as i,createElementBlock as l,Fragment as s,createCommentVNode as c,createVNode as d,withCtx as u,createTextVNode as m,createBlock as f,toDisplayString as p}from"vue";var h=(e=>(e.BRACKET="Brackets",e.MIN_DEDUCTION="Minimum Deduction",e.MAX_CAP="Maximum Cap",e))(h||{}),y=(e=>(e.PERCENTAGE="Percentage",e.FRACTIONAL="Fractional",e))(y||{}),_=(e=>(e.WET_WEIGHT="wet_weight",e.MOISTURE="moisture",e.DRY_WEIGHT="dry_weight",e))(_||{}),v=(e=>(e.METHOD="method",e.WET_WEIGHT_UOM="wet_weight_uom",e.MOISTURE_UOM="moisture_uom",e.DRY_WEIGHT_UOM="dry_weight_uom",e))(v||{}),$=a({props:{value:{type:Object,default:null}},emits:["input"],setup(t,{emit:a}){const r=o(""),i=o(!1),l=e(),s=n("values",o({}));function c(e){if(console.log("[evaluateWeightData]"),0===e.length)return;const t=u(e,_.DRY_WEIGHT),a=u(e,_.WET_WEIGHT);return{method:d(e,v.METHOD),lots:e,dry_weight_uom:d(e,v.DRY_WEIGHT_UOM),wet_weight_uom:d(e,v.WET_WEIGHT_UOM),dry_weight:t,wet_weight:a,moisture:(a-t)/a*100}}function d(e,t){if(console.log("[getFirstValueAsSharedValue]"),0!==e.length)return console.log(`lots[0][${t.toString()}]=${e[0][t.toString()]}`),e[0][t.toString()]}function u(e,t){return console.log("[evaluateAggregateValue]"),e.reduce(((e,a)=>{var o;return e+(null!=(o=a[t.toString()])?o:0)}),0)}function m(e){return null==e}function f(e,t=2,a=!0){if(console.log("[formatNumber]"),isNaN(e)||null===e)return"-";const o=Math.round(e*Math.pow(10,t))/Math.pow(10,t),[n,r]=o.toString().split("."),i=n.replace(/\B(?=(\d{3})+(?!\d))/g,",");if(!r&&!a)return i;return`${i}.${(null!=r?r:"").padEnd(t,"0")}`}function p(e){if(console.log("[parseNumber]"),!e)return 0;const t=parseFloat(e.replace(/,/g,""));return console.log(`[parseNumber] number: ${e} to ${t}`),t}function $(e,t,a){var o,n,r;if(console.log("[findBracket]"),1===e.length){if(t>=(null!=(o=e[0].lower_threshold)?o:0)&&(null===e[0].upper_threshold||void 0===e[0].upper_threshold||t<e[0].upper_threshold))return e[0];throw new Error(`Evaluated monetary value $${t} does not fall within the only ${a.type} bracket with range ${null!=(n=e[0].lower_threshold)?n:0} - ${null!=(r=e[0].upper_threshold)?r:"âˆž"}`)}return e.find((e=>{var a,o;const n=t>(null!=(a=e.lower_threshold)?a:0)&&(null===e.upper_threshold||void 0===e.upper_threshold||t<e.upper_threshold)||e.lower_threshold_inclusive&&t===(null!=(o=e.lower_threshold)?o:0)||e.upper_threshold_inclusive&&t===e.upper_threshold;return console.log(`[findBracket] value=${t} for bracket: ${JSON.stringify(e)}? match=${!!n}`),n}))}function w(e,t){var a,o,n,r,i,l,s;console.log("[evaluateFinalValueFromBrackets]");const c=(e-(null!=(a=t.initial_adjustment)?a:0)*(null!=(o=t.initial_adjustment_conversion_factor)?o:1))*(null!=(n=t.rate)?n:0)*(t.rate_type===y.PERCENTAGE?.01:1)+(null!=(r=t.final_adjustment)?r:0)*(null!=(i=t.final_adjustment_conversion_factor)?i:1);switch(t.bracket_type){case h.MIN_DEDUCTION:if(null===t.comparator||void 0===t.comparator)throw new Error("Minimum deduction not found");const a=t.comparator*(null!=(l=t.comparator_conversion_factor)?l:1);return e-c<a?e-a:c;case h.MAX_CAP:if(null===t.comparator||void 0===t.comparator)throw new Error("Maximum cap not found");const o=t.comparator*(null!=(s=t.comparator_conversion_factor)?s:1);return c>o?o:c;case h.BRACKET:return c;default:throw new Error(`bracket type ${t.bracket_type} is not supported`)}}async function g(e,t,a,o){var n,r,i,l,s,c,d,u;if(console.log("[evaluatePayableAssay]"),!a||0===a.length)return{};const m=$(a,e,{commodityCode:o,type:"Payable Assay"});if(!m)throw new Error(`Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for payable assays`);let p,_,v=1;m.initial_adjustment_uom&&void 0!==m.initial_adjustment_uom&&null!==m.initial_adjustment_uom&&m.initial_adjustment_uom!==t&&(v=await I(m.initial_adjustment_uom,t),p=O(m.initial_adjustment_uom,t));let g,E=1;m.bracket_type===h.MAX_CAP?(_=null!=(n=m.maximum_cap)?n:0,void 0!==m.maximum_cap_uom&&null!==m.maximum_cap_uom&&m.maximum_cap_uom!==t&&(E=await I(m.maximum_cap_uom,t),g=O(m.maximum_cap_uom,t))):m.bracket_type===h.MIN_DEDUCTION&&(_=null!=(r=m.minimum_deduction)?r:0,void 0!==m.minimum_deduction_uom&&null!==m.minimum_deduction_uom&&m.minimum_deduction_uom!==t&&(E=await I(m.minimum_deduction_uom,t),g=O(m.minimum_deduction_uom,t)));const b=w(e,{bracket_type:m.bracket_type,rate:null!=(i=m.rate)?i:1,rate_type:null!=(l=m.rate_type)?l:y.FRACTIONAL,initial_adjustment:null!=(s=m.initial_adjustment)?s:0,initial_adjustment_conversion_factor:v,comparator:_,comparator_conversion_factor:E});let D="";const C=void 0!==m.initial_adjustment&&null!==m.initial_adjustment;if(m.bracket_type===h.BRACKET)D=`${C?"(":""}${f(e,4)}${null!=t?t:""}${C?` - ${f(m.initial_adjustment,4)}${null!=(c=m.initial_adjustment_uom)?c:`${null!=t?t:""}`}`:""}${C&&1!==v?` * ${f(v,4)}${p}`:""}${C?")":""} * ${f(m.rate,4)}${m.rate_type===y.PERCENTAGE?"/100":`/${f(1,4)}`}`;else if(m.bracket_type===h.MIN_DEDUCTION){D=b===e-_*E?`${f(e,4)}${null!=t?t:""} - ${f(_,4)}${null!=t?t:""}${1!==E?` * ${f(E,4)}${g}`:""}`:`${C?"(":""}${f(e,4)}${null!=t?t:""}${C?` - ${f(m.initial_adjustment,4)}${null!=(d=m.initial_adjustment_uom)?d:`${null!=t?t:""}`}`:""}${C&&1!==v?` * ${f(v,4)}${p}`:""}${C?")":""} * ${f(m.rate,4)}${m.rate_type===y.PERCENTAGE?"/100":`/${f(1,4)}`}`}else{if(m.bracket_type!==h.MAX_CAP)throw new Error(`[buildPayableAssayExpression] unknown bracket method: ${m.bracket_type}`);D=b===_*E?`${f(_,4)}${null!=t?t:""}${1!==E?` * ${f(E,4)}${g}`:""}`:`${C?"(":""}${f(e,4)}${null!=t?t:""}${C?` - ${f(m.initial_adjustment,4)}${null!=(u=m.initial_adjustment_uom)?u:`${null!=t?t:""}`}`:""}${C&&1!==v?` * ${f(v,4)}${p}`:""}${C?")":""} * ${f(m.rate,4)}${m.rate_type===y.PERCENTAGE?"/100":`/${f(1,4)}`}`}return{payableAssay:b,expression:D}}console.log("[main] formValues=",s);const E="above the lower threshold, plus",b="below the upper threshold, minus";function D(e,t,a,o){var n,r,i,l;if(console.log("[evaluateTreatmentCharge]"),!a||!a.length)return;const s=$(a,e,{commodityCode:o,type:"Treatment Charge"});if(!s)throw new Error(`Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for treatment charge`);let c=0,d=1;if(s.use_btc)d=0,c=0;else if(d=null!=(n=s.rate)?n:1,s.for_every_unit===E)c=null!=(r=s.lower_threshold)?r:0;else{if(s.for_every_unit!==b)throw new Error(`[evaluateTreatmentCharge] unknown for_every_unit: ${s.for_every_unit}`);c=null!=(i=s.upper_threshold)?i:0}const u={bracket_type:h.BRACKET,rate:d,rate_type:y.FRACTIONAL,initial_adjustment:c,final_adjustment:null!=(l=s.base_treatment_charge)?l:0};return console.log(`[evaluateTreatmentCharge] bracketForEvaluation: ${JSON.stringify(u)}`),{finalValue:w(e,u),baseTreatmentCharge:s.base_treatment_charge}}function C(e,t,a,o,n){var r,i,l;if(console.log("[evaluatePenalty]"),!t||!t.length)return{};const s=$(t,e,{commodityCode:n,type:"Penalty"});if(!s)throw new Error(`[evaluatePenalty] Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for penalty`);let c=0,d=1;if(s.no_penalty)d=0,c=0;else if(d=null!=(r=s.rate)?r:1,s.for_every_unit===E)c=null!=(i=s.lower_threshold)?i:0;else{if(s.for_every_unit!==b)throw new Error(`[evaluatePenalty] unknown for_every_unit: ${s.for_every_unit}`);c=null!=(l=s.upper_threshold)?l:0}const u={bracket_type:h.BRACKET,rate:d,rate_type:y.FRACTIONAL,initial_adjustment:c,final_adjustment:0};console.log(`[evaluatePenalty] bracketForEvaluation: ${JSON.stringify(u)}`);const m=w(e,u),p=null!=u.initial_adjustment;let _="";return _=s.rate&&0!==s.rate?`${p?"(":""}${f(e,4)}${p?` - ${f(c,4)})`:""} / ${f(1,4)} * ${null!=a?a:""} ${f(d,4)}/${null!=o?o:""}`:"No penalty",{penalty:m,expression:_,bracket:s}}function A(e){const t=e.getDate(),a=e.getMonth(),o=e.getFullYear();return`${t} ${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][a]} ${o}`}function N(e,t=!0){const a=e.getMonth()+1,o=e.getDate();return`${e.getFullYear()}${t?"-":" "}${a<10?"0":""}${a}${t?"-":" "}${o<10?"0":""}${o}`}function S(e,t,a=!1){const o=new Date(e.valueOf());let n=t-(a?1:0);for(;n>0;)o.setDate(o.getDate()-1),0!==o.getDay()&&6!==o.getDay()&&(n-=1);return o}function T(e,t,a=!1){const o=new Date(e.valueOf());let n=t-(a?1:0);for(;n>0;)o.setDate(o.getDate()+1),0!==o.getDay()&&6!==o.getDay()&&(n-=1);return o}async function P(e,t){if(e===t)return 1;const a=await l.get(`/items/${ut}?filter[${mt}]=${e}`,{params:{fields:[_t]}});if(0===a.data.data.length||null===a.data.data[0][_t]||void 0===a.data.data[0][_t])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await l.get(`/items/${ut}?filter[${mt}]=${t}`,{params:{fields:[_t]}});if(0===o.data.data.length||null===o.data.data[0][_t]||void 0===o.data.data[0][_t])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for the target weight unit ${t}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(a.data.data[0][_t]);if(isNaN(n))throw new Error(`[getWeightUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);const r=parseFloat(o.data.data[0][_t]);if(isNaN(r))throw new Error(`[getWeightUnitConversionValue] target weight unit ${t} conversion value=${r} is not a number`);return n/r}async function I(e,t){if(null==e||null==t)return 1;if(e===t)return 1;const a=await l.get(`/items/${vt}?filter[${$t}]=${e}`,{params:{fields:[wt]}});if(0===a.data.data.length||void 0===a.data.data[0][wt]||null===a.data.data[0][wt])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await l.get(`/items/${vt}?filter[${$t}]=${t}`,{params:{fields:[wt]}});if(0===o.data.data.length||void 0===o.data.data[0][wt]||null===o.data.data[0][wt])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for the target weight unit ${t}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(a.data.data[0][wt]);if(isNaN(n))throw new Error(`[getAssayUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);console.log(`[getAssayUnitConversionValue] source unit conversion value=${n}`);const r=parseFloat(o.data.data[0][wt]);if(isNaN(r))throw new Error(`[getAssayUnitConversionValue] target weight unit ${e} conversion value=${r} is not a number`);return console.log(`[getAssayUnitConversionValue] target unit conversion value=${r}`),console.log("[getAssayUnitConversionValue] returning "+n/r),n/r}function O(e,t){if(void 0===e||void 0===t||null===e||null===t)return;const a=e.split("/"),o=t.split("/");if(a.length>2||o.length>2)throw new Error(`[getConversionUnit] sourceUnit=${e} and targetUnit=${t} must be in the format of 'unit1/unit2', an extra '/' was found`);if(1===a.length&&1===o.length)return`${o[0]}/${a[0]}`;if(1===a.length){const e=o[0]===a[0]?"":`${o[1]}(${a[1]})`,t=o[1];return""===t?e:`${e}/${t}`}if(1===o.length){const e=a[1],t=a[0]===o[0]?"":`${a[1]}(${o[0]})`;return""===t?e:`${e}/${t}`}{const e=a[0]===o[0],t=a[1]===o[1],n=e||""===a[0],r=e||""===o[0],i=t||""===a[1],l=t||""===o[1],s=!i&&!r,c=!n&&!l,d=`${i?"":a[1]}${s?"(":""}${r?"":`${o[0]}`}${s?")":""}`,u=`${n?"":a[0]}${c?"(":""}${l?"":`${o[1]}`}${c?")":""}`;return""===u?d:`${d}/${u}`}}async function M(e,t,a){const o=await l.get(`/items/${ut}?filter[${ft}]=${t}`,{params:{fields:[mt]}});if(!o.data.data||!o.data.data[0]||!o.data.data[0][mt])throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] Dry weight uom not found for symbol ${t}`);const n=o.data.data[0][mt];if("%"===a){if(n===e)return{};const t=O(n,e);if(!t)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and target weight unit ${e}`);return{finalConversion:{conversionFactor:await P(n,e),conversionUom:t}}}let r=a.split("/");if(1==r.length){const e=await async function(e){const t=await l.get(`/items/${vt}`,{params:{fields:[$t,gt],filter:{[gt]:{_nnull:!0},[$t]:{_eq:e}}}});if(200!==t.status||!t.data||0===t.data.data.length)throw new Error("[getAssayUnitComposition] no assay units found with composition");return t.data.data[0][gt]}(a);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${a} does not have a composition`);r=e.split("/")}if(r.length>2||0===r.length)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${a} is not in the format of 'unit1/unit2'`);const i=r[0],s=r[1],c={};if(s!==n){const e=O(n,s);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and assay unit denominator unit ${s}`);c.initialConversion={conversionFactor:await P(n,s),conversionUom:e}}if(i!==e){const t=O(i,e);if(!t)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for target weight unit ${e} and assay unit numerator unit ${i}`);c.finalConversion={conversionFactor:await P(i,e),conversionUom:t}}return c}const U="id",k="foreign_key",F="lot_number",j="method",V="navarch_parcel",R="contract",J="counterparty",x="assay_results",B="weight_result",q="actual_arrival_date",W="estimate_arrival_date",G="bl_date",L="estimated_shipment_date",H="vessel",K="origin",Q="destination",Y="shipment_code",X="adjustments",z="parcel_finalisation_date",Z="navarch_assay_lot",ee="commodity",te="dry_weight",ae="final_assay",oe="assay_uom",ne="lot_number",re="navarch_weight_lot",ie="dry_weight",le="wet_weight",se="moisture",ce="wet_weight_uom",de="dry_weight_uom",ue="navarch_contract",me="contract_currency",fe="name",pe="navarch_contract_payment_information",he="related_contract",ye="invoice_type",_e="pay_percent",ve="pa_days",$e="pa_day_type",we="pa_ref_day",ge="pa_cashflow_days",Ee="pa_cashflow_day_type",be="pp_days",De="pp_day_type",Ce="pp_ref_day",Ae="navarch_commodity_in_contract",Ne="contract",Se="commodity",Te="primary_commodity",Pe="price_method",Ie="price_per_uom",Oe="treatment_charge_per_uom",Me="quotational_periods",Ue="payable_assay_rates",ke="treatment_charge_rates",Fe="penalty_rates",je="penalty_per_uom",Ve="navarch_payable_assay_bracket",Re="initial_adjustment",Je="initial_adjustment_uom",xe="minimum_deduction",Be="minimum_deduction_uom",qe="maximum_cap",We="maximum_cap_uom",Ge="related_commodity_in_contract",Le="bracket_type",He="lower_threshold",Ke="lower_threshold_inclusive",Qe="upper_threshold",Ye="upper_threshold_inclusive",Xe="rate",ze="rate_type",Ze="navarch_treatment_charge_bracket",et="base_treatment_charge",tt="use_btc",at="for_every_unit",ot="navarch_penalty_bracket",nt="no_penalty",rt="for_every_unit",it="navarch_commodity",lt="name",st="code",ct="navarch_currency",dt="code",ut="navarch_unit",mt="symbol",ft="dry_symbol",pt="wet_symbol",ht="dry_unit",yt="wet_unit",_t="conversionToGram",vt="navarch_assay_unit",$t="unit",wt="conversion_to_ppb",gt="composition",Et="navarch_counterparty",bt="codename",Dt="name",Ct="navarch_vessel",At="name",Nt="price_pm",St="average_price",Tt="date",Pt="navarch_invoices",It="parcel",Ot="invoice",Mt="amount_paid",Ut="invoice_type",kt="commodity",Ft="price",jt="start_date",Vt="end_date";class Rt extends Error{constructor(e){super(e),this.name="NonFatalError",Object.setPrototypeOf(this,Rt.prototype)}}return{isGeneraingDoc:i,invoiceUrl:s.value,generateCashflow:async function(){r.value="";try{i.value=!0;const e=await async function(){const e=new Date(s.value.start_date);if("Invalid Date"===e.toString())throw r.value="Start date is invalid",new Error("Start date is invalid");const t=new Date(s.value.end_date);if("Invalid Date"===t.toString())throw r.value="End date is invalid",new Error("End date is invalid");const a=await l.get(`/items/${ue}`,{params:{fields:[fe,U,"invoice_type"]}}),o={};await Promise.all(a.data.data.map((async a=>{var n,r,i,s,c;const d=await l.get(`/items/${pe}`,{params:{filter:{[he]:{_eq:a[U]}},fields:[ye,ve,$e,we,ge,Ee]}}),u=await l.get(`/items/${V}`,{params:{filter:{[R]:{_eq:a[U]}},fields:[U,Y,q,W,G,L,z]}});for(const m of d.data.data){const d={days:"Final"===m[Ut]?m[ge]:m[ve],day_type:"Final"===m[Ut]?m[Ee]:m[$e],ref_day:"Final"===m[Ut]?"QP Month + n days":m[we]};if(!d)throw new Error(`Contract ${a[fe]} does not have a payment advice for invoice type ${m[Ut]}`);let f,p="";for(const h of u.data.data){switch(d.ref_day){case"Arrival Date":p="Actual Arrival Date from the Parcel form",f=null!=(n=h[q])?n:h[W];break;case"B/L Date":p="B/L Date (or Estimated Shipment Date) from the Parcel form",f=null!=(r=h[G])?r:h[L];break;case"Invoice Date":p="Invoice Date (using the B/L Date or Estimated Shipment Date from the Parcel form)",f=null!=(i=h[G])?i:h[L];break;case"Estimated Shipment Date":p="Estimated Shipment Date from the Parcel form",f=h[L];break;case"QP Month + n days":const e=await l.get(`items/${Ae}`,{params:{filter:{[Ne]:{_eq:a[U]},payable_commodity:{_eq:!0}},fields:[Me]}});if(!Array.isArray(e.data.data)||0===e.data.data.length)throw new Error(`Contract ${a[fe]} does not have any payable commodities`);const t=e.data.data.map((e=>e[Me].find((e=>!!e.default)))),o=t.reduce(((e,t)=>t.qp_period>e.qp_period?t:e),t[0]);switch(o.qp_code){case"MAMA":p="Actual Arrival Date from the Parcel form",f=null!=(s=h[q])?s:h[W];break;case"MOSS":case"MOS":case"MOAS":p="B/L Date (or Estimated Shipment Date) from the Parcel form",f=null!=(c=h[G])?c:h[L];break;default:throw new Error(`Unsupported QP code ${o.qp_code}, currently only supports MAMA, MOS, MOSS, and MOAS`)}break;default:throw new Error(`Invalid reference day for payment advice: ${d.ref_day}; please contact Navarch for support`)}if(null==f)throw new Error(`Reference day for payment advice ${p} is empty in parcel ${h[Y]}`);const u=new Date(f),y=parseInt(d.days);let _;switch(d.day_type){case"Business Day(s)":_=T(u,y,!0);break;case"Calendar Day(s)":_=new Date(u.valueOf()),_.setDate(_.getDate()+y);break;default:throw new Error(`Please provide a valid Day Type (Cashflow) for ${a[fe]}:Final Invoice Type`)}_>=e&&_<=t&&(o[h[U]]||(o[h[U]]=[]),o[h[U]].push({invoiceType:m[ye],dueDate:_,parcelId:h[U],contractName:a[fe]}))}}})));const n=Object.keys(o),i=await l.get(`/items/${V}`,{params:{filter:{[U]:{_in:n}},fields:[U,R,J,x,B,q,W,G,L,H,K,Q,Y,X,"parcel_finalised",z,x]}});if(!i.data.data||i.data.data.length!==n.length)throw new Error("Experiencing some network issues, please try again. If the issue persists, contact Navarch for support");const c={parcelData:i.data.data.reduce(((e,t)=>(e[t[U]]=t,e)),{}),contractNameByParcelId:n.reduce(((e,t)=>(e[t]=o[t][0].contractName,e)),{}),invoiceTypeParcel:n.flatMap((e=>o[e])),parcelIds:n};return console.log(`[getApplicableParcels] returnObject=${JSON.stringify(c)}`),c}(),t=await async function(e){const t=[],a=await l.get(`/items/${Pt}`,{params:{filter:{[It]:{_in:e.parcelIds},[Ot]:{_nnull:!0}},fields:[It,Ut,Ot,Mt]}});for(const o of e.invoiceTypeParcel){const n=a.data.data.find((e=>e[It]===o.parcelId&&e[Ut]===o.invoiceType));n?t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,invoiceData:{...n[Ot],amount_paid:n[Mt]}}):t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,parcelData:e.parcelData[o.parcelId]})}return console.log(`[generateInvoiceParamForParcel] invoiceParams=${JSON.stringify(t)}`),t}(e);console.log(`[generateCashflow] form values=${JSON.stringify(s.value)}`);const o=await Promise.all(t.map((async e=>(console.log(`[generateCashflow] invoiceParam=${JSON.stringify(e)}`),await async function(e){var t,a,o,n,s,d,u,m,h,y,_,v,$,w,E,b,N,T,P,I,O,z,fe,ge,Ee,_t,vt,$t,wt,gt,Nt,St,Tt,Mt,Ut,kt,Ft,jt,Vt;r.value="",i.value=!0;try{if(e.invoiceData){console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] using existing invoice=${JSON.stringify(e.invoiceData)}`);const t=e.invoiceData,a=await l.get(`/items/${Et}`,{params:{filter:{[Dt]:{_eq:t.buyer}},fields:[bt]}});Ht(a.data.data[0]);const o=await l.get(`/items/${V}`,{params:{filter:{[U]:{_eq:e.parcelId}},fields:[G,q,W]}});console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] parcel date data=${JSON.stringify(o.data.data)}`);const n=o.data.data[0];return{Counterparty:a.data.data[0][bt],Vessel:"N/A"===t.vessel?"Vessel TBA":t.vessel,"Shipment Date":t.bl_date,"Arrival Date":n[q]?A(new Date(n[q])):n[W]?A(new Date(n[W])):"N/A",Status:o[G]?"Unfinalised":"Planned",Revision:"Original",Invoice:`${t.invoice_type}:Original`,Parcel:t.parcel,"Invoice Due Date":A(e.dueDate),"Dry Weight":t.dry_weight,"Total Revenues USD":t.total_revenue,"Total Penalties USD":t.total_deductions,...Jt(t.commodities,Number(t.dry_weight)),"Total Adjustments USD":t.adjustments?t.adjustments.total_adjustments:"0.00","Parcel Value USD":t.invoice_value,"Parcel Payable Value(Below Line) USD":t.payable_amount,"Payments USD":t.amount_paid,"Due Total":t.balance_in_sellers_favor}}if(void 0===e.parcelData)throw new Rt(`Something went wrong, no parcel or invoice data for Invoice of parcel id ${e.parcelId.substring(0,5)} and invoice type ${e.invoiceType}`);const r=e.parcelId;if(!r)return void console.error(`[generateInvoice] A parcel id is not defined for invoice type ${e.invoiceType}`);const i=e.invoiceType,xt=e.parcelData,Kt=e.contractName;console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] parcel data=${JSON.stringify(xt)}`),function(e){if(!e)throw new Error("Parcel data not found, please ensure the selected parcel still exists");if(!e[Y])throw new Error("One of the parcels does not have a shipment code, please ensure that all parcels have a shipment code");if(!e[R])throw new Error(`The parcel ${e[Y]} does not have a contract, please ensure that the contract field for the parcel is not empty`);if(!e[J])throw new Error(`The parcel ${e[Y]} does not havea counterparty, please ensure that the counterparty field for the parcel is not empty`);if(!e[x])throw new Rt(`The parcel ${e[Y]} does not have assay results`);if(!e[B])throw new Rt(`The parcel ${e[Y]} does not have weight results`);if(!e[K])throw new Error(`The parcel ${e[Y]} does not havean origin port`);if(!e[Q])throw new Error(`The parcel ${e[Y]} does not havea destination port`)}(xt);const Qt=xt[x],Yt=xt[B],Xt=xt[R];if(!Xt)throw new Error(`Contract not found for parcel ${xt[Y]}`);const zt=await l.get(`/items/${pe}`,{params:{filter:{[he]:{_eq:Xt},[ye]:{_eq:i}},fields:[ye,_e,ve,$e,we,be,De,Ce]}});if(zt.data.data&&0===zt.data.data.length)throw new Error(`No invoice type found for the contract ${Kt}`);const Zt=zt.data.data.find((e=>e[ye]===i));if(!Zt)throw new Error(`Cannot find payment information for ${i} in the contract ${Kt}, please ensure that data for it has been entered and saved`);const ea=await l.get(`/items/${re}?filter[${k}]=${Yt}&sort[]=${F}`,{params:{fields:[U,ie,le,j,se,ce,de]}});console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] weight lots data=${JSON.stringify(ea.data.data)}`),function(e){if(!e||0===e.length)throw new Rt("No weight lots found for the selected parcel")}(ea.data.data);const ta=function(e){console.log("[evaluateWeights]");const t={};for(const a of e)t[a.method]||(console.log(`adding method ${a.method} to weightData object`),t[a.method]=[]),console.log(`adding lot ${a.id} to weightData.${a.method} array`),t[a.method.toString()].push(a);const a=[];for(const e of Object.keys(t)){if(!t[e]){console.log(`method=${e} does not exist in weightData object`);continue}console.log(`adding lots and other values to weights for method=${e}`);const o=c(t[e]);o&&a.push(o)}return a}(ea.data.data);let aa;if(aa||(aa=ta.find((e=>"Outturn"===e.method))),aa||(aa=ta.find((e=>"Inturn Final"===e.method))),aa||(aa=ta.find((e=>"Inturn"===e.method))),aa||(aa=ta.find((e=>"Estimated"===e.method))),aa||(aa=ta.find((e=>"Planned"===e.method))),!aa)throw new Error(`No weight lots with valid method found for parcel ${xt[Y]}`);if(void 0===aa.dry_weight||null===aa.dry_weight||void 0===aa.wet_weight||null===aa.wet_weight||void 0===aa.moisture||null===aa.moisture||void 0===aa.dry_weight_uom||null===aa.dry_weight_uom||void 0===aa.wet_weight_uom||null===aa.wet_weight_uom||void 0===aa.method||null===aa.method)throw new Error(`One of the fields for the latest weight lots data is undefined for parcel ${xt[Y]}`);const oa=await l.get(`/items/${ut}?filter[${ft}]=${aa.dry_weight_uom}`,{params:{fields:[ht]}}),na=await l.get(`/items/${ut}?filter[${pt}]=${aa.wet_weight_uom}`,{params:{fields:[yt]}});if(!oa.data.data||!oa.data.data[0]||!oa.data.data[0][ht])throw new Error(`Dry weight uom not found for symbol ${aa.dry_weight_uom} for parcel ${xt[Y]}`);if(!na.data.data||!na.data.data[0]||!na.data.data[0][yt])throw new Error(`Wet weight uom not found for symbol ${aa.wet_weight_uom} for parcel ${xt[Y]}`);const ra=oa.data.data[0][ht],ia=(ra.indexOf("dry"),na.data.data[0][yt]),la=(ia.indexOf("wet"),await l.get(`/items/${Z}?filter[${k}]=${Qt}&sort[]=${F}`,{params:{fields:[U,ee,j,te,ae,ne,oe]}}));console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] assay lots data=${JSON.stringify(la.data.data)}`),function(e){if(!e||0===e.length)throw new Rt("No assay lots found for the selected parcel")}(la.data.data);const sa=function(e){var t;console.log("[evaluateAnalyticalAssay]");const a={};for(const t of e)a[t.method]||(a[t.method]={}),a[t.method][t.commodity]||(a[t.method][t.commodity]=[]),null!==t.lot_number?(1===a[t.method][t.commodity].length&&null===a[t.method][t.commodity][0].lot_number&&(a[t.method][t.commodity]=[]),a[t.method][t.commodity].push(t)):null===t.lot_number&&0===a[t.method][t.commodity].length&&a[t.method][t.commodity].push(t);console.log(`[evaluateAnalyticalAssay] group: ${JSON.stringify(a)}}`);const o={};for(const e in a){console.log(`[evaluateAnalyticalAssay] methodKey: ${e}, group[methodKey]: ${JSON.stringify(a[e])}`);for(const n in a[e]){console.log(`[evaluateAnalyticalAssay] commodityKey: ${n}, group[methodKey][commodityKey]: ${JSON.stringify(a[e][n])}`),o[e]=null!=(t=o[e])?t:{},o[e][n]={};const r=a[e][n].reduce(((e,t)=>e+t[te]),0);console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${r} from ${JSON.stringify(a[e][n])}`),o[e][n].analytical_assay=a[e][n].reduce(((e,t)=>e+t[ae]*t[te]),0)/(0!==r?r:1),console.log(`[evaluateAnalyticalAssay] analytical assay: ${o[e][n].analytical_assay}`),a[e][n].length>0&&(o[e][n][oe]=a[e][n][0][oe])}}return console.log(`[evaluateAnalyticalAssay] analyticalAssay: ${JSON.stringify(o)}`),o}(la.data.data);let ca;if(ca||(ca=sa.Outturn),ca||(ca=sa["Inturn Final"]),ca||(ca=sa.Inturn),ca||(ca=sa.Estimated),ca||(ca=sa.Planned),!ca)throw new Error(`No assay lot data with a valid method found for parcel ${xt[Y]}`);console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] weight lots for invoice evaluation=${JSON.stringify(aa)}`),console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] assay lots for invoice evaluation=${JSON.stringify(ca)}`);const da=await l.get(`/items/${ue}/${Xt}`,{params:{fields:[me]}});!function(e){if(!e)throw new Error("Contract data not found, please ensure the selected contract still exists");if(!e[me])throw new Error("The selected contract does not have a set currency, please ensure that the currency field for the contract is not empty")}(da.data.data);const ua=await l.get(`/items/${ct}/${da.data.data.contract_currency}`,{params:{fields:[dt]}});!function(e){if(!e)throw new Error("Currency data not found, please ensure the selected currency still exists");if(!e[dt])throw new Error("The selected currency in the contract is not valid")}(ua.data.data);const ma=ua.data.data.code,fa=await l.get(`/items/${Ae}?filter[${Ne}]=${Xt}`,{params:{fields:["id",Se,Te,Pe,Me,Ue,ke,Fe,je,Ie,Oe]}});!function(e){if(!e||0===e.length)throw new Error("No commodity data found in selected contract for parcel");if(!e.every((e=>e[Se])))throw new Error("The selected contract has an undefined commodity, please ensure that the 'Commodity' field for all commodites in the contract is not empty");if(!e.every((e=>e[Ie])))throw new Error("The selected contract has an undefined base price Uom for commodity, please ensure that the 'Base Price Uom' field for all commodites in the contract is not empty")}(fa.data.data),console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] contract commodity data=${JSON.stringify(fa.data.data)}`);const pa=[],ha=[];let ya="";for(const{id:e,commodity:r,primary_commodity:c,price_method:p,quotational_periods:k,price_per_uom:F,penalty_per_uom:j,treatment_charge_per_uom:V}of fa.data.data){const R=await l.get(`/items/${it}/${r}`,{params:{fields:[lt,st,U]}});if(qt(R.data.data,r),!ca[R.data.data.code]){console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}::comm=${R.data.data[lt]}] no analytical assay for commodity ${R.data.data.code} found, skipping...`);continue}if(c&&(ya=R.data.data[lt]),null!==k){const r=k;console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}::comm=${R.data.data[lt]}] qp=${JSON.stringify(r)}`);const c=Array.isArray(r)?r.find((e=>e.default)):null;if(!c)throw new Error(`No default quotational period found for commodity ${R.data.data.code}`);const C=r.filter((e=>!e.default)).map((e=>`${e.qp_period} ${e.qp_code}`)),j=[`${c.qp_period} ${c.qp_code}`,...C].join(", ");console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}::comm=${R.data.data[lt]}] evaluate payable assay for ${R.data.data.code} with an analytical assay=${null==(t=ca[R.data.data.code])?void 0:t.analytical_assay}`);const J=await l.get(`/items/${Ve}?filter[${Ge}]=${e}`,{params:{fields:[Le,He,Ke,Qe,Ye,Xe,ze,Re,Je,xe,Be,qe,We]}}),{payableAssay:x,expression:B}=await g(null==(a=ca[R.data.data.code])?void 0:a.analytical_assay,null==(o=ca[R.data.data.code])?void 0:o.assay_uom,J.data.data,R.data.data[lt]);let H,K,Q="";if("Final"!==i){const e={invoice_type:i,days:Zt[be],day_type:Zt[De],ref_day:Zt[Ce]};if(!e)throw new Error(`No provisional pricing found for invoice type ${i} for parcel ${xt[Y]}`);let t;switch(e.ref_day){case"Arrival Date":t=null!=(n=xt[q])?n:xt[W],Q="Actual Arrival Date from the Parcel form";break;case"B/L Date":t=null!=(s=xt[G])?s:xt[L],Q="B/L Date from the Parcel form";break;case"Invoice Date":t=null!=(d=xt[G])?d:xt[L],Q="B/L Date (or Estimated Date) as Invoice Date";break;case"Estimated Shipment Date":t=xt[L],Q="Estimated Shipment Date from the Parcel form";break;default:throw new Error(`Invalid reference day for invoice pricing: ${e.ref_day}; please contact Navarch for support`)}if(null==t)throw new Error(`Reference day for invoice pricing ${Q} is empty`);K=new Date(t);const a=parseInt(e.days),o=e.day_type;switch(o){case"Business Day(s)":H=S(K,a,!0);break;case"Calendar Day(s)":H=new Date(K.valueOf()),H.setDate(H.getDate()-a);break;default:throw new Error(`Invalid day type ${o} from contract ${Kt} for invoice type ${i}`)}}else{let e;switch(c.qp_code){case"MAMA":e=new Date(null!=(u=xt[q])?u:xt[W]),Q="Actual Arrival Date";break;case"MOSS":case"MOS":case"MOAS":e=new Date(null!=(m=xt[G])?m:xt[L]),Q="Estimated Shipment Date";break;default:throw new Error(`Unsupported QP code ${c.qp_code} in contract ${Kt}, currently only supports MAMA, MOS, MOSS, and MOAS`)}if(null==e)throw new Error(`Invalid reference day for ${Q} from contract ${Kt} for commodity ${R.data.data[lt]}`)}console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}::comm=${R.data.data[lt]}] provisional pricing date range: ${H.toString()} - ${K.toString()}`);const X=await Bt(R.data.data.code,R.data.data[U],p,H,K);let Z;const ee=await l.get(`/items/${Ze}?filter[${Ge}]=${e}`,{params:{fields:[He,Ke,Qe,Ye,et,tt,at,Xe]}});void 0!==ee.data.data&&null!==ee.data.data&&ee.data.data.length>0&&(Z=await D(X,null==(h=ca[R.data.data.code])||h.assay_uom,ee.data.data,R.data.data[lt]));const te=await l.get(`/items/${ut}/${F}`,{params:{fields:[mt]}});Wt(te.data.data,R.data.data[lt]);const ae=te.data.data[mt];let oe;if(Z){if(!V)throw new Error(`Treatment Charge Rate UOM is not defined for commodity ${R.data.data[lt]}`);const e=await l.get(`/items/${ut}/${V}`,{params:{fields:[mt]}});Gt(e.data.data,R.data.data[lt]),oe=e.data.data[mt]}const ne=await M(ae,aa.dry_weight_uom,null==(y=ca[R.data.data.code])?void 0:y.assay_uom);console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}::comm=${R.data.data[lt]}] payableMetalConversion for commodity ${R.data.data.name}: ${JSON.stringify(ne)}`),ne.initialConversion=1===(null==(_=ne.initialConversion)?void 0:_.conversionFactor)?void 0:ne.initialConversion,ne.finalConversion=1===(null==(v=ne.finalConversion)?void 0:v.conversionFactor)?void 0:ne.finalConversion,pa.push({commodity:R.data.data.name,analytical_assay:f(null==($=ca[R.data.data.code])?void 0:$.analytical_assay,4),deduction_expression:B,payable_assay:f(x,4),assay_uom:null==(w=ca[R.data.data.code])?void 0:w.assay_uom,payable_metal:f(aa.dry_weight*(null!=(b=null==(E=ne.initialConversion)?void 0:E.conversionFactor)?b:1)*(null!=x?x:1)*(null!=(T=null==(N=ne.finalConversion)?void 0:N.conversionFactor)?T:1)*("%"!==(null==(P=ca[R.data.data.code])?void 0:P.assay_uom)?1:.01),4),payable_metal_expression:`${f(aa.dry_weight,4)}${aa.dry_weight_uom}${ne.initialConversion?` * ${f(ne.initialConversion.conversionFactor,4)}${ne.initialConversion.conversionUom}`:""} * ${f(null!=x?x:1,4)}${"%"!==(null==(I=ca[R.data.data.code])?void 0:I.assay_uom)?`${null==(O=ca[R.data.data.code])?void 0:O.assay_uom}`:" / 100"}${ne.finalConversion?` * ${f(ne.finalConversion.conversionFactor,4)}${ne.finalConversion.conversionUom}`:""}`,payable_metal_uom:ae,qp:j,qp_start_date:A(H),qp_end_date:A(K),qp_date_range:`${A(H)} - ${A(K)}`,price_method:p,price_rate:f(X,4),price_per_uom:ae,price:f(aa.dry_weight*(null!=(fe=null==(z=ne.initialConversion)?void 0:z.conversionFactor)?fe:1)*(null!=x?x:1)*(null!=(Ee=null==(ge=ne.finalConversion)?void 0:ge.conversionFactor)?Ee:1)*("%"!==(null==(_t=ca[R.data.data.code])?void 0:_t.assay_uom)?1:.01)*X),treatment_charge:Z?{rate:f(Z.baseTreatmentCharge,4),discount:f((null!=(vt=Z.baseTreatmentCharge)?vt:0)-(null!=($t=Z.finalValue)?$t:0),4),final_rate:f(Z.finalValue,4),per_uom:oe,final_amount:f(aa.dry_weight*(null!=(wt=Z.finalValue)?wt:1))}:void 0,final_total:f(aa.dry_weight*(null!=(Nt=null==(gt=ne.initialConversion)?void 0:gt.conversionFactor)?Nt:1)*(null!=x?x:1)*(null!=(Tt=null==(St=ne.finalConversion)?void 0:St.conversionFactor)?Tt:1)*("%"!==(null==(Mt=ca[R.data.data.code])?void 0:Mt.assay_uom)?1:.01)*X-(Z?1:0)*(aa.dry_weight*(null!=(Ut=null==Z?void 0:Z.finalValue)?Ut:1)))})}const J=await l.get(`/items/${ot}?filter[${Ge}]=${e}`,{params:{fields:[He,Ke,Qe,Ye,nt,rt,Xe]}});if(J.data.data.length>0){if(null===j)throw new Error(`Please fill in the field for Penalty Per UOM in contract ${Kt} for commodity ${R.data.data[lt]}`);const e=await l.get(`/items/${ut}/${j}`,{params:{fields:[mt]}});Lt(e.data.data,R.data.data[lt]);const t=e.data.data[mt],{penalty:a,expression:o,bracket:n}=await C(null==(kt=ca[R.data.data.code])?void 0:kt.analytical_assay,J.data.data,ma,t,R.data.data[lt]);console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}::comm=${R.data.data[lt]}] evaluated penalty with an analytical assay=${null==(Ft=ca[R.data.data.code])?void 0:Ft.analytical_assay}, penaltyRate=${null==n?void 0:n.rate}, finalPenaltyRate=${a}, expression='${o}'`),ha.push({commodity:R.data.data.name,analytical_assay:f(null==(jt=ca[R.data.data.code])?void 0:jt.analytical_assay,4),deduction_expression:o,assay_uom:null==(Vt=ca[R.data.data.code])?void 0:Vt.assay_uom,penalty_rate:f(null==n?void 0:n.rate,4),penalty_per_uom:t,final_penalty_rate:f(a,4),final_penalty:f((null!=a?a:1)*aa.dry_weight)})}}console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] evaluated commodities=${JSON.stringify(pa)}`),console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] evaluated penalties${JSON.stringify(ha)}`);const _a=pa.reduce(((e,t)=>e+p(t.price)),0),va=pa.reduce(((e,t)=>{var a;return e+p(null==(a=t.treatment_charge)?void 0:a.final_amount)}),0),$a=ha.reduce(((e,t)=>e+p(t.final_penalty)),0);console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] TOTAL_REVENUE=${_a}, TOTAL_TREATMENT_CHARGE=${va}, TOTAL_PENALTIES=${$a}`);let wa,ga=0;const Ea=!!xt[X];Ea&&(ga=xt[X].reduce(((e,t)=>e+t.amount),0),wa={adjustments:xt[X].map((e=>({description:e.description,amount:f(e.amount)}))),total_adjustments:f(ga)});const ba=Zt[_e],Da=_a-va-$a+ga,Ca=null!=ba?Da*ba/100:void 0,Aa=await l.get(`/items/${Et}/${xt[J]}`,{params:{fields:[bt]}});Ht(Aa.data.data);const Na=xt[H];let Sa;Na&&(Sa=await l.get(`/items/${Ct}/${Na}`,{params:{fields:[At]}}),function(e){if(console.log("[validateVessel]"),!e)throw new Error("Vessel for parcel not found");if(!e[At])throw new Error("No name defined for vessel of the selected parcel")}(Sa.data.data));let Ta=(await l.get(`/items/${Pt}?filter[${It}]=${r}`,{params:{fields:["id",Ot]}})).data.data.reduce(((e,t)=>e+(t[Ot]?1:0)),0)+1,Pa=r;const Ia=Ta.toString().padStart(2,"0"),Oa=(xt[Y],Pa.toString().padStart(2,"0")),Ma={Counterparty:Aa.data.data[bt],Vessel:Sa?Sa.data.data[At]:"Vessel TBA","Shipment Date":xt[G]?A(new Date(xt[G])):xt[L]?A(new Date(xt[L])):"N/A","Arrival Date":xt[q]?A(new Date(xt[q])):xt[W]?A(new Date(xt[W])):"N/A",Status:xt[G]?"Unfinalised":"Planned",Revision:"Valuation",Invoice:`${i}:Valuation`,Parcel:`${xt[Y]} (#${Oa})`,"Invoice Due Date":A(e.dueDate),"Dry Weight":`${f(aa.dry_weight,4)} ${aa.dry_weight_uom}`,"Total Revenues USD":f(_a),"Total Penalties USD":f($a+va),...Jt(pa,aa.dry_weight),"Total Adjustments USD":Ea?wa.total_adjustments:"0.00","Parcel Value USD":f(Da),"Parcel Payable Value(Below Line) USD":f(Ca),"Payments USD":"To Be Completed","Due Total":"To Be Completed"};return console.log(`[generateInvoice][parcel=${xt[Y]}::invoice type=${i}] generated forecast invoice=${JSON.stringify(Ma)}`),Ma}catch(t){if(t instanceof Rt)return void console.error(`[generateInvoice][parcel=${e.parcelId}::invoice type=${e.invoiceType}]Non-fatal error: ${t.message}`);throw t}}(e)))));a("input",o),console.log(`[generateCashflow] cashflow response: ${JSON.stringify(o)}`),i.value=!1}catch(e){r.value=e.message}finally{i.value=!1}},viewDoc:function(e){const a=null!=e?e:t.value.doc_name;console.log(`[viewDoc] doc name: ${a}`);const o=`/display-doc?filepath=${encodeURIComponent(`/data/uploads/${a}.pdf`)}`;window.open(o)},failureReason:r};function Jt(e,t){return e.map((e=>{var t,a,o;return{[`${e.commodity} Payable Metal (${e.payable_metal_uom})`]:e.payable_metal,[`${e.commodity} Revenue (USD)`]:e.price,[`${e.commodity} QP Month`]:xt(new Date(e.qp_start_date)),[`${e.commodity} Price (USD/${e.price_per_uom})`]:e.price_rate,[`${e.commodity} TC (USD)`]:null==(t=e.treatment_charge)?void 0:t.final_amount,[`${e.commodity} TC (USD/${null==(a=e.treatment_charge)?void 0:a.per_uom})`]:null==(o=e.treatment_charge)?void 0:o.final_rate}})).reduce(((e,t)=>({...e,...t})),{})}function xt(e){return`${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]} ${e.getFullYear()}`}async function Bt(e,t,a,o,n,r=1){var i;if(console.log(`[getCommodityAvgPrice] commodity=${e}, commodityId=${t}, source=${a}, startDate=${o}, endDate=${n}, currency=${r}`),m(e))throw new Error(`Commodity ${e} is not defined for price calcualtion`);if(m(a))throw new Error(`Price method for commodity ${e} is not defined for price calcualtion`);if(m(o))throw new Error(`Start date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);if(m(n))throw new Error(`End date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);const c=await l.get(`/items/navarch_commodity_price?filter[_and][0][price_method][_eq]=${a}&filter[_and][0][currency][_eq]=${r}&filter[_and][1][date][_between][0]=${N(o)}&filter[_and][1][date][_between][1]=${N(n)}&sort=date`,{params:{fields:[Nt,St,Tt,"price_method"]}});if((null==(i=c.data)?void 0:i.data)&&Array.isArray(c.data.data)&&c.data.data.length>0){const t=c.data.data[c.data.data.length-1];if(new Date(t[Tt])>=n){return c.data.data.reduce(((t,o)=>{if(!o[St]&&!o[Nt])throw new Error(`Commodity ${e} for Price Method #${a} on the date of ${o[Tt]} does not have a price, please contact Navarch for assistance`);let n=Number(o[St]);if(isNaN(n)&&(n=Number(o[Nt])),isNaN(n))throw new Error(`The commodity price for ${e} of Price Method #${a} for the date of ${o[Tt]} is not a valid number, please contact Navarch for assistance`);return t+n}),0)/c.data.data.length}}if(!s.value[U])throw new Error("Please save the Cashflow form first before generating the cashflow doc");const d=await l.get("/items/navarch_forecast_price",{params:{filter:{[kt]:t,cashflow_forecast_id:s.value[U]},fields:[Ft,kt,jt,Vt]}});!function(e){if(!e||!Array.isArray(e)||0===e.length)throw new Error("No forecast price found, please ensure prices have been provided")}(d.data.data);const u=d.data.data.find((e=>{const t=new Date(e[jt]),a=new Date(e[Vt]);return t<=o&&a>=n}));if(!u)throw new Error(`No single forecast price found for commodity ${e} between ${N(o)} and ${N(n)}, please ensure there is only one price value for this range`);return u[Ft]}function qt(e,t){var a,o,n;if(console.log("[validateCommodityData]"),!e)throw new Error("commodity data response is null");if(!e[lt])throw new Error(`Commodity name for commodity ${null!=(a=e[st])?a:t} is undefined, please contact Navarch for assistance`);if(!e[st])throw new Error(`Commodity code for commodity ${null!=(o=e[lt])?o:t} is not defined, please contact Navarch for assistance`);if(!e[U])throw new Error(`Commodity ID for commodity ${null!=(n=e[lt])?n:t} is not defined, please contact Navarch for assistance`)}function Wt(e,t){if(!e)throw new Error(`Price per UOM for commodity ${t} is not a valid`);if(!e[mt])throw new Error(`Price per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function Gt(e,t){if(!e)throw new Error(`Treatment charge per UOM for commodity ${t} is not a valid`);if(!e[mt])throw new Error(`Treatment charge per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function Lt(e,t){if(!e)throw new Error(`Penalty per UOM for commodity ${t} is not a valid`);if(!e[mt])throw new Error(`Penalty per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function Ht(e){if(console.log("[validateCounterparty]"),!e)throw new Error("Counterparty for parcel not found");if(!e[bt])throw new Error("No codename defined for counterparty of the selected parcel")}}});const w={key:0},g={key:1};$.render=function(e,t,a,o,n,h){const y=r("v-button"),_=r("v-notice");return i(),l(s,null,[c(' <input :value="value" @input="handleChange($event.target.value)" /> '),c(" create a button only interface for Directus"),e.value?(i(),l("div",g,[d(y,{class:"margin-top-16px",onClick:t[1]||(t[1]=()=>e.viewDoc())},{default:u((()=>[m("View Cashflow ")])),_:1})])):(i(),l("div",w,[d(y,{class:"margin-top-16px",onClick:t[0]||(t[0]=()=>e.generateCashflow()),loading:e.isGeneraingDoc},{default:u((()=>[m("Generate Cashflow")])),_:1},8,["loading"]),e.failureReason?(i(),f(_,{key:0},{default:u((()=>[m(p(e.failureReason),1)])),_:1})):c("v-if",!0)]))],2112)},$.__file="src/interface.vue";var E=t({id:"navarch-docgen-cashflow",name:"Navarch Cashflow Generator Button",icon:"receipt_long",description:"This is my custom interface for Navarch's Cashflow Doc!",component:$,options:null,types:["json"],group:"standard"});export{E as default};
