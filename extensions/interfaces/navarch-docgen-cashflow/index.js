import{useApi as e,defineInterface as t}from"@directus/extensions-sdk";import{defineComponent as a,ref as o,inject as n,resolveComponent as r,openBlock as i,createElementBlock as l,Fragment as s,createCommentVNode as c,createVNode as d,withCtx as u,createTextVNode as m,createBlock as f,toDisplayString as p}from"vue";var y=(e=>(e.BRACKET="Brackets",e.MIN_DEDUCTION="Minimum Deduction",e.MAX_CAP="Maximum Cap",e))(y||{}),h=(e=>(e.PERCENTAGE="Percentage",e.FRACTIONAL="Fractional",e))(h||{}),v=(e=>(e.WET_WEIGHT="wet_weight",e.MOISTURE="moisture",e.DRY_WEIGHT="dry_weight",e))(v||{}),_=(e=>(e.METHOD="method",e.WET_WEIGHT_UOM="wet_weight_uom",e.MOISTURE_UOM="moisture_uom",e.DRY_WEIGHT_UOM="dry_weight_uom",e))(_||{}),g=a({props:{value:{type:Object,default:null}},emits:["input"],setup(t,{emit:a}){const r=o(""),i=o(!1),l=o(!1),s=e(),c=n("values",o({}));function d(e){if(console.log("[evaluateWeightData]"),0===e.length)return;const t=m(e,v.DRY_WEIGHT),a=m(e,v.WET_WEIGHT);return{method:u(e,_.METHOD),lots:e,dry_weight_uom:u(e,_.DRY_WEIGHT_UOM),wet_weight_uom:u(e,_.WET_WEIGHT_UOM),dry_weight:t,wet_weight:a,moisture:(a-t)/a*100}}function u(e,t){if(console.log("[getFirstValueAsSharedValue]"),0!==e.length)return console.log(`lots[0][${t.toString()}]=${e[0][t.toString()]}`),e[0][t.toString()]}function m(e,t){return console.log("[evaluateAggregateValue]"),e.reduce(((e,a)=>{var o;return e+(null!=(o=a[t.toString()])?o:0)}),0)}function f(e){return null==e}function p(e,t=2,a=!0){if(console.log("[formatNumber]"),isNaN(e)||null===e)return"-";const o=Math.round(e*Math.pow(10,t))/Math.pow(10,t),[n,r]=o.toString().split("."),i=n.replace(/\B(?=(\d{3})+(?!\d))/g,",");if(!r&&!a)return i;return`${i}.${(null!=r?r:"").padEnd(t,"0")}`}function g(e){if(console.log("[parseNumber]"),!e)return 0;const t=parseFloat(e.replace(/,/g,""));return console.log(`[parseNumber] number: ${e} to ${t}`),t}function w(e,t,a){var o,n,r;if(console.log("[findBracket]"),1===e.length){if(t>=(null!=(o=e[0].lower_threshold)?o:0)&&(null===e[0].upper_threshold||void 0===e[0].upper_threshold||t<e[0].upper_threshold))return e[0];throw new Error(`Evaluated monetary value $${t} does not fall within the only ${a.type} bracket with range ${null!=(n=e[0].lower_threshold)?n:0} - ${null!=(r=e[0].upper_threshold)?r:"âˆž"}`)}return e.find((e=>{var a,o;const n=t>(null!=(a=e.lower_threshold)?a:0)&&(null===e.upper_threshold||void 0===e.upper_threshold||t<e.upper_threshold)||e.lower_threshold_inclusive&&t===(null!=(o=e.lower_threshold)?o:0)||e.upper_threshold_inclusive&&t===e.upper_threshold;return console.log(`[findBracket] value=${t} for bracket: ${JSON.stringify(e)}? match=${!!n}`),n}))}function $(e,t){var a,o,n,r,i,l,s;console.log("[evaluateFinalValueFromBrackets]");const c=(e-(null!=(a=t.initial_adjustment)?a:0)*(null!=(o=t.initial_adjustment_conversion_factor)?o:1))*(null!=(n=t.rate)?n:0)*(t.rate_type===h.PERCENTAGE?.01:1)+(null!=(r=t.final_adjustment)?r:0)*(null!=(i=t.final_adjustment_conversion_factor)?i:1);switch(t.bracket_type){case y.MIN_DEDUCTION:if(null===t.comparator||void 0===t.comparator)throw new Error("Minimum deduction not found");const a=t.comparator*(null!=(l=t.comparator_conversion_factor)?l:1);return e-c<a?e-a:c;case y.MAX_CAP:if(null===t.comparator||void 0===t.comparator)throw new Error("Maximum cap not found");const o=t.comparator*(null!=(s=t.comparator_conversion_factor)?s:1);return c>o?o:c;case y.BRACKET:return c;default:throw new Error(`bracket type ${t.bracket_type} is not supported`)}}async function D(e,t,a,o){var n,r,i,l,s,c,d,u;if(console.log("[evaluatePayableAssay]"),!a||0===a.length)return{};const m=w(a,e,{commodityCode:o,type:"Payable Assay"});if(!m)throw new Error(`Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for payable assays`);let f,v,_=1;m.initial_adjustment_uom&&void 0!==m.initial_adjustment_uom&&null!==m.initial_adjustment_uom&&m.initial_adjustment_uom!==t&&(_=await M(m.initial_adjustment_uom,t),f=k(m.initial_adjustment_uom,t));let g,D=1;m.bracket_type===y.MAX_CAP?(v=null!=(n=m.maximum_cap)?n:0,void 0!==m.maximum_cap_uom&&null!==m.maximum_cap_uom&&m.maximum_cap_uom!==t&&(D=await M(m.maximum_cap_uom,t),g=k(m.maximum_cap_uom,t))):m.bracket_type===y.MIN_DEDUCTION&&(v=null!=(r=m.minimum_deduction)?r:0,void 0!==m.minimum_deduction_uom&&null!==m.minimum_deduction_uom&&m.minimum_deduction_uom!==t&&(D=await M(m.minimum_deduction_uom,t),g=k(m.minimum_deduction_uom,t)));const b=$(e,{bracket_type:m.bracket_type,rate:null!=(i=m.rate)?i:1,rate_type:null!=(l=m.rate_type)?l:h.FRACTIONAL,initial_adjustment:null!=(s=m.initial_adjustment)?s:0,initial_adjustment_conversion_factor:_,comparator:v,comparator_conversion_factor:D});let E="";const P=void 0!==m.initial_adjustment&&null!==m.initial_adjustment;if(m.bracket_type===y.BRACKET)E=`${P?"(":""}${p(e,4)}${null!=t?t:""}${P?` - ${p(m.initial_adjustment,4)}${null!=(c=m.initial_adjustment_uom)?c:`${null!=t?t:""}`}`:""}${P&&1!==_?` * ${p(_,4)}${f}`:""}${P?")":""} * ${p(m.rate,4)}${m.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`;else if(m.bracket_type===y.MIN_DEDUCTION){E=b===e-v*D?`${p(e,4)}${null!=t?t:""} - ${p(v,4)}${null!=t?t:""}${1!==D?` * ${p(D,4)}${g}`:""}`:`${P?"(":""}${p(e,4)}${null!=t?t:""}${P?` - ${p(m.initial_adjustment,4)}${null!=(d=m.initial_adjustment_uom)?d:`${null!=t?t:""}`}`:""}${P&&1!==_?` * ${p(_,4)}${f}`:""}${P?")":""} * ${p(m.rate,4)}${m.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`}else{if(m.bracket_type!==y.MAX_CAP)throw new Error(`[buildPayableAssayExpression] unknown bracket method: ${m.bracket_type}`);E=b===v*D?`${p(v,4)}${null!=t?t:""}${1!==D?` * ${p(D,4)}${g}`:""}`:`${P?"(":""}${p(e,4)}${null!=t?t:""}${P?` - ${p(m.initial_adjustment,4)}${null!=(u=m.initial_adjustment_uom)?u:`${null!=t?t:""}`}`:""}${P&&1!==_?` * ${p(_,4)}${f}`:""}${P?")":""} * ${p(m.rate,4)}${m.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`}return{payableAssay:b,expression:E}}console.log("[main] formValues=",c);const b="above the lower threshold, plus",E="below the upper threshold, minus";function P(e,t,a,o){var n,r,i,l;if(console.log("[evaluateTreatmentCharge]"),!a||!a.length)return;const s=w(a,e,{commodityCode:o,type:"Treatment Charge"});if(!s)throw new Error(`Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for treatment charge`);let c=0,d=1;if(s.use_btc)d=0,c=0;else if(d=null!=(n=s.rate)?n:1,s.for_every_unit===b)c=null!=(r=s.lower_threshold)?r:0;else{if(s.for_every_unit!==E)throw new Error(`[evaluateTreatmentCharge] unknown for_every_unit: ${s.for_every_unit}`);c=null!=(i=s.upper_threshold)?i:0}const u={bracket_type:y.BRACKET,rate:d,rate_type:h.FRACTIONAL,initial_adjustment:c,final_adjustment:null!=(l=s.base_treatment_charge)?l:0};return console.log(`[evaluateTreatmentCharge] bracketForEvaluation: ${JSON.stringify(u)}`),{finalValue:$(e,u),baseTreatmentCharge:s.base_treatment_charge}}function C(e,t,a,o,n){var r,i,l;if(console.log("[evaluatePenalty]"),!t||!t.length)return{};const s=w(t,e,{commodityCode:n,type:"Penalty"});if(!s)throw new Error(`[evaluatePenalty] Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for penalty`);let c=0,d=1;if(s.no_penalty)d=0,c=0;else if(d=null!=(r=s.rate)?r:1,s.for_every_unit===b)c=null!=(i=s.lower_threshold)?i:0;else{if(s.for_every_unit!==E)throw new Error(`[evaluatePenalty] unknown for_every_unit: ${s.for_every_unit}`);c=null!=(l=s.upper_threshold)?l:0}const u={bracket_type:y.BRACKET,rate:d,rate_type:h.FRACTIONAL,initial_adjustment:c,final_adjustment:0};console.log(`[evaluatePenalty] bracketForEvaluation: ${JSON.stringify(u)}`);const m=$(e,u),f=null!=u.initial_adjustment;let v="";return v=s.rate&&0!==s.rate?`${f?"(":""}${p(e,4)}${f?` - ${p(c,4)})`:""} / ${p(1,4)} * ${null!=a?a:""} ${p(d,4)}/${null!=o?o:""}`:"No penalty",{penalty:m,expression:v,bracket:s}}function S(e){const t=e.getDate(),a=e.getMonth(),o=e.getFullYear();return`${t} ${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][a]} ${o}`}function A(e,t=!0){const a=e.getMonth()+1,o=e.getDate();return`${e.getFullYear()}${t?"-":" "}${a<10?"0":""}${a}${t?"-":" "}${o<10?"0":""}${o}`}function N(e,t,a=!1){const o=new Date(e.valueOf());let n=t-(a?1:0);for(;n>0;)o.setDate(o.getDate()-1),0!==o.getDay()&&6!==o.getDay()&&(n-=1);return o.getHours()>=12&&o.setDate(o.getDate()+1),o}function O(e,t,a=!1){const o=new Date(e.valueOf());let n=t-(a?1:0);for(;n>0;)o.setDate(o.getDate()+1),0!==o.getDay()&&6!==o.getDay()&&(n-=1);return o.getHours()>=12&&o.setDate(o.getDate()+1),o}function T(e,t){const a=new Date(e.valueOf());return a.setMonth(a.getMonth()+t,1),a}function U(e,t){const a=new Date(e.valueOf());return a.setMonth(a.getMonth()+t+1,0),a}async function I(e,t){if(e===t)return 1;const a=await s.get(`/items/${vt}?filter[${_t}]=${e}`,{params:{fields:[bt]}});if(0===a.data.data.length||null===a.data.data[0][bt]||void 0===a.data.data[0][bt])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await s.get(`/items/${vt}?filter[${_t}]=${t}`,{params:{fields:[bt]}});if(0===o.data.data.length||null===o.data.data[0][bt]||void 0===o.data.data[0][bt])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for the target weight unit ${t}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(a.data.data[0][bt]);if(isNaN(n))throw new Error(`[getWeightUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);const r=parseFloat(o.data.data[0][bt]);if(isNaN(r))throw new Error(`[getWeightUnitConversionValue] target weight unit ${t} conversion value=${r} is not a number`);return n/r}async function M(e,t){if(null==e||null==t)return 1;if(e===t)return 1;const a=await s.get(`/items/${Et}?filter[${Pt}]=${e}`,{params:{fields:[Ct]}});if(0===a.data.data.length||void 0===a.data.data[0][Ct]||null===a.data.data[0][Ct])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await s.get(`/items/${Et}?filter[${Pt}]=${t}`,{params:{fields:[Ct]}});if(0===o.data.data.length||void 0===o.data.data[0][Ct]||null===o.data.data[0][Ct])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for the target weight unit ${t}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(a.data.data[0][Ct]);if(isNaN(n))throw new Error(`[getAssayUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);console.log(`[getAssayUnitConversionValue] source unit conversion value=${n}`);const r=parseFloat(o.data.data[0][Ct]);if(isNaN(r))throw new Error(`[getAssayUnitConversionValue] target weight unit ${e} conversion value=${r} is not a number`);return console.log(`[getAssayUnitConversionValue] target unit conversion value=${r}`),console.log("[getAssayUnitConversionValue] returning "+n/r),n/r}function k(e,t){if(void 0===e||void 0===t||null===e||null===t)return;const a=e.split("/"),o=t.split("/");if(a.length>2||o.length>2)throw new Error(`[getConversionUnit] sourceUnit=${e} and targetUnit=${t} must be in the format of 'unit1/unit2', an extra '/' was found`);if(1===a.length&&1===o.length)return`${o[0]}/${a[0]}`;if(1===a.length){const e=o[0]===a[0]?"":`${o[1]}(${a[1]})`,t=o[1];return""===t?e:`${e}/${t}`}if(1===o.length){const e=a[1],t=a[0]===o[0]?"":`${a[1]}(${o[0]})`;return""===t?e:`${e}/${t}`}{const e=a[0]===o[0],t=a[1]===o[1],n=e||""===a[0],r=e||""===o[0],i=t||""===a[1],l=t||""===o[1],s=!i&&!r,c=!n&&!l,d=`${i?"":a[1]}${s?"(":""}${r?"":`${o[0]}`}${s?")":""}`,u=`${n?"":a[0]}${c?"(":""}${l?"":`${o[1]}`}${c?")":""}`;return""===u?d:`${d}/${u}`}}async function F(e,t,a){const o=await s.get(`/items/${vt}?filter[${gt}]=${t}`,{params:{fields:[_t]}});if(!o.data.data||!o.data.data[0]||!o.data.data[0][_t])throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] Dry weight uom not found for symbol ${t}`);const n=o.data.data[0][_t];if("%"===a){if(n===e)return{};const t=k(n,e);if(!t)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and target weight unit ${e}`);return{finalConversion:{conversionFactor:await I(n,e),conversionUom:t}}}let r=a.split("/");if(1==r.length){const e=await async function(e){const t=await s.get(`/items/${Et}`,{params:{fields:[Pt,St],filter:{[St]:{_nnull:!0},[Pt]:{_eq:e}}}});if(200!==t.status||!t.data||0===t.data.data.length)throw new Error("[getAssayUnitComposition] no assay units found with composition");return t.data.data[0][St]}(a);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${a} does not have a composition`);r=e.split("/")}if(r.length>2||0===r.length)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${a} is not in the format of 'unit1/unit2'`);const i=r[0],l=r[1],c={};if(l!==n){const e=k(n,l);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and assay unit denominator unit ${l}`);c.initialConversion={conversionFactor:await I(n,l),conversionUom:e}}if(i!==e){const t=k(i,e);if(!t)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for target weight unit ${e} and assay unit numerator unit ${i}`);c.finalConversion={conversionFactor:await I(i,e),conversionUom:t}}return c}const j="id",V="foreign_key",B="lot_number",J="method",R="navarch_cashflow",x="navarch_parcel",q="contract",L="counterparty",W="assay_results",G="weight_result",H="actual_arrival_date",K="estimate_arrival_date",Q="bl_date",Y="estimated_shipment_date",X="vessel",z="origin",Z="destination",ee="shipment_code",te="adjustments",ae="parcel_finalisation_date",oe="navarch_assay_lot",ne="commodity",re="dry_weight",ie="buyer_assay",le="seller_assay",se="final_assay",ce="assay_uom",de="lot_number",ue="navarch_weight_lot",me="dry_weight",fe="wet_weight",pe="moisture",ye="wet_weight_uom",he="dry_weight_uom",ve="navarch_contract",_e="contract_currency",ge="name",we="navarch_contract_payment_information",$e="related_contract",De="invoice_type",be="pay_percent",Ee="pa_days",Pe="pa_day_type",Ce="pa_ref_day",Se="pa_cashflow_days",Ae="pa_cashflow_day_type",Ne="pp_days",Oe="pp_day_type",Te="pp_ref_day",Ue="navarch_commodity_in_contract",Ie="contract",Me="commodity",ke="primary_commodity",Fe="price_method",je="price_per_uom",Ve="treatment_charge_per_uom",Be="quotational_periods",Je="payable_assay_rates",Re="treatment_charge_rates",xe="penalty_rates",qe="penalty_per_uom",Le="navarch_payable_assay_bracket",We="initial_adjustment",Ge="initial_adjustment_uom",He="minimum_deduction",Ke="minimum_deduction_uom",Qe="maximum_cap",Ye="maximum_cap_uom",Xe="related_commodity_in_contract",ze="bracket_type",Ze="lower_threshold",et="lower_threshold_inclusive",tt="upper_threshold",at="upper_threshold_inclusive",ot="rate",nt="rate_type",rt="navarch_treatment_charge_bracket",it="base_treatment_charge",lt="use_btc",st="for_every_unit",ct="navarch_penalty_bracket",dt="no_penalty",ut="for_every_unit",mt="navarch_commodity",ft="name",pt="code",yt="navarch_currency",ht="code",vt="navarch_unit",_t="symbol",gt="dry_symbol",wt="wet_symbol",$t="dry_unit",Dt="wet_unit",bt="conversionToGram",Et="navarch_assay_unit",Pt="unit",Ct="conversion_to_ppb",St="composition",At="navarch_counterparty",Nt="codename",Ot="name",Tt="navarch_vessel",Ut="name",It="price_pm",Mt="average_price",kt="date",Ft="navarch_invoices",jt="parcel",Vt="invoice",Bt="invoice_date",Jt="amount_paid",Rt="invoice_type",xt="navarch_forecast_price",qt="commodity",Lt="price",Wt="start_date",Gt="end_date",Ht={Advance:0,"Second Advance":1,"Third Advance":2,"Fourth Advance":3,Provisional:4,"Second Provisional":5,"Third Provisional":6,"Fourth Provisional":7,Final:8};function Kt(e){const t=[...new Set(e.flatMap((e=>Object.keys(e))))],a=e.map((e=>t.map((t=>{const a=e[t]||"";return"string"==typeof a&&a.includes(",")?`"${a}"`:a})).join(",")));return[t.join(","),...a].join("\n")}class Qt extends Error{constructor(e){super(e),this.name="NonFatalError",Object.setPrototypeOf(this,Qt.prototype)}}return{isGeneraingDoc:i,invoiceUrl:c.value,generateCashflow:async function(){r.value="";try{i.value=!0;const e=await async function(){const e=new Date(c.value.start_date);if("Invalid Date"===e.toString())throw r.value="Start date is invalid",new Error("Start date is invalid");const t=new Date(c.value.end_date);if("Invalid Date"===t.toString())throw r.value="End date is invalid",new Error("End date is invalid");const a=await s.get(`/items/${ve}`,{params:{fields:[ge,j,"invoice_type"]}}),o={};await Promise.all(a.data.data.map((async a=>{var n,r,i,l,c;const d=await s.get(`/items/${we}`,{params:{filter:{[$e]:{_eq:a[j]}},fields:[De,Ee,Pe,Ce,Se,Ae]}}),u=await s.get(`/items/${x}`,{params:{filter:{[q]:{_eq:a[j]}},fields:[j,ee,H,K,Q,Y,ae]}});for(const m of d.data.data){const d={days:"Final"===m[Rt]?m[Se]:m[Ee],day_type:"Final"===m[Rt]?m[Ae]:m[Pe],ref_day:"Final"===m[Rt]?"QP Month + n days":m[Ce]};if(!d)throw new Error(`Contract ${a[ge]} does not have a payment advice for invoice type ${m[Rt]}`);let f,p="";for(const y of u.data.data){switch(d.ref_day){case"Arrival Date":p="Actual Arrival Date from the Parcel form",f=null!=(n=y[H])?n:y[K];break;case"B/L Date":p="B/L Date (or Estimated Shipment Date) from the Parcel form",f=null!=(r=y[Q])?r:y[Y];break;case"Invoice Date":p="Invoice Date (using the B/L Date or Estimated Shipment Date from the Parcel form)",f=null!=(i=y[Q])?i:y[Y];break;case"Estimated Shipment Date":p="Estimated Shipment Date from the Parcel form",f=y[Y];break;case"QP Month + n days":const e=await s.get(`items/${Ue}`,{params:{filter:{[Ie]:{_eq:a[j]},payable_commodity:{_eq:!0}},fields:[Be]}});if(!Array.isArray(e.data.data)||0===e.data.data.length)throw new Error(`Contract ${a[ge]} does not have any payable commodities`);const t=e.data.data.map((e=>e[Be].find((e=>!!e.default)))),o=t.reduce(((e,t)=>t.qp_period>e.qp_period?t:e),t[0]);let u;switch(o.qp_code){case"MAMA":p="Actual Arrival Date (or Estimated Arrival Date) from the Parcel form",u=null!=(l=y[H])?l:y[K];break;case"MOSS":case"MOS":case"MOAS":p="B/L Date (or Estimated Shipment Date) from the Parcel form",u=null!=(c=y[Q])?c:y[Y];break;default:throw new Error(`Unsupported QP code ${o.qp_code}, currently only supports MAMA, MOS, MOSS, and MOAS`)}const m=U(new Date(u),o.qp_period);if(!m||"Invalid Date"===m.toString())throw new Error(`Invalid date for last date of QP month: ${m}, please ensure all fields for QP for contract ${a[ge]} and the ${p} in parcel ${y[ee]} are filled in`);f=m.toISOString();break;default:throw new Error(`Invalid reference day for payment advice: ${d.ref_day}; please contact Navarch for support`)}if(null==f)throw new Error(`Reference day for payment advice ${p} is empty in parcel ${y[ee]}`);const u=new Date(f),h=parseInt(d.days);let v;switch(d.day_type){case"Business Day(s)":v=O(u,h,!0);break;case"Calendar Day(s)":v=new Date(u.valueOf()),v.getHours()>=12?v.setDate(v.getDate()+h+1):v.setDate(v.getDate()+h);break;default:throw new Error(`Please provide a valid Day Type (Cashflow) for ${a[ge]}:Final Invoice Type`)}v>=e&&v<=t&&(o[y[j]]||(o[y[j]]=[]),o[y[j]].push({invoiceType:m[De],dueDate:v,parcelId:y[j],contractName:a[ge]}))}}})));const n=Object.keys(o),i=await s.get(`/items/${x}`,{params:{filter:{[j]:{_in:n}},fields:[j,q,L,W,G,H,K,Q,Y,X,z,Z,ee,te,"parcel_finalised",ae,W]}});if(!i.data.data||i.data.data.length!==n.length)throw new Error("Experiencing some network issues, please try again. If the issue persists, contact Navarch for support");const l={parcelData:i.data.data.reduce(((e,t)=>(e[t[j]]=t,e)),{}),contractNameByParcelId:n.reduce(((e,t)=>(e[t]=o[t][0].contractName,e)),{}),invoiceTypeParcel:n.flatMap((e=>o[e])),parcelIds:n};return console.log(`[getApplicableParcels] returnObject=${JSON.stringify(l)}`),l}(),t=await async function(e){const t=[],a=await s.get(`/items/${Ft}`,{params:{filter:{[jt]:{_in:e.parcelIds},[Vt]:{_nnull:!0}},fields:[jt,Rt,Vt,Bt,Jt]}});a.data.data.sort(((e,t)=>{const a=Ht[e[Rt]]-Ht[t[Rt]];return 0===a?new Date(t[Bt]).valueOf()-new Date(e[Bt]).valueOf():a}));for(const o of e.invoiceTypeParcel){const n=a.data.data.find((e=>e[jt]===o.parcelId&&e[Rt]===o.invoiceType));n?t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,invoiceData:{...n[Vt],amount_paid:n[Jt]}}):t.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,parcelData:e.parcelData[o.parcelId]})}return console.log(`[generateInvoiceParamForParcel] invoiceParams=${JSON.stringify(t)}`),t}(e);console.log(`[generateCashflow] form values=${JSON.stringify(c.value)}`);const o=await Promise.all(t.map((async e=>(console.log(`[generateCashflow] invoiceParam=${JSON.stringify(e)}`),await async function(e){var t,a,o,n,l,c,u,m,f,y,h,v,_,w,$,b,E,A,O,I,M,k,R,ae,ge,Se,Ae,bt,Et,Pt,Ct,St,It,Mt,kt,Bt,Jt,Rt,xt;r.value="",i.value=!0;try{if(e.invoiceData){console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] using existing invoice=${JSON.stringify(e.invoiceData)}`);const t=e.invoiceData,a=await s.get(`/items/${At}`,{params:{filter:{[Ot]:{_eq:t.buyer}},fields:[Nt]}});na(a.data.data[0]);const o=await s.get(`/items/${x}`,{params:{filter:{[j]:{_eq:e.parcelId}},fields:[Q,H,K]}});console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] parcel date data=${JSON.stringify(o.data.data)}`);const n=o.data.data[0];return{Counterparty:a.data.data[0][Nt],Vessel:"N/A"===t.vessel?"Vessel TBA":t.vessel,"Shipment Date":t.bl_date,"Arrival Date":n[H]?S(new Date(n[H])):n[K]?S(new Date(n[K])):"N/A",Status:o[Q]?"Unfinalised":"Planned",Revision:"Original",Invoice:`${t.invoice_type}:Original`,Parcel:t.parcel,"Invoice Due Date":S(e.dueDate),"Dry Weight":`${t.dry_weight} ${t.dry_weight_uom}`,"Total Revenues USD":t.total_revenue,"Total Penalties USD":t.total_deductions,...await Xt(t.commodities,{dryWeight:g(t.dry_weight),dryWeightUom:t.dry_weight_uom}),"Total Adjustments USD":t.adjustments?t.adjustments.total_adjustments:"0.00","Parcel Value USD":t.invoice_value,"Parcel Payable Value(Below Line) USD":t.payable_amount,"Payments USD":t.amount_paid,"Due Total":t.balance_in_sellers_favor,metadata:{invoiceTypeRanking:Ht[t.invoice_type]}}}if(void 0===e.parcelData)throw new Qt(`Something went wrong, no parcel or invoice data for Invoice of parcel id ${e.parcelId.substring(0,5)} and invoice type ${e.invoiceType}`);const r=e.parcelId;if(!r)return void console.error(`[generateInvoice] A parcel id is not defined for invoice type ${e.invoiceType}`);const i=e.invoiceType,qt=e.parcelData,Lt=e.contractName;console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] parcel data=${JSON.stringify(qt)}`),function(e){if(!e)throw new Error("Parcel data not found, please ensure the selected parcel still exists");if(!e[ee])throw new Error("One of the parcels does not have a shipment code, please ensure that all parcels have a shipment code");if(!e[q])throw new Error(`The parcel ${e[ee]} does not have a contract, please ensure that the contract field for the parcel is not empty`);if(!e[L])throw new Error(`The parcel ${e[ee]} does not havea counterparty, please ensure that the counterparty field for the parcel is not empty`);if(!e[W])throw new Qt(`The parcel ${e[ee]} does not have assay results`);if(!e[G])throw new Qt(`The parcel ${e[ee]} does not have weight results`);if(!e[z])throw new Error(`The parcel ${e[ee]} does not havean origin port`);if(!e[Z])throw new Error(`The parcel ${e[ee]} does not havea destination port`)}(qt);const Wt=qt[W],Gt=qt[G],Kt=qt[q];if(!Kt)throw new Error(`Contract not found for parcel ${qt[ee]}`);const Yt=await s.get(`/items/${we}`,{params:{filter:{[$e]:{_eq:Kt},[De]:{_eq:i}},fields:[De,be,Ee,Pe,Ce,Ne,Oe,Te]}});if(Yt.data.data&&0===Yt.data.data.length)throw new Error(`No invoice type found for the contract ${Lt}`);const zt=Yt.data.data.find((e=>e[De]===i));if(!zt)throw new Error(`Cannot find payment information for ${i} in the contract ${Lt}, please ensure that data for it has been entered and saved`);const ra=await s.get(`/items/${ue}?filter[${V}]=${Gt}&sort[]=${B}`,{params:{fields:[j,me,fe,J,pe,ye,he]}});console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] weight lots data=${JSON.stringify(ra.data.data)}`),function(e){if(!e||0===e.length)throw new Qt("No weight lots found for the selected parcel")}(ra.data.data);const ia=function(e){console.log("[evaluateWeights]");const t={};for(const a of e)t[a.method]||(console.log(`adding method ${a.method} to weightData object`),t[a.method]=[]),console.log(`adding lot ${a.id} to weightData.${a.method} array`),t[a.method.toString()].push(a);const a=[];for(const e of Object.keys(t)){if(!t[e]){console.log(`method=${e} does not exist in weightData object`);continue}console.log(`adding lots and other values to weights for method=${e}`);const o=d(t[e]);o&&a.push(o)}return a}(ra.data.data);let la;if(la||(la=ia.find((e=>"Outturn"===e.method))),la||(la=ia.find((e=>"Inturn Final"===e.method))),la||(la=ia.find((e=>"Inturn"===e.method))),la||(la=ia.find((e=>"Estimated"===e.method))),la||(la=ia.find((e=>"Planned"===e.method))),!la)throw new Error(`No weight lots with valid method found for parcel ${qt[ee]}`);if(void 0===la.dry_weight||null===la.dry_weight||void 0===la.wet_weight||null===la.wet_weight||void 0===la.moisture||null===la.moisture||void 0===la.dry_weight_uom||null===la.dry_weight_uom||void 0===la.wet_weight_uom||null===la.wet_weight_uom||void 0===la.method||null===la.method)throw new Error(`One of the fields for the latest weight lots data is undefined for parcel ${qt[ee]}`);const sa=await s.get(`/items/${vt}?filter[${gt}]=${la.dry_weight_uom}`,{params:{fields:[$t]}}),ca=await s.get(`/items/${vt}?filter[${wt}]=${la.wet_weight_uom}`,{params:{fields:[Dt]}});if(!sa.data.data||!sa.data.data[0]||!sa.data.data[0][$t])throw new Error(`Dry weight uom not found for symbol ${la.dry_weight_uom} for parcel ${qt[ee]}`);if(!ca.data.data||!ca.data.data[0]||!ca.data.data[0][Dt])throw new Error(`Wet weight uom not found for symbol ${la.wet_weight_uom} for parcel ${qt[ee]}`);const da=sa.data.data[0][$t],ua=(da.indexOf("dry"),ca.data.data[0][Dt]),ma=(ua.indexOf("wet"),await s.get(`/items/${oe}?filter[${V}]=${Wt}&sort[]=${B}`,{params:{fields:[j,ne,J,re,ie,le,se,de,ce]}}));console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] assay lots data=${JSON.stringify(ma.data.data)}`),function(e){if(!e||0===e.length)throw new Qt("No assay lots found for the selected parcel")}(ma.data.data);const fa=function(e){var t,a,o;console.log("[evaluateAnalyticalAssay]");const n={};for(const t of e)n[t.method]||(n[t.method]={}),n[t.method][t.commodity]||(n[t.method][t.commodity]=[]),null!==t.lot_number?(1===n[t.method][t.commodity].length&&null===n[t.method][t.commodity][0].lot_number&&(n[t.method][t.commodity]=[]),n[t.method][t.commodity].push(t)):null===t.lot_number&&0===n[t.method][t.commodity].length&&n[t.method][t.commodity].push(t);console.log(`[evaluateAnalyticalAssay] group: ${JSON.stringify(n)}}`);const r={};for(const e in n){console.log(`[evaluateAnalyticalAssay] methodKey: ${e}, group[methodKey]: ${JSON.stringify(n[e])}`);for(const i in n[e]){console.log(`[evaluateAnalyticalAssay] commodityKey: ${i}, group[methodKey][commodityKey]: ${JSON.stringify(n[e][i])}`),r[e]=null!=(t=r[e])?t:{},r[e][i]={};const l=n[e][i].reduce(((e,t)=>e+t[re]),0);console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${l} from ${JSON.stringify(n[e][i])}`);const s=null!=(o=currentValue[se])?o:null!=(a=currentValue[le])?a:currentValue[ie];r[e][i].analytical_assay=n[e][i].reduce(((e,t)=>e+s*t[re]),0)/(0!==l?l:1),console.log(`[evaluateAnalyticalAssay] analytical assay: ${r[e][i].analytical_assay}`),n[e][i].length>0&&(r[e][i][ce]=n[e][i][0][ce])}}return console.log(`[evaluateAnalyticalAssay] analyticalAssay: ${JSON.stringify(r)}`),r}(ma.data.data);let pa;if(pa||(pa=fa.Outturn),pa||(pa=fa["Inturn Final"]),pa||(pa=fa.Inturn),pa||(pa=fa.Estimated),pa||(pa=fa.Planned),!pa)throw new Error(`No assay lot data with a valid method found for parcel ${qt[ee]}`);console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] weight lots for invoice evaluation=${JSON.stringify(la)}`),console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] assay lots for invoice evaluation=${JSON.stringify(pa)}`);const ya=await s.get(`/items/${ve}/${Kt}`,{params:{fields:[_e]}});!function(e){if(!e)throw new Error("Contract data not found, please ensure the selected contract still exists");if(!e[_e])throw new Error("The selected contract does not have a set currency, please ensure that the currency field for the contract is not empty")}(ya.data.data);const ha=await s.get(`/items/${yt}/${ya.data.data.contract_currency}`,{params:{fields:[ht]}});!function(e){if(!e)throw new Error("Currency data not found, please ensure the selected currency still exists");if(!e[ht])throw new Error("The selected currency in the contract is not valid")}(ha.data.data);const va=ha.data.data.code,_a=await s.get(`/items/${Ue}?filter[${Ie}]=${Kt}`,{params:{fields:["id",Me,ke,Fe,Be,Je,Re,xe,qe,je,Ve]}});!function(e){if(!e||0===e.length)throw new Error("No commodity data found in selected contract for parcel");if(!e.every((e=>e[Me])))throw new Error("The selected contract has an undefined commodity, please ensure that the 'Commodity' field for all commodites in the contract is not empty");if(!e.every((e=>e[je])))throw new Error("The selected contract has an undefined base price Uom for commodity, please ensure that the 'Base Price Uom' field for all commodites in the contract is not empty")}(_a.data.data),console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] contract commodity data=${JSON.stringify(_a.data.data)}`);const ga=[],wa=[];let $a="";for(const{id:e,commodity:r,primary_commodity:d,price_method:g,quotational_periods:V,price_per_uom:B,penalty_per_uom:J,treatment_charge_per_uom:x}of _a.data.data){const q=await s.get(`/items/${mt}/${r}`,{params:{fields:[ft,pt,j]}});if(ea(q.data.data,r),!pa[q.data.data.code]){console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}::comm=${q.data.data[ft]}] no analytical assay for commodity ${q.data.data.code} found, skipping...`);continue}if(d&&($a=q.data.data[ft]),null!==V){const r=V;console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}::comm=${q.data.data[ft]}] qp=${JSON.stringify(r)}`);const d=Array.isArray(r)?r.find((e=>e.default)):null;if(!d)throw new Error(`No default quotational period found for commodity ${q.data.data.code}`);const C=r.filter((e=>!e.default)).map((e=>`${e.qp_period} ${e.qp_code}`)),J=[`${d.qp_period} ${d.qp_code}`,...C].join(", ");console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}::comm=${q.data.data[ft]}] evaluate payable assay for ${q.data.data.code} with an analytical assay=${null==(t=pa[q.data.data.code])?void 0:t.analytical_assay}`);const L=await s.get(`/items/${Le}?filter[${Xe}]=${e}`,{params:{fields:[ze,Ze,et,tt,at,ot,nt,We,Ge,He,Ke,Qe,Ye]}}),{payableAssay:W,expression:G}=await D(null==(a=pa[q.data.data.code])?void 0:a.analytical_assay,null==(o=pa[q.data.data.code])?void 0:o.assay_uom,L.data.data,q.data.data[ft]);let X,z,Z="";if("Final"!==i){const e={invoice_type:i,days:zt[Ne],day_type:zt[Oe],ref_day:zt[Te]};if(!e)throw new Error(`No provisional pricing found for invoice type ${i} for parcel ${qt[ee]}`);let t;switch(e.ref_day){case"Arrival Date":t=null!=(n=qt[H])?n:qt[K],Z="Actual Arrival Date from the Parcel form";break;case"B/L Date":t=null!=(l=qt[Q])?l:qt[Y],Z="B/L Date from the Parcel form";break;case"Invoice Date":t=null!=(c=qt[Q])?c:qt[Y],Z="B/L Date (or Estimated Date) as Invoice Date";break;case"Estimated Shipment Date":t=qt[Y],Z="Estimated Shipment Date from the Parcel form";break;default:throw new Error(`Invalid reference day for invoice pricing: ${e.ref_day}; please contact Navarch for support`)}if(null==t)throw new Error(`Reference day for invoice pricing ${Z} is empty`);z=new Date(t);const a=parseInt(e.days),o=e.day_type;switch(o){case"Business Day(s)":X=N(z,a,!0);break;case"Calendar Day(s)":X=new Date(z.valueOf()),X.setDate(X.getDate()-a);break;default:throw new Error(`Invalid day type ${o} from contract ${Lt} for invoice type ${i}`)}}else{let e;switch(d.qp_code){case"MAMA":e=new Date(null!=(u=qt[H])?u:qt[K]),Z="Actual Arrival Date";break;case"MOSS":case"MOS":case"MOAS":e=new Date(null!=(m=qt[Q])?m:qt[Y]),Z="Estimated Shipment Date";break;default:throw new Error(`Unsupported QP code ${d.qp_code} in the contract ${Lt}, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}if(null==e)throw new Error(`Invalid reference day for ${Z} from contract ${Lt} for commodity ${q.data.data[ft]}`);X=T(e,d.qp_period),z=U(e,d.qp_period)}console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}::comm=${q.data.data[ft]}] provisional pricing date range: ${X.toString()} - ${z.toString()}`);const te=await Zt(q.data.data.code,q.data.data[j],g,X,z);let oe;const ne=await s.get(`/items/${rt}?filter[${Xe}]=${e}`,{params:{fields:[Ze,et,tt,at,it,lt,st,ot]}});void 0!==ne.data.data&&null!==ne.data.data&&ne.data.data.length>0&&(oe=await P(te,null==(f=pa[q.data.data.code])||f.assay_uom,ne.data.data,q.data.data[ft]));const re=await s.get(`/items/${vt}/${B}`,{params:{fields:[_t]}});ta(re.data.data,q.data.data[ft]);const ie=re.data.data[_t];let le;if(oe){if(!x)throw new Error(`Treatment Charge Rate UOM is not defined for commodity ${q.data.data[ft]}`);const e=await s.get(`/items/${vt}/${x}`,{params:{fields:[_t]}});aa(e.data.data,q.data.data[ft]),le=e.data.data[_t]}const se=await F(ie,la.dry_weight_uom,null==(y=pa[q.data.data.code])?void 0:y.assay_uom);console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}::comm=${q.data.data[ft]}] payableMetalConversion for commodity ${q.data.data.name}: ${JSON.stringify(se)}`),se.initialConversion=1===(null==(h=se.initialConversion)?void 0:h.conversionFactor)?void 0:se.initialConversion,se.finalConversion=1===(null==(v=se.finalConversion)?void 0:v.conversionFactor)?void 0:se.finalConversion,ga.push({commodity:q.data.data.name,analytical_assay:p(null==(_=pa[q.data.data.code])?void 0:_.analytical_assay,4),deduction_expression:G,payable_assay:p(W,4),assay_uom:null==(w=pa[q.data.data.code])?void 0:w.assay_uom,payable_metal:p(la.dry_weight*(null!=(b=null==($=se.initialConversion)?void 0:$.conversionFactor)?b:1)*(null!=W?W:1)*(null!=(A=null==(E=se.finalConversion)?void 0:E.conversionFactor)?A:1)*("%"!==(null==(O=pa[q.data.data.code])?void 0:O.assay_uom)?1:.01),4),payable_metal_expression:`${p(la.dry_weight,4)}${la.dry_weight_uom}${se.initialConversion?` * ${p(se.initialConversion.conversionFactor,4)}${se.initialConversion.conversionUom}`:""} * ${p(null!=W?W:1,4)}${"%"!==(null==(I=pa[q.data.data.code])?void 0:I.assay_uom)?`${null==(M=pa[q.data.data.code])?void 0:M.assay_uom}`:" / 100"}${se.finalConversion?` * ${p(se.finalConversion.conversionFactor,4)}${se.finalConversion.conversionUom}`:""}`,payable_metal_uom:ie,qp:J,qp_start_date:S(X),qp_end_date:S(z),price_method:g,price_rate:p(te,4),price_per_uom:ie,price:p(la.dry_weight*(null!=(R=null==(k=se.initialConversion)?void 0:k.conversionFactor)?R:1)*(null!=W?W:1)*(null!=(ge=null==(ae=se.finalConversion)?void 0:ae.conversionFactor)?ge:1)*("%"!==(null==(Se=pa[q.data.data.code])?void 0:Se.assay_uom)?1:.01)*te),treatment_charge:oe?{rate:p(oe.baseTreatmentCharge,4),discount:p((null!=(Ae=oe.baseTreatmentCharge)?Ae:0)-(null!=(bt=oe.finalValue)?bt:0),4),final_rate:p(oe.finalValue,4),per_uom:le,final_amount:p(la.dry_weight*(null!=(Et=oe.finalValue)?Et:1))}:void 0,final_total:p(la.dry_weight*(null!=(Ct=null==(Pt=se.initialConversion)?void 0:Pt.conversionFactor)?Ct:1)*(null!=W?W:1)*(null!=(It=null==(St=se.finalConversion)?void 0:St.conversionFactor)?It:1)*("%"!==(null==(Mt=pa[q.data.data.code])?void 0:Mt.assay_uom)?1:.01)*te-(oe?1:0)*(la.dry_weight*(null!=(kt=null==oe?void 0:oe.finalValue)?kt:1)))})}const L=await s.get(`/items/${ct}?filter[${Xe}]=${e}`,{params:{fields:[Ze,et,tt,at,dt,ut,ot]}});if(L.data.data.length>0){if(null===J)throw new Error(`Please fill in the field for Penalty Per UOM in contract ${Lt} for commodity ${q.data.data[ft]}`);const e=await s.get(`/items/${vt}/${J}`,{params:{fields:[_t]}});oa(e.data.data,q.data.data[ft]);const t=e.data.data[_t],{penalty:a,expression:o,bracket:n}=await C(null==(Bt=pa[q.data.data.code])?void 0:Bt.analytical_assay,L.data.data,va,t,q.data.data[ft]);console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}::comm=${q.data.data[ft]}] evaluated penalty with an analytical assay=${null==(Jt=pa[q.data.data.code])?void 0:Jt.analytical_assay}, penaltyRate=${null==n?void 0:n.rate}, finalPenaltyRate=${a}, expression='${o}'`),wa.push({commodity:q.data.data.name,analytical_assay:p(null==(Rt=pa[q.data.data.code])?void 0:Rt.analytical_assay,4),deduction_expression:o,assay_uom:null==(xt=pa[q.data.data.code])?void 0:xt.assay_uom,penalty_rate:p(null==n?void 0:n.rate,4),penalty_per_uom:t,final_penalty_rate:p(a,4),final_penalty:p((null!=a?a:1)*la.dry_weight)})}}console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] evaluated commodities=${JSON.stringify(ga)}`),console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] evaluated penalties${JSON.stringify(wa)}`);const Da=ga.reduce(((e,t)=>e+g(t.price)),0),ba=ga.reduce(((e,t)=>{var a;return e+g(null==(a=t.treatment_charge)?void 0:a.final_amount)}),0),Ea=wa.reduce(((e,t)=>e+g(t.final_penalty)),0);console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] TOTAL_REVENUE=${Da}, TOTAL_TREATMENT_CHARGE=${ba}, TOTAL_PENALTIES=${Ea}`);let Pa,Ca=0;const Sa=!!qt[te];Sa&&(Ca=qt[te].reduce(((e,t)=>e+t.amount),0),Pa={adjustments:qt[te].map((e=>({description:e.description,amount:p(e.amount)}))),total_adjustments:p(Ca)});const Aa=zt[be],Na=Da-ba-Ea+Ca,Oa=null!=Aa?Na*Aa/100:void 0,Ta=await s.get(`/items/${At}/${qt[L]}`,{params:{fields:[Nt]}});na(Ta.data.data);const Ua=qt[X];let Ia;Ua&&(Ia=await s.get(`/items/${Tt}/${Ua}`,{params:{fields:[Ut]}}),function(e){if(console.log("[validateVessel]"),!e)throw new Error("Vessel for parcel not found");if(!e[Ut])throw new Error("No name defined for vessel of the selected parcel")}(Ia.data.data));let Ma=(await s.get(`/items/${Ft}?filter[${jt}]=${r}`,{params:{fields:["id",Vt]}})).data.data.reduce(((e,t)=>e+(t[Vt]?1:0)),0)+1,ka=r;const Fa=Ma.toString().padStart(2,"0"),ja=(qt[ee],ka.toString().padStart(2,"0")),Va={Counterparty:Ta.data.data[Nt],Vessel:Ia?Ia.data.data[Ut]:"Vessel TBA","Shipment Date":qt[Q]?S(new Date(qt[Q])):qt[Y]?S(new Date(qt[Y])):"N/A","Arrival Date":qt[H]?S(new Date(qt[H])):qt[K]?S(new Date(qt[K])):"N/A",Status:qt[Q]?"Unfinalised":"Planned",Revision:"Valuation",Invoice:`${i}:Valuation`,Parcel:`${qt[ee]} (#${ja})`,"Invoice Due Date":S(e.dueDate),"Dry Weight":`${p(la.dry_weight,4)} ${la.dry_weight_uom}`,"Total Revenues USD":p(Da),"Total Penalties USD":p(Ea+ba),...await Xt(ga,{dryWeight:la.dry_weight,dryWeightUom:la.dry_weight_uom}),"Total Adjustments USD":Sa?Pa.total_adjustments:"0.00","Parcel Value USD":p(Na),"Parcel Payable Value(Below Line) USD":p(Oa),"Payments USD":"-","Due Total":"-",metadata:{invoiceTypeRanking:Ht[i]}};return console.log(`[generateInvoice][parcel=${qt[ee]}::invoice type=${i}] generated forecast invoice=${JSON.stringify(Va)}`),Va}catch(t){if(t instanceof Qt)return void console.error(`[generateInvoice][parcel=${e.parcelId}::invoice type=${e.invoiceType}]Non-fatal error: ${t.message}`);throw t}}(e))))),n=function(e){const t=e.reduce(((e,t)=>(e[t.Parcel]||(e[t.Parcel]=[]),e[t.Parcel].push(t),e)),{});Object.keys(t).forEach((e=>{t[e].sort(((e,t)=>e.metadata.invoiceTypeRanking<t.metadata.invoiceTypeRanking?-1:e.metadata.invoiceTypeRanking>t.metadata.invoiceTypeRanking?1:0))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(t)}`),Object.keys(t).forEach((e=>{t[e].forEach(((a,o)=>{if(!a["Parcel Payable Value(Below Line) USD"]||"-"===a["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${a.Invoice} does not have a Parcel Payable Value(Below Line) USD`);const n=g(a["Parcel Payable Value(Below Line) USD"]);if(isNaN(n))throw new Error(`Parcel ${e} for invoice ${a.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${a["Parcel Payable Value(Below Line) USD"]}`);if(0===o){a["Payments USD"]=a["Payments USD"]&&"-"!==a["Payments USD"]?a["Payments USD"]:"0.00";const e=g(a["Payments USD"]);a["Due Total"]=p(n-e)}else{if(!t[e][o-1]["Parcel Payable Value(Below Line) USD"]||"-"===t[e][o-1]["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${a.Invoice} does not have a Parcel Payable Value(Below Line) USD for the previous invoice`);const r=g(t[e][o-1]["Parcel Payable Value(Below Line) USD"]);if(isNaN(r))throw new Error(`Parcel ${e} for invoice ${a.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${t[e][o-1]["Parcel Payable Value(Below Line) USD"]} for the previous invoice`);a["Due Total"]=p(n-r),a["Payments USD"]&&"-"!==a["Payments USD"]||(a["Payments USD"]=t[e][o-1]["Payments USD"])}}))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(t)}`);const a=Object.keys(t).flatMap((e=>t[e]));return console.log(`[evaluateDuePaymentsForCashflow] cashflowAsJsonWithDueTotal=${JSON.stringify(a)}`),a}(o.filter((e=>!!e))),l=n.map((e=>(delete e.metadata,e))),u=Kt(l);a("input",l),console.log(`[generateCashflow] cashflow response: ${JSON.stringify(l)}`),console.log(`[generateCashflow] cashflow as csv: ${u}`),i.value=!1,Yt(u)}catch(e){r.value=e.message}finally{i.value=!1}},downloadDoc:Yt,copy:async function(){l.value=!0;const{id:e,user_created:t,date_created:a,user_updated:o,date_updated:n,cashflow:i,forecast_price:d,...u}=c.value,m=await s.get(`/items/${xt}`,{params:{filter:{[j]:d},fields:[qt,Wt,Gt,Lt]}}),f=await s.post(`items/${xt}`,m.data.data);if(200!==f.status)return console.log(`[cashflow::copy] duplicate forecast prices response status: ${f.status}`),void(r.value=`Failed to duplicate forecast prices with status ${f.status}`);const p=f.data.data.map((e=>e.id));console.log(`[cashflow::copy] duplicated forecast prices id=${JSON.stringify(p)}`),console.log(`[cashflow::copy] requestBody=${JSON.stringify(u)}`);const y=await s.post("/items/"+R,{forecast_price:p,...u});if(200!==y.status)return console.log(`[cashflow::copy] copy response status: ${y.status}`),void(r.value=`Failed to duplicate cashflow with status ${y.status}`);l.value=!1,window.open(`/admin/content/${R}/${y.data.data.id}`)},isCopying:l,failureReason:r};function Yt(e){let t;t=f(e)?Kt(c.value.input):e,console.log(`[downloadDoc] csvData=${t}`),function(e){const t=new Blob([e],{type:"text/csv"}),a=URL.createObjectURL(t),o=document.createElement("a");o.href=a,o.download=`cashflow-${A(c.value.start_date,!1)}-${A(c.value.end_date,!1)}.csv`,document.body.appendChild(o),o.click(),document.body.removeChild(o)}(t)}async function Xt(e,t){console.log(`[mapOutCommoditiesForCashflow] commodities=${JSON.stringify(e)};;containedMetalParam=${JSON.stringify(t)}`);return(await Promise.all(e.map((async e=>{var a,o,n,r,i,l,s;const c=await F(e.payable_metal_uom,t.dryWeightUom,e.assay_uom);console.log(`[mapOutCommoditiesForCashflow] commodity=${e.commodity}, containedMetalUnitConversion=${JSON.stringify(c)}`);const d=(null!=(o=null==(a=c.initialConversion)?void 0:a.conversionFactor)?o:1)*(null!=(r=null==(n=c.finalConversion)?void 0:n.conversionFactor)?r:1),u=("%"===e.assay_uom?.01:1)*e.analytical_assay;return{[`${e.commodity} Payable Metal (${e.payable_metal_uom})`]:e.payable_metal,[`${e.commodity} Contained Metal (${e.payable_metal_uom})`]:p(t.dryWeight*u*d),[`${e.commodity} Revenue (USD)`]:e.price,[`${e.commodity} QP Month`]:zt(new Date(e.qp_start_date)),[`${e.commodity} Price (USD/${e.price_per_uom})`]:e.price_rate,[`${e.commodity} TC (USD)`]:null==(i=e.treatment_charge)?void 0:i.final_amount,[`${e.commodity} TC (USD/${null==(l=e.treatment_charge)?void 0:l.per_uom})`]:null==(s=e.treatment_charge)?void 0:s.final_rate}})))).reduce(((e,t)=>({...e,...t})),{})}function zt(e){return`${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]} ${e.getFullYear()}`}async function Zt(e,t,a,o,n,r=1){var i;if(console.log(`[getCommodityAvgPrice] commodity=${e}, commodityId=${t}, source=${a}, startDate=${o}, endDate=${n}, currency=${r}`),f(e))throw new Error(`Commodity ${e} is not defined for price calcualtion`);if(f(a))throw new Error(`Price method for commodity ${e} is not defined for price calcualtion`);if(f(o))throw new Error(`Start date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);if(f(n))throw new Error(`End date is not defined for price calcualtion with Price Method #${a} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);const l=await s.get(`/items/navarch_commodity_price?filter[_and][0][price_method][_eq]=${a}&filter[_and][0][currency][_eq]=${r}&filter[_and][1][date][_between][0]=${A(o)}&filter[_and][1][date][_between][1]=${A(n)}&sort=date`,{params:{fields:[It,Mt,kt,"price_method"]}});if((null==(i=l.data)?void 0:i.data)&&Array.isArray(l.data.data)&&l.data.data.length>0){const t=l.data.data[l.data.data.length-1],r=new Date(t[kt]);if(console.log(`[getCommodityAvgPrice] commodity prices=${JSON.stringify(l.data.data)}`),r>=n){const t=l.data.data.reduce(((t,o)=>{if(!o[Mt]&&!o[It])throw new Error(`Commodity ${e} for Price Method #${a} on the date of ${o[kt]} does not have a price, please contact Navarch for assistance`);let n;if(null!==o[Mt]&&(n=Number(o[Mt])),null===o[It])throw new Error(`The commodity price for ${e} of Price Method #${a} for the date of ${o[kt]} is not a valid number, please contact Navarch for assistance`);return n=Number(o[It]),t+n}),0)/l.data.data.length;return console.log(`[getCommodityAvgPrice] average price=${t} for commodity ${e} between ${A(o)} and ${A(n)}`),t}console.log(`[getCommodityAvgPrice] latest comm price date=${r} is before end date=${n}, getting forecast price`)}if(!c.value[j])throw new Error("Please save the Cashflow form first before generating the cashflow doc");const d=await s.get(`/items/${xt}`,{params:{filter:{[qt]:{_eq:t},cashflow_forecast_id:{_eq:c.value[j]}},fields:[Lt,qt,Wt,Gt]}});!function(e,t){if(!e||!Array.isArray(e)||0===e.length)throw new Error(`No forecast price found for ${t}, please ensure prices have been provided`)}(d.data.data,e);const u=d.data.data.find((e=>{const t=new Date(e[Wt]),a=new Date(e[Gt]);return t<=o&&a>=n}));if(!u)throw new Error(`No single forecast price found for commodity ${e} between ${A(o)} and ${A(n)}, please ensure there is only one price value for this range`);return console.log(`[getCommodityAvgPrice] forecast price=${u[Lt]} for commodity ${e} between ${A(o)} and ${A(n)}`),u[Lt]}function ea(e,t){var a,o,n;if(console.log("[validateCommodityData]"),!e)throw new Error("commodity data response is null");if(!e[ft])throw new Error(`Commodity name for commodity ${null!=(a=e[pt])?a:t} is undefined, please contact Navarch for assistance`);if(!e[pt])throw new Error(`Commodity code for commodity ${null!=(o=e[ft])?o:t} is not defined, please contact Navarch for assistance`);if(!e[j])throw new Error(`Commodity ID for commodity ${null!=(n=e[ft])?n:t} is not defined, please contact Navarch for assistance`)}function ta(e,t){if(!e)throw new Error(`Price per UOM for commodity ${t} is not a valid`);if(!e[_t])throw new Error(`Price per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function aa(e,t){if(!e)throw new Error(`Treatment charge per UOM for commodity ${t} is not a valid`);if(!e[_t])throw new Error(`Treatment charge per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function oa(e,t){if(!e)throw new Error(`Penalty per UOM for commodity ${t} is not a valid`);if(!e[_t])throw new Error(`Penalty per UOM for commodity ${t} does not have a valid unit symbol, please contact Navarch for assistance`)}function na(e){if(console.log("[validateCounterparty]"),!e)throw new Error("Counterparty for parcel not found");if(!e[Nt])throw new Error("No codename defined for counterparty of the selected parcel")}}});const w={key:0},$={key:1};var D=[],b=[];!function(e,t){if(e&&"undefined"!=typeof document){var a,o=!0===t.prepend?"prepend":"append",n=!0===t.singleTag,r="string"==typeof t.container?document.querySelector(t.container):document.getElementsByTagName("head")[0];if(n){var i=D.indexOf(r);-1===i&&(i=D.push(r)-1,b[i]={}),a=b[i]&&b[i][o]?b[i][o]:b[i][o]=l()}else a=l();65279===e.charCodeAt(0)&&(e=e.substring(1)),a.styleSheet?a.styleSheet.cssText+=e:a.appendChild(document.createTextNode(e))}function l(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),t.attributes)for(var a=Object.keys(t.attributes),n=0;n<a.length;n++)e.setAttribute(a[n],t.attributes[a[n]]);var i="prepend"===o?"afterbegin":"beforeend";return r.insertAdjacentElement(i,e),e}}(".margin-top-16px[data-v-64969d30] {\n  margin-top: 16px;\n}",{}),g.render=function(e,t,a,o,n,y){const h=r("v-button"),v=r("v-notice");return i(),l(s,null,[c(' <input :value="value" @input="handleChange($event.target.value)" /> '),c(" create a button only interface for Directus"),e.value?(i(),l("div",$,[d(h,{onClick:t[1]||(t[1]=()=>e.downloadDoc())},{default:u((()=>[m("Download Cashflow ")])),_:1})])):(i(),l("div",w,[d(h,{onClick:t[0]||(t[0]=()=>e.generateCashflow()),loading:e.isGeneraingDoc},{default:u((()=>[m("Generate Cashflow")])),_:1},8,["loading"]),e.failureReason?(i(),f(v,{key:0},{default:u((()=>[m(p(e.failureReason),1)])),_:1})):c("v-if",!0)])),d(h,{class:"margin-top-16px",onClick:t[2]||(t[2]=()=>e.copy()),loading:e.isCopying},{default:u((()=>[m("Copy")])),_:1},8,["loading"])],64)},g.__scopeId="data-v-64969d30",g.__file="src/interface.vue";var E=t({id:"navarch-docgen-cashflow",name:"Navarch Cashflow Generator Button",icon:"receipt_long",description:"This is my custom interface for Navarch's Cashflow Doc!",component:g,options:null,types:["json"],group:"standard"});export{E as default};
