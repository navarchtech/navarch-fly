import{useApi as e,defineInterface as a}from"@directus/extensions-sdk";import{defineComponent as t,ref as o,inject as n,resolveComponent as r,openBlock as i,createElementBlock as l,Fragment as s,createCommentVNode as c,createVNode as d,withCtx as u,createTextVNode as m,createBlock as f,toDisplayString as h}from"vue";import{assert as p}from"console";var y=(e=>(e.BRACKET="Brackets",e.MIN_DEDUCTION="Minimum Deduction",e.MAX_CAP="Maximum Cap",e))(y||{}),v=(e=>(e.PERCENTAGE="Percentage",e.FRACTIONAL="Fractional",e))(v||{}),_=(e=>(e.WET_WEIGHT="wet_weight",e.MOISTURE="moisture",e.DRY_WEIGHT="dry_weight",e))(_||{}),w=(e=>(e.METHOD="method",e.WET_WEIGHT_UOM="wet_weight_uom",e.MOISTURE_UOM="moisture_uom",e.DRY_WEIGHT_UOM="dry_weight_uom",e))(w||{}),g=t({props:{value:{type:Object,default:null}},emits:["input"],setup(a,{emit:t}){const r=o(""),i=o(!1),l=e(),s=n("values",o({}));function c(e){if(console.log("[evaluateWeightData]"),0===e.length)return;const a=u(e,_.DRY_WEIGHT),t=u(e,_.WET_WEIGHT);return{method:d(e,w.METHOD),lots:e,dry_weight_uom:d(e,w.DRY_WEIGHT_UOM),wet_weight_uom:d(e,w.WET_WEIGHT_UOM),dry_weight:a,wet_weight:t,moisture:(t-a)/t*100}}function d(e,a){if(console.log("[getFirstValueAsSharedValue]"),0!==e.length)return console.log(`lots[0][${a.toString()}]=${e[0][a.toString()]}`),e[0][a.toString()]}function u(e,a){return console.log("[evaluateAggregateValue]"),e.reduce(((e,t)=>{var o;return e+(null!=(o=t[a.toString()])?o:0)}),0)}function m(e){return null==e}function f(e,a=2,t=!0){if(console.log("[formatNumber]"),isNaN(e)||null===e)return"-";const o=Math.round(e*Math.pow(10,a))/Math.pow(10,a),[n,r]=o.toString().split("."),i=n.replace(/\B(?=(\d{3})+(?!\d))/g,",");if(!r&&!t)return i;return`${i}.${(null!=r?r:"").padEnd(a,"0")}`}function h(e){if(console.log("[parseNumber]"),!e)return 0;const a=parseFloat(e.replace(/,/g,""));return console.log(`[parseNumber] number: ${e} to ${a}`),a}function g(e,a,t){var o,n,r;if(console.log("[findBracket]"),1===e.length){if(a>=(null!=(o=e[0].lower_threshold)?o:0)&&(null===e[0].upper_threshold||void 0===e[0].upper_threshold||a<e[0].upper_threshold))return e[0];throw new Error(`Evaluated monetary value $${a} does not fall within the only ${t.type} bracket with range ${null!=(n=e[0].lower_threshold)?n:0} - ${null!=(r=e[0].upper_threshold)?r:"âˆž"}`)}return e.find((e=>{var t,o;const n=a>(null!=(t=e.lower_threshold)?t:0)&&(null===e.upper_threshold||void 0===e.upper_threshold||a<e.upper_threshold)||e.lower_threshold_inclusive&&a===(null!=(o=e.lower_threshold)?o:0)||e.upper_threshold_inclusive&&a===e.upper_threshold;return console.log(`[findBracket] value=${a} for bracket: ${JSON.stringify(e)}? match=${!!n}`),n}))}function $(e,a){var t,o,n,r,i,l,s;console.log("[evaluateFinalValueFromBrackets]");const c=(e-(null!=(t=a.initial_adjustment)?t:0)*(null!=(o=a.initial_adjustment_conversion_factor)?o:1))*(null!=(n=a.rate)?n:0)*(a.rate_type===v.PERCENTAGE?.01:1)+(null!=(r=a.final_adjustment)?r:0)*(null!=(i=a.final_adjustment_conversion_factor)?i:1);switch(a.bracket_type){case y.MIN_DEDUCTION:if(null===a.comparator||void 0===a.comparator)throw new Error("Minimum deduction not found");const t=a.comparator*(null!=(l=a.comparator_conversion_factor)?l:1);return e-c<t?e-t:c;case y.MAX_CAP:if(null===a.comparator||void 0===a.comparator)throw new Error("Maximum cap not found");const o=a.comparator*(null!=(s=a.comparator_conversion_factor)?s:1);return c>o?o:c;case y.BRACKET:return c;default:throw new Error(`bracket type ${a.bracket_type} is not supported`)}}async function D(e,a,t,o){var n,r,i,l,s,c,d,u;if(console.log("[evaluatePayableAssay]"),!t||0===t.length)return{};const m=g(t,e,{commodityCode:o,type:"Payable Assay"});if(!m)throw new Error(`Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for payable assays`);let h,p,_=1;m.initial_adjustment_uom&&void 0!==m.initial_adjustment_uom&&null!==m.initial_adjustment_uom&&m.initial_adjustment_uom!==a&&(_=await M(m.initial_adjustment_uom,a),h=k(m.initial_adjustment_uom,a));let w,D=1;m.bracket_type===y.MAX_CAP?(p=null!=(n=m.maximum_cap)?n:0,void 0!==m.maximum_cap_uom&&null!==m.maximum_cap_uom&&m.maximum_cap_uom!==a&&(D=await M(m.maximum_cap_uom,a),w=k(m.maximum_cap_uom,a))):m.bracket_type===y.MIN_DEDUCTION&&(p=null!=(r=m.minimum_deduction)?r:0,void 0!==m.minimum_deduction_uom&&null!==m.minimum_deduction_uom&&m.minimum_deduction_uom!==a&&(D=await M(m.minimum_deduction_uom,a),w=k(m.minimum_deduction_uom,a)));const b=$(e,{bracket_type:m.bracket_type,rate:null!=(i=m.rate)?i:1,rate_type:null!=(l=m.rate_type)?l:v.FRACTIONAL,initial_adjustment:null!=(s=m.initial_adjustment)?s:0,initial_adjustment_conversion_factor:_,comparator:p,comparator_conversion_factor:D});let E="";const P=void 0!==m.initial_adjustment&&null!==m.initial_adjustment;if(m.bracket_type===y.BRACKET)E=`${P?"(":""}${f(e,4)}${null!=a?a:""}${P?` - ${f(m.initial_adjustment,4)}${null!=(c=m.initial_adjustment_uom)?c:`${null!=a?a:""}`}`:""}${P&&1!==_?` * ${f(_,4)}${h}`:""}${P?")":""} * ${f(m.rate,4)}${m.rate_type===v.PERCENTAGE?"/100":`/${f(1,4)}`}`;else if(m.bracket_type===y.MIN_DEDUCTION){E=b===e-p*D?`${f(e,4)}${null!=a?a:""} - ${f(p,4)}${null!=a?a:""}${1!==D?` * ${f(D,4)}${w}`:""}`:`${P?"(":""}${f(e,4)}${null!=a?a:""}${P?` - ${f(m.initial_adjustment,4)}${null!=(d=m.initial_adjustment_uom)?d:`${null!=a?a:""}`}`:""}${P&&1!==_?` * ${f(_,4)}${h}`:""}${P?")":""} * ${f(m.rate,4)}${m.rate_type===v.PERCENTAGE?"/100":`/${f(1,4)}`}`}else{if(m.bracket_type!==y.MAX_CAP)throw new Error(`[buildPayableAssayExpression] unknown bracket method: ${m.bracket_type}`);E=b===p*D?`${f(p,4)}${null!=a?a:""}${1!==D?` * ${f(D,4)}${w}`:""}`:`${P?"(":""}${f(e,4)}${null!=a?a:""}${P?` - ${f(m.initial_adjustment,4)}${null!=(u=m.initial_adjustment_uom)?u:`${null!=a?a:""}`}`:""}${P&&1!==_?` * ${f(_,4)}${h}`:""}${P?")":""} * ${f(m.rate,4)}${m.rate_type===v.PERCENTAGE?"/100":`/${f(1,4)}`}`}return{payableAssay:b,expression:E}}console.log("[main] formValues=",s);const b="above the lower threshold, plus",E="below the upper threshold, minus";function P(e,a,t,o){var n,r,i,l;if(console.log("[evaluateTreatmentCharge]"),!t||!t.length)return;const s=g(t,e,{commodityCode:o,type:"Treatment Charge"});if(!s)throw new Error(`Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for treatment charge`);let c=0,d=1;if(s.use_btc)d=0,c=0;else if(d=null!=(n=s.rate)?n:1,s.for_every_unit===b)c=null!=(r=s.lower_threshold)?r:0;else{if(s.for_every_unit!==E)throw new Error(`[evaluateTreatmentCharge] unknown for_every_unit: ${s.for_every_unit}`);c=null!=(i=s.upper_threshold)?i:0}const u={bracket_type:y.BRACKET,rate:d,rate_type:v.FRACTIONAL,initial_adjustment:c,final_adjustment:null!=(l=s.base_treatment_charge)?l:0};return console.log(`[evaluateTreatmentCharge] bracketForEvaluation: ${JSON.stringify(u)}`),{finalValue:$(e,u),baseTreatmentCharge:s.base_treatment_charge}}function C(e,a,t,o,n){var r,i,l;if(console.log("[evaluatePenalty]"),!a||!a.length)return{};const s=g(a,e,{commodityCode:n,type:"Penalty"});if(!s)throw new Error(`[evaluatePenalty] Bracket not found for value ${e}, please ensure the brackets for all commodities defined in the contract cover all range of possible values for penalty`);let c=0,d=1;if(s.no_penalty)d=0,c=0;else if(d=null!=(r=s.rate)?r:1,s.for_every_unit===b)c=null!=(i=s.lower_threshold)?i:0;else{if(s.for_every_unit!==E)throw new Error(`[evaluatePenalty] unknown for_every_unit: ${s.for_every_unit}`);c=null!=(l=s.upper_threshold)?l:0}const u={bracket_type:y.BRACKET,rate:d,rate_type:v.FRACTIONAL,initial_adjustment:c,final_adjustment:0};console.log(`[evaluatePenalty] bracketForEvaluation: ${JSON.stringify(u)}`);const m=$(e,u),h=null!=u.initial_adjustment;let p="";return p=s.rate&&0!==s.rate?`${h?"(":""}${f(e,4)}${h?` - ${f(c,4)})`:""} / ${f(1,4)} * ${null!=t?t:""} ${f(d,4)}/${null!=o?o:""}`:"No penalty",{penalty:m,expression:p,bracket:s}}function S(e){const a=e.getDate(),t=e.getMonth(),o=e.getFullYear();return`${a} ${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][t]} ${o}`}function N(e,a=!0){const t=e.getMonth()+1,o=e.getDate();return`${e.getFullYear()}${a?"-":" "}${t<10?"0":""}${t}${a?"-":" "}${o<10?"0":""}${o}`}function A(e,a,t=!1){const o=new Date(e.valueOf());let n=a-(t?1:0);for(;n>0;)o.setDate(o.getDate()-1),0!==o.getDay()&&6!==o.getDay()&&(n-=1);return o.getHours()>=12&&o.setDate(o.getDate()+1),o}function O(e,a,t=!1){const o=new Date(e.valueOf());let n=a-(t?1:0);for(;n>0;)o.setDate(o.getDate()+1),0!==o.getDay()&&6!==o.getDay()&&(n-=1);return o.getHours()>=12&&o.setDate(o.getDate()+1),o}function T(e,a){const t=new Date(e.valueOf());return t.setMonth(t.getMonth()+a,1),t}function U(e,a){const t=new Date(e.valueOf());return t.setMonth(t.getMonth()+a+1,0),t}async function I(e,a){if(e===a)return 1;const t=await l.get(`/items/${ha}?filter[${pa}]=${e}`,{params:{fields:[ga]}});if(0===t.data.data.length||null===t.data.data[0][ga]||void 0===t.data.data[0][ga])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await l.get(`/items/${ha}?filter[${pa}]=${a}`,{params:{fields:[ga]}});if(0===o.data.data.length||null===o.data.data[0][ga]||void 0===o.data.data[0][ga])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for the target weight unit ${a}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(t.data.data[0][ga]);if(isNaN(n))throw new Error(`[getWeightUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);const r=parseFloat(o.data.data[0][ga]);if(isNaN(r))throw new Error(`[getWeightUnitConversionValue] target weight unit ${a} conversion value=${r} is not a number`);return n/r}async function M(e,a){if(null==e||null==a)return 1;if(e===a)return 1;const t=await l.get(`/items/${$a}?filter[${Da}]=${e}`,{params:{fields:[ba]}});if(0===t.data.data.length||void 0===t.data.data[0][ba]||null===t.data.data[0][ba])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await l.get(`/items/${$a}?filter[${Da}]=${a}`,{params:{fields:[ba]}});if(0===o.data.data.length||void 0===o.data.data[0][ba]||null===o.data.data[0][ba])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for the target weight unit ${a}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(t.data.data[0][ba]);if(isNaN(n))throw new Error(`[getAssayUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);console.log(`[getAssayUnitConversionValue] source unit conversion value=${n}`);const r=parseFloat(o.data.data[0][ba]);if(isNaN(r))throw new Error(`[getAssayUnitConversionValue] target weight unit ${e} conversion value=${r} is not a number`);return console.log(`[getAssayUnitConversionValue] target unit conversion value=${r}`),console.log("[getAssayUnitConversionValue] returning "+n/r),n/r}function k(e,a){if(void 0===e||void 0===a||null===e||null===a)return;const t=e.split("/"),o=a.split("/");if(t.length>2||o.length>2)throw new Error(`[getConversionUnit] sourceUnit=${e} and targetUnit=${a} must be in the format of 'unit1/unit2', an extra '/' was found`);if(1===t.length&&1===o.length)return`${o[0]}/${t[0]}`;if(1===t.length){const e=o[0]===t[0]?"":`${o[1]}(${t[1]})`,a=o[1];return""===a?e:`${e}/${a}`}if(1===o.length){const e=t[1],a=t[0]===o[0]?"":`${t[1]}(${o[0]})`;return""===a?e:`${e}/${a}`}{const e=t[0]===o[0],a=t[1]===o[1],n=e||""===t[0],r=e||""===o[0],i=a||""===t[1],l=a||""===o[1],s=!i&&!r,c=!n&&!l,d=`${i?"":t[1]}${s?"(":""}${r?"":`${o[0]}`}${s?")":""}`,u=`${n?"":t[0]}${c?"(":""}${l?"":`${o[1]}`}${c?")":""}`;return""===u?d:`${d}/${u}`}}async function F(e,a,t){const o=await l.get(`/items/${ha}?filter[${ya}]=${a}`,{params:{fields:[pa]}});if(!o.data.data||!o.data.data[0]||!o.data.data[0][pa])throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] Dry weight uom not found for symbol ${a}`);const n=o.data.data[0][pa];if("%"===t){if(n===e)return{};const a=k(n,e);if(!a)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and target weight unit ${e}`);return{finalConversion:{conversionFactor:await I(n,e),conversionUom:a}}}let r=t.split("/");if(1==r.length){const e=await async function(e){const a=await l.get(`/items/${$a}`,{params:{fields:[Da,Ea],filter:{[Ea]:{_nnull:!0},[Da]:{_eq:e}}}});if(200!==a.status||!a.data||0===a.data.data.length)throw new Error("[getAssayUnitComposition] no assay units found with composition");return a.data.data[0][Ea]}(t);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${t} does not have a composition`);r=e.split("/")}if(r.length>2||0===r.length)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${t} is not in the format of 'unit1/unit2'`);const i=r[0],s=r[1],c={};if(s!==n){const e=k(n,s);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and assay unit denominator unit ${s}`);c.initialConversion={conversionFactor:await I(n,s),conversionUom:e}}if(i!==e){const a=k(i,e);if(!a)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for target weight unit ${e} and assay unit numerator unit ${i}`);c.finalConversion={conversionFactor:await I(i,e),conversionUom:a}}return c}const j="id",V="foreign_key",B="lot_number",R="method",J="navarch_parcel",q="contract",x="counterparty",L="assay_results",W="weight_result",G="actual_arrival_date",H="estimate_arrival_date",K="bl_date",Q="estimated_shipment_date",Y="vessel",X="origin",z="destination",Z="shipment_code",ee="adjustments",ae="parcel_finalisation_date",te="navarch_assay_lot",oe="commodity",ne="dry_weight",re="final_assay",ie="assay_uom",le="lot_number",se="navarch_weight_lot",ce="dry_weight",de="wet_weight",ue="moisture",me="wet_weight_uom",fe="dry_weight_uom",he="navarch_contract",pe="contract_currency",ye="name",ve="navarch_contract_payment_information",_e="related_contract",we="invoice_type",ge="pay_percent",$e="pa_days",De="pa_day_type",be="pa_ref_day",Ee="pa_cashflow_days",Pe="pa_cashflow_day_type",Ce="pp_days",Se="pp_day_type",Ne="pp_ref_day",Ae="navarch_commodity_in_contract",Oe="contract",Te="commodity",Ue="primary_commodity",Ie="price_method",Me="price_per_uom",ke="treatment_charge_per_uom",Fe="quotational_periods",je="payable_assay_rates",Ve="treatment_charge_rates",Be="penalty_rates",Re="penalty_per_uom",Je="navarch_payable_assay_bracket",qe="initial_adjustment",xe="initial_adjustment_uom",Le="minimum_deduction",We="minimum_deduction_uom",Ge="maximum_cap",He="maximum_cap_uom",Ke="related_commodity_in_contract",Qe="bracket_type",Ye="lower_threshold",Xe="lower_threshold_inclusive",ze="upper_threshold",Ze="upper_threshold_inclusive",ea="rate",aa="rate_type",ta="navarch_treatment_charge_bracket",oa="base_treatment_charge",na="use_btc",ra="for_every_unit",ia="navarch_penalty_bracket",la="no_penalty",sa="for_every_unit",ca="navarch_commodity",da="name",ua="code",ma="navarch_currency",fa="code",ha="navarch_unit",pa="symbol",ya="dry_symbol",va="wet_symbol",_a="dry_unit",wa="wet_unit",ga="conversionToGram",$a="navarch_assay_unit",Da="unit",ba="conversion_to_ppb",Ea="composition",Pa="navarch_counterparty",Ca="codename",Sa="name",Na="navarch_vessel",Aa="name",Oa="price_pm",Ta="average_price",Ua="date",Ia="navarch_invoices",Ma="parcel",ka="invoice",Fa="amount_paid",ja="invoice_type",Va="commodity",Ba="price",Ra="start_date",Ja="end_date",qa={Advance:0,"Second Advance":1,"Third Advance":2,"Fourth Advance":3,Provisional:4,"Second Provisional":5,"Third Provisional":6,"Fourth Provisional":7,Final:8};class xa extends Error{constructor(e){super(e),this.name="NonFatalError",Object.setPrototypeOf(this,xa.prototype)}}return{isGeneraingDoc:i,invoiceUrl:s.value,generateCashflow:async function(){r.value="";try{i.value=!0;const e=await async function(){const e=new Date(s.value.start_date);if("Invalid Date"===e.toString())throw r.value="Start date is invalid",new Error("Start date is invalid");const a=new Date(s.value.end_date);if("Invalid Date"===a.toString())throw r.value="End date is invalid",new Error("End date is invalid");const t=await l.get(`/items/${he}`,{params:{fields:[ye,j,"invoice_type"]}}),o={};await Promise.all(t.data.data.map((async t=>{var n,r,i,s,c;const d=await l.get(`/items/${ve}`,{params:{filter:{[_e]:{_eq:t[j]}},fields:[we,$e,De,be,Ee,Pe]}}),u=await l.get(`/items/${J}`,{params:{filter:{[q]:{_eq:t[j]}},fields:[j,Z,G,H,K,Q,ae]}});for(const m of d.data.data){const d={days:"Final"===m[ja]?m[Ee]:m[$e],day_type:"Final"===m[ja]?m[Pe]:m[De],ref_day:"Final"===m[ja]?"QP Month + n days":m[be]};if(!d)throw new Error(`Contract ${t[ye]} does not have a payment advice for invoice type ${m[ja]}`);let f,h="";for(const p of u.data.data){switch(d.ref_day){case"Arrival Date":h="Actual Arrival Date from the Parcel form",f=null!=(n=p[G])?n:p[H];break;case"B/L Date":h="B/L Date (or Estimated Shipment Date) from the Parcel form",f=null!=(r=p[K])?r:p[Q];break;case"Invoice Date":h="Invoice Date (using the B/L Date or Estimated Shipment Date from the Parcel form)",f=null!=(i=p[K])?i:p[Q];break;case"Estimated Shipment Date":h="Estimated Shipment Date from the Parcel form",f=p[Q];break;case"QP Month + n days":const e=await l.get(`items/${Ae}`,{params:{filter:{[Oe]:{_eq:t[j]},payable_commodity:{_eq:!0}},fields:[Fe]}});if(!Array.isArray(e.data.data)||0===e.data.data.length)throw new Error(`Contract ${t[ye]} does not have any payable commodities`);const a=e.data.data.map((e=>e[Fe].find((e=>!!e.default)))),o=a.reduce(((e,a)=>a.qp_period>e.qp_period?a:e),a[0]);let u;switch(o.qp_code){case"MAMA":h="Actual Arrival Date (or Estimated Arrival Date) from the Parcel form",u=null!=(s=p[G])?s:p[H];break;case"MOSS":case"MOS":case"MOAS":h="B/L Date (or Estimated Shipment Date) from the Parcel form",u=null!=(c=p[K])?c:p[Q];break;default:throw new Error(`Unsupported QP code ${o.qp_code}, currently only supports MAMA, MOS, MOSS, and MOAS`)}const m=U(new Date(u),o.qp_period);if(!m||"Invalid Date"===m.toString())throw new Error(`Invalid date for last date of QP month: ${m}, please ensure all fields for QP for contract ${t[ye]} and the ${h} in parcel ${p[Z]} are filled in`);f=m.toISOString();break;default:throw new Error(`Invalid reference day for payment advice: ${d.ref_day}; please contact Navarch for support`)}if(null==f)throw new Error(`Reference day for payment advice ${h} is empty in parcel ${p[Z]}`);const u=new Date(f),y=parseInt(d.days);let v;switch(d.day_type){case"Business Day(s)":v=O(u,y,!0);break;case"Calendar Day(s)":v=new Date(u.valueOf()),v.getHours()>=12?v.setDate(v.getDate()+y+1):v.setDate(v.getDate()+y);break;default:throw new Error(`Please provide a valid Day Type (Cashflow) for ${t[ye]}:Final Invoice Type`)}v>=e&&v<=a&&(o[p[j]]||(o[p[j]]=[]),o[p[j]].push({invoiceType:m[we],dueDate:v,parcelId:p[j],contractName:t[ye]}))}}})));const n=Object.keys(o),i=await l.get(`/items/${J}`,{params:{filter:{[j]:{_in:n}},fields:[j,q,x,L,W,G,H,K,Q,Y,X,z,Z,ee,"parcel_finalised",ae,L]}});if(!i.data.data||i.data.data.length!==n.length)throw new Error("Experiencing some network issues, please try again. If the issue persists, contact Navarch for support");const c={parcelData:i.data.data.reduce(((e,a)=>(e[a[j]]=a,e)),{}),contractNameByParcelId:n.reduce(((e,a)=>(e[a]=o[a][0].contractName,e)),{}),invoiceTypeParcel:n.flatMap((e=>o[e])),parcelIds:n};return console.log(`[getApplicableParcels] returnObject=${JSON.stringify(c)}`),c}(),a=await async function(e){const a=[],t=await l.get(`/items/${Ia}`,{params:{filter:{[Ma]:{_in:e.parcelIds},[ka]:{_nnull:!0}},fields:[Ma,ja,ka,Fa]}});for(const o of e.invoiceTypeParcel){const n=t.data.data.find((e=>e[Ma]===o.parcelId&&e[ja]===o.invoiceType));n?a.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,invoiceData:{...n[ka],amount_paid:n[Fa]}}):a.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,parcelData:e.parcelData[o.parcelId]})}return console.log(`[generateInvoiceParamForParcel] invoiceParams=${JSON.stringify(a)}`),a}(e);console.log(`[generateCashflow] form values=${JSON.stringify(s.value)}`);const o=(await Promise.all(a.map((async e=>(console.log(`[generateCashflow] invoiceParam=${JSON.stringify(e)}`),await async function(e){var a,t,o,n,s,d,u,m,p,y,v,_,w,g,$,b,E,N,O,I,M,k,ae,ye,Ee,Pe,ga,$a,Da,ba,Ea,Oa,Ta,Ua,Fa,ja,Va,Ba,Ra;r.value="",i.value=!0;try{if(e.invoiceData){console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] using existing invoice=${JSON.stringify(e.invoiceData)}`);const a=e.invoiceData,t=await l.get(`/items/${Pa}`,{params:{filter:{[Sa]:{_eq:a.buyer}},fields:[Ca]}});za(t.data.data[0]);const o=await l.get(`/items/${J}`,{params:{filter:{[j]:{_eq:e.parcelId}},fields:[K,G,H]}});console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] parcel date data=${JSON.stringify(o.data.data)}`);const n=o.data.data[0];return{Counterparty:t.data.data[0][Ca],Vessel:"N/A"===a.vessel?"Vessel TBA":a.vessel,"Shipment Date":a.bl_date,"Arrival Date":n[G]?S(new Date(n[G])):n[H]?S(new Date(n[H])):"N/A",Status:o[K]?"Unfinalised":"Planned",Revision:"Original",Invoice:`${a.invoice_type}:Original`,Parcel:a.parcel,"Invoice Due Date":S(e.dueDate),"Dry Weight":a.dry_weight,"Total Revenues USD":a.total_revenue,"Total Penalties USD":a.total_deductions,...await Wa(a.commodities,{dryWeight:Number(a.dry_weight),dryWeightUom:a.dry_weight_uom}),"Total Adjustments USD":a.adjustments?a.adjustments.total_adjustments:"0.00","Parcel Value USD":a.invoice_value,"Parcel Payable Value(Below Line) USD":a.payable_amount,"Payments USD":a.amount_paid,"Due Total":a.balance_in_sellers_favor,metadata:{invoiceTypeRanking:qa[a.invoice_type]}}}if(void 0===e.parcelData)throw new xa(`Something went wrong, no parcel or invoice data for Invoice of parcel id ${e.parcelId.substring(0,5)} and invoice type ${e.invoiceType}`);const r=e.parcelId;if(!r)return void console.error(`[generateInvoice] A parcel id is not defined for invoice type ${e.invoiceType}`);const i=e.invoiceType,Ja=e.parcelData,La=e.contractName;console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] parcel data=${JSON.stringify(Ja)}`),function(e){if(!e)throw new Error("Parcel data not found, please ensure the selected parcel still exists");if(!e[Z])throw new Error("One of the parcels does not have a shipment code, please ensure that all parcels have a shipment code");if(!e[q])throw new Error(`The parcel ${e[Z]} does not have a contract, please ensure that the contract field for the parcel is not empty`);if(!e[x])throw new Error(`The parcel ${e[Z]} does not havea counterparty, please ensure that the counterparty field for the parcel is not empty`);if(!e[L])throw new xa(`The parcel ${e[Z]} does not have assay results`);if(!e[W])throw new xa(`The parcel ${e[Z]} does not have weight results`);if(!e[X])throw new Error(`The parcel ${e[Z]} does not havean origin port`);if(!e[z])throw new Error(`The parcel ${e[Z]} does not havea destination port`)}(Ja);const Ga=Ja[L],Za=Ja[W],et=Ja[q];if(!et)throw new Error(`Contract not found for parcel ${Ja[Z]}`);const at=await l.get(`/items/${ve}`,{params:{filter:{[_e]:{_eq:et},[we]:{_eq:i}},fields:[we,ge,$e,De,be,Ce,Se,Ne]}});if(at.data.data&&0===at.data.data.length)throw new Error(`No invoice type found for the contract ${La}`);const tt=at.data.data.find((e=>e[we]===i));if(!tt)throw new Error(`Cannot find payment information for ${i} in the contract ${La}, please ensure that data for it has been entered and saved`);const ot=await l.get(`/items/${se}?filter[${V}]=${Za}&sort[]=${B}`,{params:{fields:[j,ce,de,R,ue,me,fe]}});console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] weight lots data=${JSON.stringify(ot.data.data)}`),function(e){if(!e||0===e.length)throw new xa("No weight lots found for the selected parcel")}(ot.data.data);const nt=function(e){console.log("[evaluateWeights]");const a={};for(const t of e)a[t.method]||(console.log(`adding method ${t.method} to weightData object`),a[t.method]=[]),console.log(`adding lot ${t.id} to weightData.${t.method} array`),a[t.method.toString()].push(t);const t=[];for(const e of Object.keys(a)){if(!a[e]){console.log(`method=${e} does not exist in weightData object`);continue}console.log(`adding lots and other values to weights for method=${e}`);const o=c(a[e]);o&&t.push(o)}return t}(ot.data.data);let rt;if(rt||(rt=nt.find((e=>"Outturn"===e.method))),rt||(rt=nt.find((e=>"Inturn Final"===e.method))),rt||(rt=nt.find((e=>"Inturn"===e.method))),rt||(rt=nt.find((e=>"Estimated"===e.method))),rt||(rt=nt.find((e=>"Planned"===e.method))),!rt)throw new Error(`No weight lots with valid method found for parcel ${Ja[Z]}`);if(void 0===rt.dry_weight||null===rt.dry_weight||void 0===rt.wet_weight||null===rt.wet_weight||void 0===rt.moisture||null===rt.moisture||void 0===rt.dry_weight_uom||null===rt.dry_weight_uom||void 0===rt.wet_weight_uom||null===rt.wet_weight_uom||void 0===rt.method||null===rt.method)throw new Error(`One of the fields for the latest weight lots data is undefined for parcel ${Ja[Z]}`);const it=await l.get(`/items/${ha}?filter[${ya}]=${rt.dry_weight_uom}`,{params:{fields:[_a]}}),lt=await l.get(`/items/${ha}?filter[${va}]=${rt.wet_weight_uom}`,{params:{fields:[wa]}});if(!it.data.data||!it.data.data[0]||!it.data.data[0][_a])throw new Error(`Dry weight uom not found for symbol ${rt.dry_weight_uom} for parcel ${Ja[Z]}`);if(!lt.data.data||!lt.data.data[0]||!lt.data.data[0][wa])throw new Error(`Wet weight uom not found for symbol ${rt.wet_weight_uom} for parcel ${Ja[Z]}`);const st=it.data.data[0][_a],ct=(st.indexOf("dry"),lt.data.data[0][wa]),dt=(ct.indexOf("wet"),await l.get(`/items/${te}?filter[${V}]=${Ga}&sort[]=${B}`,{params:{fields:[j,oe,R,ne,re,le,ie]}}));console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] assay lots data=${JSON.stringify(dt.data.data)}`),function(e){if(!e||0===e.length)throw new xa("No assay lots found for the selected parcel")}(dt.data.data);const ut=function(e){var a;console.log("[evaluateAnalyticalAssay]");const t={};for(const a of e)t[a.method]||(t[a.method]={}),t[a.method][a.commodity]||(t[a.method][a.commodity]=[]),null!==a.lot_number?(1===t[a.method][a.commodity].length&&null===t[a.method][a.commodity][0].lot_number&&(t[a.method][a.commodity]=[]),t[a.method][a.commodity].push(a)):null===a.lot_number&&0===t[a.method][a.commodity].length&&t[a.method][a.commodity].push(a);console.log(`[evaluateAnalyticalAssay] group: ${JSON.stringify(t)}}`);const o={};for(const e in t){console.log(`[evaluateAnalyticalAssay] methodKey: ${e}, group[methodKey]: ${JSON.stringify(t[e])}`);for(const n in t[e]){console.log(`[evaluateAnalyticalAssay] commodityKey: ${n}, group[methodKey][commodityKey]: ${JSON.stringify(t[e][n])}`),o[e]=null!=(a=o[e])?a:{},o[e][n]={};const r=t[e][n].reduce(((e,a)=>e+a[ne]),0);console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${r} from ${JSON.stringify(t[e][n])}`),o[e][n].analytical_assay=t[e][n].reduce(((e,a)=>e+a[re]*a[ne]),0)/(0!==r?r:1),console.log(`[evaluateAnalyticalAssay] analytical assay: ${o[e][n].analytical_assay}`),t[e][n].length>0&&(o[e][n][ie]=t[e][n][0][ie])}}return console.log(`[evaluateAnalyticalAssay] analyticalAssay: ${JSON.stringify(o)}`),o}(dt.data.data);let mt;if(mt||(mt=ut.Outturn),mt||(mt=ut["Inturn Final"]),mt||(mt=ut.Inturn),mt||(mt=ut.Estimated),mt||(mt=ut.Planned),!mt)throw new Error(`No assay lot data with a valid method found for parcel ${Ja[Z]}`);console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] weight lots for invoice evaluation=${JSON.stringify(rt)}`),console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] assay lots for invoice evaluation=${JSON.stringify(mt)}`);const ft=await l.get(`/items/${he}/${et}`,{params:{fields:[pe]}});!function(e){if(!e)throw new Error("Contract data not found, please ensure the selected contract still exists");if(!e[pe])throw new Error("The selected contract does not have a set currency, please ensure that the currency field for the contract is not empty")}(ft.data.data);const ht=await l.get(`/items/${ma}/${ft.data.data.contract_currency}`,{params:{fields:[fa]}});!function(e){if(!e)throw new Error("Currency data not found, please ensure the selected currency still exists");if(!e[fa])throw new Error("The selected currency in the contract is not valid")}(ht.data.data);const pt=ht.data.data.code,yt=await l.get(`/items/${Ae}?filter[${Oe}]=${et}`,{params:{fields:["id",Te,Ue,Ie,Fe,je,Ve,Be,Re,Me,ke]}});!function(e){if(!e||0===e.length)throw new Error("No commodity data found in selected contract for parcel");if(!e.every((e=>e[Te])))throw new Error("The selected contract has an undefined commodity, please ensure that the 'Commodity' field for all commodites in the contract is not empty");if(!e.every((e=>e[Me])))throw new Error("The selected contract has an undefined base price Uom for commodity, please ensure that the 'Base Price Uom' field for all commodites in the contract is not empty")}(yt.data.data),console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] contract commodity data=${JSON.stringify(yt.data.data)}`);const vt=[],_t=[];let wt="";for(const{id:e,commodity:r,primary_commodity:c,price_method:h,quotational_periods:V,price_per_uom:B,penalty_per_uom:R,treatment_charge_per_uom:J}of yt.data.data){const q=await l.get(`/items/${ca}/${r}`,{params:{fields:[da,ua,j]}});if(Ka(q.data.data,r),!mt[q.data.data.code]){console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}::comm=${q.data.data[da]}] no analytical assay for commodity ${q.data.data.code} found, skipping...`);continue}if(c&&(wt=q.data.data[da]),null!==V){const r=V;console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}::comm=${q.data.data[da]}] qp=${JSON.stringify(r)}`);const c=Array.isArray(r)?r.find((e=>e.default)):null;if(!c)throw new Error(`No default quotational period found for commodity ${q.data.data.code}`);const C=r.filter((e=>!e.default)).map((e=>`${e.qp_period} ${e.qp_code}`)),R=[`${c.qp_period} ${c.qp_code}`,...C].join(", ");console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}::comm=${q.data.data[da]}] evaluate payable assay for ${q.data.data.code} with an analytical assay=${null==(a=mt[q.data.data.code])?void 0:a.analytical_assay}`);const x=await l.get(`/items/${Je}?filter[${Ke}]=${e}`,{params:{fields:[Qe,Ye,Xe,ze,Ze,ea,aa,qe,xe,Le,We,Ge,He]}}),{payableAssay:L,expression:W}=await D(null==(t=mt[q.data.data.code])?void 0:t.analytical_assay,null==(o=mt[q.data.data.code])?void 0:o.assay_uom,x.data.data,q.data.data[da]);let Y,X,z="";if("Final"!==i){const e={invoice_type:i,days:tt[Ce],day_type:tt[Se],ref_day:tt[Ne]};if(!e)throw new Error(`No provisional pricing found for invoice type ${i} for parcel ${Ja[Z]}`);let a;switch(e.ref_day){case"Arrival Date":a=null!=(n=Ja[G])?n:Ja[H],z="Actual Arrival Date from the Parcel form";break;case"B/L Date":a=null!=(s=Ja[K])?s:Ja[Q],z="B/L Date from the Parcel form";break;case"Invoice Date":a=null!=(d=Ja[K])?d:Ja[Q],z="B/L Date (or Estimated Date) as Invoice Date";break;case"Estimated Shipment Date":a=Ja[Q],z="Estimated Shipment Date from the Parcel form";break;default:throw new Error(`Invalid reference day for invoice pricing: ${e.ref_day}; please contact Navarch for support`)}if(null==a)throw new Error(`Reference day for invoice pricing ${z} is empty`);X=new Date(a);const t=parseInt(e.days),o=e.day_type;switch(o){case"Business Day(s)":Y=A(X,t,!0);break;case"Calendar Day(s)":Y=new Date(X.valueOf()),Y.setDate(Y.getDate()-t);break;default:throw new Error(`Invalid day type ${o} from contract ${La} for invoice type ${i}`)}}else{let e;switch(c.qp_code){case"MAMA":e=new Date(null!=(u=Ja[G])?u:Ja[H]),z="Actual Arrival Date";break;case"MOSS":case"MOS":case"MOAS":e=new Date(null!=(m=Ja[K])?m:Ja[Q]),z="Estimated Shipment Date";break;default:throw new Error(`Unsupported QP code ${c.qp_code} in the contract ${La}, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}if(null==e)throw new Error(`Invalid reference day for ${z} from contract ${La} for commodity ${q.data.data[da]}`);Y=T(e,c.qp_period),X=U(e,c.qp_period)}console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}::comm=${q.data.data[da]}] provisional pricing date range: ${Y.toString()} - ${X.toString()}`);const ee=await Ha(q.data.data.code,q.data.data[j],h,Y,X);let te;const oe=await l.get(`/items/${ta}?filter[${Ke}]=${e}`,{params:{fields:[Ye,Xe,ze,Ze,oa,na,ra,ea]}});void 0!==oe.data.data&&null!==oe.data.data&&oe.data.data.length>0&&(te=await P(ee,null==(p=mt[q.data.data.code])||p.assay_uom,oe.data.data,q.data.data[da]));const ne=await l.get(`/items/${ha}/${B}`,{params:{fields:[pa]}});Qa(ne.data.data,q.data.data[da]);const re=ne.data.data[pa];let ie;if(te){if(!J)throw new Error(`Treatment Charge Rate UOM is not defined for commodity ${q.data.data[da]}`);const e=await l.get(`/items/${ha}/${J}`,{params:{fields:[pa]}});Ya(e.data.data,q.data.data[da]),ie=e.data.data[pa]}const le=await F(re,rt.dry_weight_uom,null==(y=mt[q.data.data.code])?void 0:y.assay_uom);console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}::comm=${q.data.data[da]}] payableMetalConversion for commodity ${q.data.data.name}: ${JSON.stringify(le)}`),le.initialConversion=1===(null==(v=le.initialConversion)?void 0:v.conversionFactor)?void 0:le.initialConversion,le.finalConversion=1===(null==(_=le.finalConversion)?void 0:_.conversionFactor)?void 0:le.finalConversion,vt.push({commodity:q.data.data.name,analytical_assay:f(null==(w=mt[q.data.data.code])?void 0:w.analytical_assay,4),deduction_expression:W,payable_assay:f(L,4),assay_uom:null==(g=mt[q.data.data.code])?void 0:g.assay_uom,payable_metal:f(rt.dry_weight*(null!=(b=null==($=le.initialConversion)?void 0:$.conversionFactor)?b:1)*(null!=L?L:1)*(null!=(N=null==(E=le.finalConversion)?void 0:E.conversionFactor)?N:1)*("%"!==(null==(O=mt[q.data.data.code])?void 0:O.assay_uom)?1:.01),4),payable_metal_expression:`${f(rt.dry_weight,4)}${rt.dry_weight_uom}${le.initialConversion?` * ${f(le.initialConversion.conversionFactor,4)}${le.initialConversion.conversionUom}`:""} * ${f(null!=L?L:1,4)}${"%"!==(null==(I=mt[q.data.data.code])?void 0:I.assay_uom)?`${null==(M=mt[q.data.data.code])?void 0:M.assay_uom}`:" / 100"}${le.finalConversion?` * ${f(le.finalConversion.conversionFactor,4)}${le.finalConversion.conversionUom}`:""}`,payable_metal_uom:re,qp:R,qp_start_date:S(Y),qp_end_date:S(X),price_method:h,price_rate:f(ee,4),price_per_uom:re,price:f(rt.dry_weight*(null!=(ae=null==(k=le.initialConversion)?void 0:k.conversionFactor)?ae:1)*(null!=L?L:1)*(null!=(Ee=null==(ye=le.finalConversion)?void 0:ye.conversionFactor)?Ee:1)*("%"!==(null==(Pe=mt[q.data.data.code])?void 0:Pe.assay_uom)?1:.01)*ee),treatment_charge:te?{rate:f(te.baseTreatmentCharge,4),discount:f((null!=(ga=te.baseTreatmentCharge)?ga:0)-(null!=($a=te.finalValue)?$a:0),4),final_rate:f(te.finalValue,4),per_uom:ie,final_amount:f(rt.dry_weight*(null!=(Da=te.finalValue)?Da:1))}:void 0,final_total:f(rt.dry_weight*(null!=(Ea=null==(ba=le.initialConversion)?void 0:ba.conversionFactor)?Ea:1)*(null!=L?L:1)*(null!=(Ta=null==(Oa=le.finalConversion)?void 0:Oa.conversionFactor)?Ta:1)*("%"!==(null==(Ua=mt[q.data.data.code])?void 0:Ua.assay_uom)?1:.01)*ee-(te?1:0)*(rt.dry_weight*(null!=(Fa=null==te?void 0:te.finalValue)?Fa:1)))})}const x=await l.get(`/items/${ia}?filter[${Ke}]=${e}`,{params:{fields:[Ye,Xe,ze,Ze,la,sa,ea]}});if(x.data.data.length>0){if(null===R)throw new Error(`Please fill in the field for Penalty Per UOM in contract ${La} for commodity ${q.data.data[da]}`);const e=await l.get(`/items/${ha}/${R}`,{params:{fields:[pa]}});Xa(e.data.data,q.data.data[da]);const a=e.data.data[pa],{penalty:t,expression:o,bracket:n}=await C(null==(ja=mt[q.data.data.code])?void 0:ja.analytical_assay,x.data.data,pt,a,q.data.data[da]);console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}::comm=${q.data.data[da]}] evaluated penalty with an analytical assay=${null==(Va=mt[q.data.data.code])?void 0:Va.analytical_assay}, penaltyRate=${null==n?void 0:n.rate}, finalPenaltyRate=${t}, expression='${o}'`),_t.push({commodity:q.data.data.name,analytical_assay:f(null==(Ba=mt[q.data.data.code])?void 0:Ba.analytical_assay,4),deduction_expression:o,assay_uom:null==(Ra=mt[q.data.data.code])?void 0:Ra.assay_uom,penalty_rate:f(null==n?void 0:n.rate,4),penalty_per_uom:a,final_penalty_rate:f(t,4),final_penalty:f((null!=t?t:1)*rt.dry_weight)})}}console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] evaluated commodities=${JSON.stringify(vt)}`),console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] evaluated penalties${JSON.stringify(_t)}`);const gt=vt.reduce(((e,a)=>e+h(a.price)),0),$t=vt.reduce(((e,a)=>{var t;return e+h(null==(t=a.treatment_charge)?void 0:t.final_amount)}),0),Dt=_t.reduce(((e,a)=>e+h(a.final_penalty)),0);console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] TOTAL_REVENUE=${gt}, TOTAL_TREATMENT_CHARGE=${$t}, TOTAL_PENALTIES=${Dt}`);let bt,Et=0;const Pt=!!Ja[ee];Pt&&(Et=Ja[ee].reduce(((e,a)=>e+a.amount),0),bt={adjustments:Ja[ee].map((e=>({description:e.description,amount:f(e.amount)}))),total_adjustments:f(Et)});const Ct=tt[ge],St=gt-$t-Dt+Et,Nt=null!=Ct?St*Ct/100:void 0,At=await l.get(`/items/${Pa}/${Ja[x]}`,{params:{fields:[Ca]}});za(At.data.data);const Ot=Ja[Y];let Tt;Ot&&(Tt=await l.get(`/items/${Na}/${Ot}`,{params:{fields:[Aa]}}),function(e){if(console.log("[validateVessel]"),!e)throw new Error("Vessel for parcel not found");if(!e[Aa])throw new Error("No name defined for vessel of the selected parcel")}(Tt.data.data));let Ut=(await l.get(`/items/${Ia}?filter[${Ma}]=${r}`,{params:{fields:["id",ka]}})).data.data.reduce(((e,a)=>e+(a[ka]?1:0)),0)+1,It=r;const Mt=Ut.toString().padStart(2,"0"),kt=(Ja[Z],It.toString().padStart(2,"0")),Ft={Counterparty:At.data.data[Ca],Vessel:Tt?Tt.data.data[Aa]:"Vessel TBA","Shipment Date":Ja[K]?S(new Date(Ja[K])):Ja[Q]?S(new Date(Ja[Q])):"N/A","Arrival Date":Ja[G]?S(new Date(Ja[G])):Ja[H]?S(new Date(Ja[H])):"N/A",Status:Ja[K]?"Unfinalised":"Planned",Revision:"Valuation",Invoice:`${i}:Valuation`,Parcel:`${Ja[Z]} (#${kt})`,"Invoice Due Date":S(e.dueDate),"Dry Weight":`${f(rt.dry_weight,4)} ${rt.dry_weight_uom}`,"Total Revenues USD":f(gt),"Total Penalties USD":f(Dt+$t),...await Wa(vt,{dryWeight:rt.dry_weight,dryWeightUom:rt.dry_weight_uom}),"Total Adjustments USD":Pt?bt.total_adjustments:"0.00","Parcel Value USD":f(St),"Parcel Payable Value(Below Line) USD":f(Nt),"Payments USD":"-","Due Total":"-",metadata:{invoiceTypeRanking:qa[i]}};return console.log(`[generateInvoice][parcel=${Ja[Z]}::invoice type=${i}] generated forecast invoice=${JSON.stringify(Ft)}`),Ft}catch(a){if(a instanceof xa)return void console.error(`[generateInvoice][parcel=${e.parcelId}::invoice type=${e.invoiceType}]Non-fatal error: ${a.message}`);throw a}}(e)))))).filter((e=>!!e)),n=function(e){const a=e.reduce(((e,a)=>(e[a.Parcel]||(e[a.Parcel]=[]),e[a.Parcel].push(a),e)),{});Object.keys(a).forEach((e=>{a[e].sort(((e,a)=>e.metadata.invoiceTypeRanking<a.metadata.invoiceTypeRanking?-1:e.metadata.invoiceTypeRanking>a.metadata.invoiceTypeRanking?1:0))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(a)}`),Object.keys(a).forEach((e=>{a[e].forEach(((t,o)=>{if(!t["Parcel Payable Value(Below Line) USD"]||"-"===t["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${t.Invoice} does not have a Parcel Payable Value(Below Line) USD`);const n=h(t["Parcel Payable Value(Below Line) USD"]);if(isNaN(n))throw new Error(`Parcel ${e} for invoice ${t.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${t["Parcel Payable Value(Below Line) USD"]}`);if(0===o){t["Payments USD"]=t["Payments USD"]&&"-"!==t["Payments USD"]?t["Payments USD"]:"0.00";const a=h(t["Payments USD"]);p(!isNaN(a),`Parcel ${e} for invoice ${t.Invoice} has an invalid Payments USD of ${t["Payments USD"]}`),t["Due Total"]=f(n-a)}else{if(!a[e][o-1]["Parcel Payable Value(Below Line) USD"]||"-"===a[e][o-1]["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${t.Invoice} does not have a Parcel Payable Value(Below Line) USD for the previous invoice`);const r=h(a[e][o-1]["Parcel Payable Value(Below Line) USD"]);if(isNaN(r))throw new Error(`Parcel ${e} for invoice ${t.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${a[e][o-1]["Parcel Payable Value(Below Line) USD"]} for the previous invoice`);t["Due Total"]=f(n-r),t["Payments USD"]&&"-"!==t["Payments USD"]||(t["Payments USD"]=a[e][o-1]["Payments USD"])}}))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(a)}`);const t=Object.keys(a).flatMap((e=>a[e]));return console.log(`[evaluateDuePaymentsForCashflow] cashflowAsJsonWithDueTotal=${JSON.stringify(t)}`),t}(o),d=function(e){const a=[...new Set(e.flatMap((e=>Object.keys(e))))],t=e.map((e=>a.map((a=>e[a]||"")).join(",")));return[a.join(","),...t].join("\n")}(n);t("input",o),console.log(`[generateCashflow] cashflow response: ${JSON.stringify(n)}`),console.log(`[generateCashflow] cashflow as csv: ${d}`),i.value=!1,La(d)}catch(e){r.value=e.message}finally{i.value=!1}},viewDoc:La,failureReason:r};function La(e){const a=null!=e?e:s.value.input;console.log(`[viewDoc] csvData=${a}`),function(e){const a=new Blob([e],{type:"text/csv"}),t=URL.createObjectURL(a),o=document.createElement("a");o.href=t,o.download="data.csv",document.body.appendChild(o),o.click(),document.body.removeChild(o)}(a)}async function Wa(e,a){console.log(`[mapOutCommoditiesForCashflow] commodities=${JSON.stringify(e)};;containedMetalParam=${JSON.stringify(a)}`);return(await Promise.all(e.map((async e=>{var t,o,n,r,i,l,s;const c=await F(e.payable_metal_uom,a.dryWeightUom,e.assay_uom);console.log(`[mapOutCommoditiesForCashflow] commodity=${e.commodity}, containedMetalUnitConversion=${JSON.stringify(c)}`);const d=(null!=(o=null==(t=c.initialConversion)?void 0:t.conversionFactor)?o:1)*(null!=(r=null==(n=c.finalConversion)?void 0:n.conversionFactor)?r:1),u=("%"===e.assay_uom?.01:1)*e.analytical_assay;return{[`${e.commodity} Payable Metal (${e.payable_metal_uom})`]:e.payable_metal,[`${e.commodity} Contained Metal (${e.payable_metal_uom})`]:f(a.dryWeight*u*d),[`${e.commodity} Revenue (USD)`]:e.price,[`${e.commodity} QP Month`]:Ga(new Date(e.qp_start_date)),[`${e.commodity} Price (USD/${e.price_per_uom})`]:e.price_rate,[`${e.commodity} TC (USD)`]:null==(i=e.treatment_charge)?void 0:i.final_amount,[`${e.commodity} TC (USD/${null==(l=e.treatment_charge)?void 0:l.per_uom})`]:null==(s=e.treatment_charge)?void 0:s.final_rate}})))).reduce(((e,a)=>({...e,...a})),{})}function Ga(e){return`${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]} ${e.getFullYear()}`}async function Ha(e,a,t,o,n,r=1){var i;if(console.log(`[getCommodityAvgPrice] commodity=${e}, commodityId=${a}, source=${t}, startDate=${o}, endDate=${n}, currency=${r}`),m(e))throw new Error(`Commodity ${e} is not defined for price calcualtion`);if(m(t))throw new Error(`Price method for commodity ${e} is not defined for price calcualtion`);if(m(o))throw new Error(`Start date is not defined for price calcualtion with Price Method #${t} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);if(m(n))throw new Error(`End date is not defined for price calcualtion with Price Method #${t} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);const c=await l.get(`/items/navarch_commodity_price?filter[_and][0][price_method][_eq]=${t}&filter[_and][0][currency][_eq]=${r}&filter[_and][1][date][_between][0]=${N(o)}&filter[_and][1][date][_between][1]=${N(n)}&sort=date`,{params:{fields:[Oa,Ta,Ua,"price_method"]}});if((null==(i=c.data)?void 0:i.data)&&Array.isArray(c.data.data)&&c.data.data.length>0){const a=c.data.data[c.data.data.length-1];if(new Date(a[Ua])>=n){return c.data.data.reduce(((a,o)=>{if(!o[Ta]&&!o[Oa])throw new Error(`Commodity ${e} for Price Method #${t} on the date of ${o[Ua]} does not have a price, please contact Navarch for assistance`);let n=Number(o[Ta]);if(isNaN(n)&&(n=Number(o[Oa])),isNaN(n))throw new Error(`The commodity price for ${e} of Price Method #${t} for the date of ${o[Ua]} is not a valid number, please contact Navarch for assistance`);return a+n}),0)/c.data.data.length}}if(!s.value[j])throw new Error("Please save the Cashflow form first before generating the cashflow doc");const d=await l.get("/items/navarch_forecast_price",{params:{filter:{[Va]:{_eq:a},cashflow_forecast_id:{_eq:s.value[j]}},fields:[Ba,Va,Ra,Ja]}});console.log(`[getCommodityAvgPrice] forecast prices=${JSON.stringify(d.data.data)}`),function(e,a){if(!e||!Array.isArray(e)||0===e.length)throw new Error(`No forecast price found for ${a}, please ensure prices have been provided`)}(d.data.data,e);const u=d.data.data.find((e=>{const a=new Date(e[Ra]),t=new Date(e[Ja]);return a<=o&&t>=n}));if(!u)throw new Error(`No single forecast price found for commodity ${e} between ${N(o)} and ${N(n)}, please ensure there is only one price value for this range`);return u[Ba]}function Ka(e,a){var t,o,n;if(console.log("[validateCommodityData]"),!e)throw new Error("commodity data response is null");if(!e[da])throw new Error(`Commodity name for commodity ${null!=(t=e[ua])?t:a} is undefined, please contact Navarch for assistance`);if(!e[ua])throw new Error(`Commodity code for commodity ${null!=(o=e[da])?o:a} is not defined, please contact Navarch for assistance`);if(!e[j])throw new Error(`Commodity ID for commodity ${null!=(n=e[da])?n:a} is not defined, please contact Navarch for assistance`)}function Qa(e,a){if(!e)throw new Error(`Price per UOM for commodity ${a} is not a valid`);if(!e[pa])throw new Error(`Price per UOM for commodity ${a} does not have a valid unit symbol, please contact Navarch for assistance`)}function Ya(e,a){if(!e)throw new Error(`Treatment charge per UOM for commodity ${a} is not a valid`);if(!e[pa])throw new Error(`Treatment charge per UOM for commodity ${a} does not have a valid unit symbol, please contact Navarch for assistance`)}function Xa(e,a){if(!e)throw new Error(`Penalty per UOM for commodity ${a} is not a valid`);if(!e[pa])throw new Error(`Penalty per UOM for commodity ${a} does not have a valid unit symbol, please contact Navarch for assistance`)}function za(e){if(console.log("[validateCounterparty]"),!e)throw new Error("Counterparty for parcel not found");if(!e[Ca])throw new Error("No codename defined for counterparty of the selected parcel")}}});const $={key:0},D={key:1};g.render=function(e,a,t,o,n,p){const y=r("v-button"),v=r("v-notice");return i(),l(s,null,[c(' <input :value="value" @input="handleChange($event.target.value)" /> '),c(" create a button only interface for Directus"),e.value?(i(),l("div",D,[d(y,{class:"margin-top-16px",onClick:a[1]||(a[1]=()=>e.viewDoc())},{default:u((()=>[m("View Cashflow ")])),_:1})])):(i(),l("div",$,[d(y,{class:"margin-top-16px",onClick:a[0]||(a[0]=()=>e.generateCashflow()),loading:e.isGeneraingDoc},{default:u((()=>[m("Generate Cashflow")])),_:1},8,["loading"]),e.failureReason?(i(),f(v,{key:0},{default:u((()=>[m(h(e.failureReason),1)])),_:1})):c("v-if",!0)]))],2112)},g.__file="src/interface.vue";var b=a({id:"navarch-docgen-cashflow",name:"Navarch Cashflow Generator Button",icon:"receipt_long",description:"This is my custom interface for Navarch's Cashflow Doc!",component:g,options:null,types:["json"],group:"standard"});export{b as default};
