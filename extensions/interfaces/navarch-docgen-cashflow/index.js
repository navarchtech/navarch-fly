import{useApi as e,defineInterface as a}from"@directus/extensions-sdk";import{defineComponent as t,ref as o,inject as n,resolveComponent as r,openBlock as i,createElementBlock as l,Fragment as s,createCommentVNode as c,createVNode as d,withCtx as u,createTextVNode as f,createBlock as m,toDisplayString as p}from"vue";var y=(e=>(e.BRACKET="Bracket",e.MIN_DEDUCTION="Minimum Deduction",e.MAX_CAP="Maximum Cap",e))(y||{}),h=(e=>(e.PERCENTAGE="Percentage",e.FRACTIONAL="Fractional",e))(h||{}),v=(e=>(e.WET_WEIGHT="wet_weight",e.MOISTURE="moisture",e.DRY_WEIGHT="dry_weight",e))(v||{}),_=(e=>(e.METHOD="method",e.WET_WEIGHT_UOM="wet_weight_uom",e.MOISTURE_UOM="moisture_uom",e.DRY_WEIGHT_UOM="dry_weight_uom",e))(_||{}),g=t({props:{value:{type:Object,default:null}},emits:["input"],setup(a,{emit:t}){const r=o(""),i=o(!1),l=o(!1),s=e(),c=n("values",o({}));function d(e){if(console.log("[evaluateWeightData]"),0===e.length)return;const a=f(e,v.DRY_WEIGHT),t=f(e,v.WET_WEIGHT);return{method:u(e,_.METHOD),lots:e,dry_weight_uom:u(e,_.DRY_WEIGHT_UOM),wet_weight_uom:u(e,_.WET_WEIGHT_UOM),dry_weight:a,wet_weight:t,moisture:(t-a)/t*100}}function u(e,a){if(console.log("[getFirstValueAsSharedValue]"),0!==e.length)return console.log(`lots[0][${a.toString()}]=${e[0][a.toString()]}`),e[0][a.toString()]}function f(e,a){return console.log("[evaluateAggregateValue]"),e.reduce(((e,t)=>{var o;return e+parseFloat(null!=(o=t[a.toString()])?o:"0")}),0)}function m(e){return null==e}function p(e,a=2,t=!0){if(console.log("[formatNumber]"),isNaN(e)||null===e)return"-";const o=Math.round(e*Math.pow(10,a))/Math.pow(10,a),[n,r]=o.toString().split("."),i=n.replace(/\B(?=(\d{3})+(?!\d))/g,",");if(!r&&!t)return i;return`${i}.${(null!=r?r:"").padEnd(a,"0")}`}function g(e){if(console.log("[parseNumber]"),"number"==typeof e)return e;if(!e||"-"===e)return 0;const a=parseFloat(e.replace(/[^\d.-]/g,""));return console.log(`[parseNumber] number: ${e} to ${a}`),a}function w(e,a){return console.log("[findBracket]"),e.find((e=>{var t,o;const n=a>(null!=(t=e.lower_threshold)?t:0)&&(m(e.upper_threshold)||a<e.upper_threshold)||e.lower_threshold_inclusive&&a===(null!=(o=e.lower_threshold)?o:0)||e.upper_threshold_inclusive&&a===e.upper_threshold;return console.log(`[findBracket] value=${a} for bracket: ${JSON.stringify(e)}? match=${!!n}`),n}))}function $(e,a){var t,o,n,r,i,l,s;console.log("[evaluateFinalValueFromBrackets]");const c=(e-(null!=(t=a.initial_adjustment)?t:0)*(null!=(o=a.initial_adjustment_conversion_factor)?o:1))*(null!=(n=a.rate)?n:0)*(a.rate_type===h.PERCENTAGE?.01:1)+(null!=(r=a.final_adjustment)?r:0)*(null!=(i=a.final_adjustment_conversion_factor)?i:1);switch(a.bracket_type){case y.MIN_DEDUCTION:if(null===a.comparator||void 0===a.comparator)throw new Error("Minimum deduction not found");const t=a.comparator*(null!=(l=a.comparator_conversion_factor)?l:1);return e-c<t?e-t:c;case y.MAX_CAP:if(null===a.comparator||void 0===a.comparator)throw new Error("Maximum cap not found");const o=a.comparator*(null!=(s=a.comparator_conversion_factor)?s:1);return c>o?o:c;case y.BRACKET:return c;default:throw new Error(`bracket type ${a.bracket_type} is not supported`)}}async function D(e,a,t,o){var n,r,i,l,s,c,d,u;if(console.log("[evaluatePayableAssay]"),!t||0===t.length)return{};const f=w(t,e);if(!f)throw new Error(`Unable to find the range for analytical assay value of ${e}, please ensure the payable assay rates for the commodity ${o} are defined in the contract cover all range of possible values`);let m,v,_=1;f.initial_adjustment_uom&&void 0!==f.initial_adjustment_uom&&null!==f.initial_adjustment_uom&&f.initial_adjustment_uom!==a&&(_=await k(f.initial_adjustment_uom,a),m=F(f.initial_adjustment_uom,a));let g,D=1;f.bracket_type===y.MAX_CAP?(v=null!=(n=f.maximum_cap)?n:0,void 0!==f.maximum_cap_uom&&null!==f.maximum_cap_uom&&f.maximum_cap_uom!==a&&(D=await k(f.maximum_cap_uom,a),g=F(f.maximum_cap_uom,a))):f.bracket_type===y.MIN_DEDUCTION&&(v=null!=(r=f.minimum_deduction)?r:0,void 0!==f.minimum_deduction_uom&&null!==f.minimum_deduction_uom&&f.minimum_deduction_uom!==a&&(D=await k(f.minimum_deduction_uom,a),g=F(f.minimum_deduction_uom,a)));const E=$(e,{bracket_type:f.bracket_type,rate:null!=(i=f.rate)?i:1,rate_type:null!=(l=f.rate_type)?l:h.FRACTIONAL,initial_adjustment:null!=(s=f.initial_adjustment)?s:0,initial_adjustment_conversion_factor:_,comparator:v,comparator_conversion_factor:D});let b="";const P=void 0!==f.initial_adjustment&&null!==f.initial_adjustment;if(f.bracket_type===y.BRACKET)b=`${P?"(":""}${p(e,4)}${null!=a?a:""}${P?` - ${p(f.initial_adjustment,4)}${null!=(c=f.initial_adjustment_uom)?c:`${null!=a?a:""}`}`:""}${P&&1!==_?` * ${p(_,4)}${m}`:""}${P?")":""} * ${p(f.rate,4)}${f.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`;else if(f.bracket_type===y.MIN_DEDUCTION){b=E===e-v*D?`${p(e,4)}${null!=a?a:""} - ${p(v,4)}${null!=a?a:""}${1!==D?` * ${p(D,4)}${g}`:""}`:`${P?"(":""}${p(e,4)}${null!=a?a:""}${P?` - ${p(f.initial_adjustment,4)}${null!=(d=f.initial_adjustment_uom)?d:`${null!=a?a:""}`}`:""}${P&&1!==_?` * ${p(_,4)}${m}`:""}${P?")":""} * ${p(f.rate,4)}${f.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`}else{if(f.bracket_type!==y.MAX_CAP)throw new Error(`[buildPayableAssayExpression] unknown bracket method: ${f.bracket_type}`);b=E===v*D?`${p(v,4)}${null!=a?a:""}${1!==D?` * ${p(D,4)}${g}`:""}`:`${P?"(":""}${p(e,4)}${null!=a?a:""}${P?` - ${p(f.initial_adjustment,4)}${null!=(u=f.initial_adjustment_uom)?u:`${null!=a?a:""}`}`:""}${P&&1!==_?` * ${p(_,4)}${m}`:""}${P?")":""} * ${p(f.rate,4)}${f.rate_type===h.PERCENTAGE?"/100":`/${p(1,4)}`}`}return{payableAssay:E,expression:b}}console.log("[main] formValues=",c);const E="above the lower threshold, plus",b="below the upper threshold, minus";function P(e,a,t,o,n){var r,i,l,s,c;if(console.log("[evaluateCharge]"),!t||!t.length)return;const d=w(t,e);if(!d)throw new Error(`Unable to find the range for the price rate value of ${e}, please ensure the ${n} rates for commodity ${o} are defined in the contract cover all range of possible values`);let u=0,f=1;if(d.use_btc)f=0,u=0;else{const e=null!=(r=d.escalator_reference)?r:1;if(f=(null!=(i=d.rate)?i:1)/e,d.for_every_unit===E)u=null!=(l=d.lower_threshold)?l:0;else{if(d.for_every_unit!==b)throw new Error(`[evaluateCharge] unknown for_every_unit: ${d.for_every_unit}`);u=null!=(s=d.upper_threshold)?s:0}}const m={bracket_type:y.BRACKET,rate:f,rate_type:h.FRACTIONAL,initial_adjustment:u,final_adjustment:null!=(c=d.base_treatment_charge)?c:0};return console.log(`[evaluateCharge] bracketForEvaluation: ${JSON.stringify(m)}`),{finalValue:$(e,m),baseTreatmentCharge:d.base_treatment_charge}}function S(e,a,t,o,n){var r,i,l,s;if(console.log("[evaluatePenalty]"),!a||!a.length)return{};const c=w(a,e);if(!c)throw new Error(`Unable to find the range for the analytical assay value of ${e}, please ensure the penalty rates for commodity ${n} are defined in the contract cover all range of possible values`);let d=0,u=1;if(c.no_penalty)u=0,d=0;else{const e=null!=(r=c.escalator_reference)?r:1;if(u=(null!=(i=c.rate)?i:1)/e,c.for_every_unit===E)d=null!=(l=c.lower_threshold)?l:0;else{if(c.for_every_unit!==b)throw new Error(`[evaluatePenalty] unknown for_every_unit: ${c.for_every_unit}`);d=null!=(s=c.upper_threshold)?s:0}}const f={bracket_type:y.BRACKET,rate:u,rate_type:h.FRACTIONAL,initial_adjustment:d,final_adjustment:0};console.log(`[evaluatePenalty] bracketForEvaluation: ${JSON.stringify(f)}`);const m=$(e,f),v=null!=f.initial_adjustment;let _="";return _=c.rate&&0!==c.rate?`${v?"(":""}${p(e,4)}${v?` - ${p(d,4)})`:""} / ${p(1,4)} * ${null!=t?t:""} ${p(u,4)}/${null!=o?o:""}`:"No penalty",{penalty:m,expression:_,bracket:c}}function A(e){const a=e.getDate(),t=e.getMonth(),o=e.getFullYear();return`${a} ${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][t]} ${o}`}function C(e,a=!0){const t=e.getMonth()+1,o=e.getDate();return`${e.getFullYear()}${a?"-":" "}${t<10?"0":""}${t}${a?"-":" "}${o<10?"0":""}${o}`}function N(e,a,t=!1){const o=new Date(e.valueOf());let n=a-(t?1:0),r=!0;for(;O(o);)o.setDate(o.getDate()-1),r&&(n-=1,r=!1);for(;n>0;)o.setDate(o.getDate()-1),O(o)||(n-=1);for(o.getHours()>=12&&o.setDate(o.getDate()+1);O(o);)o.setDate(o.getDate()-1);return o}function O(e){return 0===e.getDay()||6===e.getDay()}function I(e,a,t=!1){const o=new Date(e.valueOf());let n=a-(t?1:0),r=!0;for(;O(o);)o.setDate(o.getDate()+1),r&&(n-=1,r=!1);for(;n>0;)o.setDate(o.getDate()+1),O(o)||(n-=1);for(o.getHours()>=12&&o.setDate(o.getDate()+1);O(o);)o.setDate(o.getDate()+1);return o}function T(e,a){const t=new Date(e.valueOf());return t.setMonth(t.getMonth()+a,1),t}function U(e,a){const t=new Date(e.valueOf());return t.setMonth(t.getMonth()+a+1,0),t}async function M(e,a){if(e===a)return 1;const t=await s.get(`/items/${Da}?filter[${Ea}]=${e}`,{params:{fields:[Ca]}});if(0===t.data.data.length||null===t.data.data[0][Ca]||void 0===t.data.data[0][Ca])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await s.get(`/items/${Da}?filter[${Ea}]=${a}`,{params:{fields:[Ca]}});if(0===o.data.data.length||null===o.data.data[0][Ca]||void 0===o.data.data[0][Ca])throw new Error(`[getWeightUnitConversionValue] failed to get conversion value for the target weight unit ${a}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(t.data.data[0][Ca]);if(isNaN(n))throw new Error(`[getWeightUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);const r=parseFloat(o.data.data[0][Ca]);if(isNaN(r))throw new Error(`[getWeightUnitConversionValue] target weight unit ${a} conversion value=${r} is not a number`);return n/r}async function k(e,a){if(null==e||null==a)return 1;if(e===a)return 1;const t=await s.get(`/items/${Na}?filter[${Oa}]=${e}`,{params:{fields:[Ia]}});if(0===t.data.data.length||void 0===t.data.data[0][Ia]||null===t.data.data[0][Ia])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for source weight unit ${e}. Ensure that the symbol is correct and is a weight unit symbol`);const o=await s.get(`/items/${Na}?filter[${Oa}]=${a}`,{params:{fields:[Ia]}});if(0===o.data.data.length||void 0===o.data.data[0][Ia]||null===o.data.data[0][Ia])throw new Error(`[getAssayUnitConversionValue] failed to get conversion value for the target weight unit ${a}. Ensure that the symbol is correct and is a weight unit symbol`);const n=parseFloat(t.data.data[0][Ia]);if(isNaN(n))throw new Error(`[getAssayUnitConversionValue] source weight unit ${e} conversion value=${n} is not a number`);console.log(`[getAssayUnitConversionValue] source unit conversion value=${n}`);const r=parseFloat(o.data.data[0][Ia]);if(isNaN(r))throw new Error(`[getAssayUnitConversionValue] target weight unit ${e} conversion value=${r} is not a number`);return console.log(`[getAssayUnitConversionValue] target unit conversion value=${r}`),console.log("[getAssayUnitConversionValue] returning "+n/r),n/r}function F(e,a){if(void 0===e||void 0===a||null===e||null===a)return;const t=e.split("/"),o=a.split("/");if(t.length>2||o.length>2)throw new Error(`[getConversionUnit] sourceUnit=${e} and targetUnit=${a} must be in the format of 'unit1/unit2', an extra '/' was found`);if(1===t.length&&1===o.length)return`${o[0]}/${t[0]}`;if(1===t.length){const e=o[0]===t[0]?"":`${o[1]}(${t[1]})`,a=o[1];return""===a?e:`${e}/${a}`}if(1===o.length){const e=t[1],a=t[0]===o[0]?"":`${t[1]}(${o[0]})`;return""===a?e:`${e}/${a}`}{const e=t[0]===o[0],a=t[1]===o[1],n=e||""===t[0],r=e||""===o[0],i=a||""===t[1],l=a||""===o[1],s=!i&&!r,c=!n&&!l,d=`${i?"":t[1]}${s?"(":""}${r?"":`${o[0]}`}${s?")":""}`,u=`${n?"":t[0]}${c?"(":""}${l?"":`${o[1]}`}${c?")":""}`;return""===u?d:`${d}/${u}`}}async function V(e,a,t){const o=await s.get(`/items/${Da}?filter[${ba}]=${a}`,{params:{fields:[Ea]}});if(!o.data.data||!o.data.data[0]||!o.data.data[0][Ea])throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] Dry weight uom not found for symbol ${a}`);const n=o.data.data[0][Ea];if("%"===t){if(n===e)return{};const a=F(n,e);if(!a)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and target weight unit ${e}`);return{finalConversion:{conversionFactor:await M(n,e),conversionUom:a}}}let r=t.split("/");if(1==r.length){const e=await async function(e){const a=await s.get(`/items/${Na}`,{params:{fields:[Oa,Ta],filter:{[Ta]:{_nnull:!0},[Oa]:{_eq:e}}}});if(200!==a.status||!a.data||0===a.data.data.length)throw new Error("[getAssayUnitComposition] no assay units found with composition");return a.data.data[0][Ta]}(t);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${t} does not have a composition`);r=e.split("/")}if(r.length>2||0===r.length)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] assay unit ${t} is not in the format of 'unit1/unit2'`);const i=r[0],l=r[1],c={};if(l!==n){const e=F(n,l);if(!e)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for dry weight unit ${n} and assay unit denominator unit ${l}`);c.initialConversion={conversionFactor:await M(n,l),conversionUom:e}}if(i!==e){const a=F(i,e);if(!a)throw new Error(`[getConversionValuesAndUnitsForPayableMetalCalculation] no conversion unit found for target weight unit ${e} and assay unit numerator unit ${i}`);c.finalConversion={conversionFactor:await M(i,e),conversionUom:a}}return c}const j="id",q="foreign_key",B="lot_number",R="method",J="navarch_cashflow",x="navarch_parcel",L="contract",W="counterparty",G="assay_results",H="weight_result",Q="actual_arrival_date",K="estimate_arrival_date",Y="bl_date",X="estimated_shipment_date",z="qp_selection",Z="vessel",ee="origin",ae="destination",te="shipment_code",oe="adjustments",ne="parcel_finalisation_date",re="navarch_assay_lot",ie="commodity",le="dry_weight",se="dry_weight_uom",ce="buyer_assay",de="seller_assay",ue="final_assay",fe="assay_uom",me="lot_number",pe="navarch_weight_lot",ye="dry_weight",he="wet_weight",ve="moisture",_e="wet_weight_uom",ge="dry_weight_uom",we="navarch_contract",$e="contract_currency",De="name",Ee="navarch_contract_payment_information",be="related_contract",Pe="invoice_type",Se="pay_percent",Ae="pa_days",Ce="pa_day_type",Ne="pa_ref_day",Oe="pp_days",Ie="pp_day_type",Te="pp_ref_day",Ue="navarch_commodity_in_contract",Me="contract",ke="commodity",Fe="primary_commodity",Ve="payable_commodity",je="price_method",qe="price_per_uom",Be="treatment_charge_per_uom",Re="quotational_periods",Je="payable_assay_rates",xe="penalty_rates",Le="penalty_per_uom",We="navarch_payable_assay_bracket",Ge="initial_adjustment",He="initial_adjustment_uom",Qe="minimum_deduction",Ke="minimum_deduction_uom",Ye="maximum_cap",Xe="maximum_cap_uom",ze="related_commodity_in_contract",Ze="bracket_type",ea="lower_threshold",aa="lower_threshold_inclusive",ta="upper_threshold",oa="upper_threshold_inclusive",na="rate",ra="rate_type",ia="navarch_treatment_charge_bracket",la="base_treatment_charge",sa="use_btc",ca="escalator_reference",da="for_every_unit",ua="related_contract_commodity_tc",fa="related_contract_commodity_rc",ma="navarch_penalty_bracket",pa="no_penalty",ya="escalator_reference",ha="for_every_unit",va="navarch_commodity",_a="name",ga="code",wa="navarch_currency",$a="code",Da="navarch_unit",Ea="symbol",ba="dry_symbol",Pa="wet_symbol",Sa="dry_unit",Aa="wet_unit",Ca="conversionToGram",Na="navarch_assay_unit",Oa="unit",Ia="conversion_to_ppb",Ta="composition",Ua="navarch_counterparty",Ma="codename",ka="name",Fa="navarch_vessel",Va="name",ja="navarch_commodity_price",qa="price_pm",Ba="average_price",Ra="date",Ja="navarch_invoices",xa="parcel",La="invoice",Wa="invoice_date",Ga="amount_paid",Ha="invoice_type",Qa="navarch_forecast_price",Ka="commodity",Ya="price",Xa="start_date",za="end_date",Za={Advance:0,"Second Advance":1,"Third Advance":2,"Fourth Advance":3,Provisional:4,"Second Provisional":5,"Third Provisional":6,"Fourth Provisional":7,Final:8};function et(e){const a=[...new Set(e.flatMap((e=>Object.keys(e))))],t=e.map((e=>a.map((a=>{const t=e[a]||"";return"string"==typeof t&&t.includes(",")?`"${t}"`:t})).join(",")));return[a.join(","),...t].join("\n")}function at(e){const a=new Blob([e],{type:"text/csv"}),t=URL.createObjectURL(a),o=document.createElement("a");o.href=t,o.download=`Cashflow-[${function(){const e=new Date,a=60*e.getTimezoneOffset()*1e3,t=e.getTime()-a,o=new Date(t),n=o.toISOString().slice(0,19),r=e.getTimezoneOffset()/60*-1;return`${n}GMT${r>0?"+":""}${r}`.replace(/:/g,"")}()}]-Valuation_Period-(${C(new Date(c.value.start_date),!1)}~${C(new Date(c.value.end_date),!1)}).csv`,document.body.appendChild(o),o.click(),document.body.removeChild(o)}class tt extends Error{constructor(e){super(e),this.name="NonFatalError",Object.setPrototypeOf(this,tt.prototype)}}return{isGeneraingDoc:i,invoiceUrl:c.value,generateCashflow:async function(){r.value="";try{i.value=!0;const e=await async function(){const e=new Date(c.value.start_date);if("Invalid Date"===e.toString())throw r.value="Start date is invalid",new Error("Start date is invalid");const a=new Date(c.value.end_date);if("Invalid Date"===a.toString())throw r.value="End date is invalid",new Error("End date is invalid");const t=await s.get(`/items/${we}`,{params:{fields:[De,j,"invoice_type"]}}),o={};await Promise.all(t.data.data.map((async t=>{var n,r,i,l,c;const d=await s.get(`/items/${Ee}`,{params:{filter:{[be]:{_eq:t[j]}},fields:[Pe,Ae,Ce,Ne]}}),u=await s.get(`/items/${x}`,{params:{filter:{[L]:{_eq:t[j]}},fields:[j,te,Q,K,Y,X,ne]}});for(const f of d.data.data){const d={days:f[Ae],day_type:f[Ce],ref_day:"Final"===f[Ha]?"QP Month + n days":f[Ne]};if(!d)throw new Error(`Contract ${t[De]} does not have a payment advice for invoice type ${f[Ha]}`);let m,p="";for(const y of u.data.data){switch(d.ref_day){case"Arrival Date":p="Actual Arrival Date from the Parcel form",m=null!=(n=y[Q])?n:y[K];break;case"B/L Date":p="B/L Date (or Estimated Shipment Date) from the Parcel form",m=null!=(r=y[Y])?r:y[X];break;case"Invoice Date":p="Invoice Date (using the B/L Date or Estimated Shipment Date from the Parcel form)",m=null!=(i=y[Y])?i:y[X];break;case"Estimated Shipment Date":p="Estimated Shipment Date from the Parcel form",m=y[X];break;case"QP Month + n days":const e=await s.get(`items/${Ue}`,{params:{filter:{[Me]:{_eq:t[j]},[Ve]:{_eq:!0}},fields:[Re]}});if(!Array.isArray(e.data.data)||0===e.data.data.length)throw new Error(`Contract ${t[De]} does not have any payable commodities`);const a=e.data.data.map((e=>e[Re].find((e=>!!e.default)))),o=a.reduce(((e,a)=>a.qp_period>e.qp_period?a:e),a[0]);let u;switch(o.qp_code){case"MAMA":p="Actual Arrival Date (or Estimated Arrival Date) from the Parcel form",u=null!=(l=y[Q])?l:y[K];break;case"MOSS":case"MOS":case"MOAS":p="B/L Date (or Estimated Shipment Date) from the Parcel form",u=null!=(c=y[Y])?c:y[X];break;default:throw new Error(`Unsupported QP code ${o.qp_code}, currently only supports MAMA, MOS, MOSS, and MOAS`)}const f=U(new Date(u),o.qp_period);if(!f||"Invalid Date"===f.toString())throw new Error(`Invalid date for last date of QP month: ${f}, please ensure all fields for QP for contract ${t[De]} and the ${p} in parcel ${y[te]} are filled in`);m=f.toISOString();break;default:throw new Error(`Invalid reference day for payment advice: ${d.ref_day}; please contact Navarch for support`)}if(null==m)throw new Error(`Reference day for payment advice ${p} is empty in parcel ${y[te]}`);const u=new Date(m),h=parseInt(d.days);let v;switch(d.day_type){case"Business Day(s)":v=I(u,h);break;case"Calendar Day(s)":v=new Date(u.valueOf()),v.getHours()>=12?v.setDate(v.getDate()+h+1):v.setDate(v.getDate()+h);break;default:throw new Error(`Please provide a valid Day Type (Cashflow) for ${t[De]}:Final Invoice Type`)}v>=e&&v<=a&&(o[y[j]]||(o[y[j]]=[]),o[y[j]].push({invoiceType:f[Pe],dueDate:v,parcelId:y[j],contractName:t[De]}))}}})));const n=Object.keys(o),i=await s.get(`/items/${x}`,{params:{filter:{[j]:{_in:n}},fields:[j,L,W,G,H,Q,K,Y,X,z,Z,ee,ae,te,oe,"parcel_finalised",ne,G]}});if(!i.data.data||i.data.data.length!==n.length)throw new Error("Experiencing some network issues, please try again. If the issue persists, contact Navarch for support");const l={parcelData:i.data.data.reduce(((e,a)=>(e[a[j]]=a,e)),{}),contractNameByParcelId:n.reduce(((e,a)=>(e[a]=o[a][0].contractName,e)),{}),invoiceTypeParcel:n.flatMap((e=>o[e])),parcelIds:n};return console.log(`[getApplicableParcels] returnObject=${JSON.stringify(l)}`),l}(),a=await async function(e){const a=[],t=await s.get(`/items/${Ja}`,{params:{filter:{[xa]:{_in:e.parcelIds},[La]:{_nnull:!0}},fields:[xa,Ha,La,Wa,Ga]}});t.data.data.sort(((e,a)=>{const t=Za[e[Ha]]-Za[a[Ha]];return 0===t?new Date(a[Wa]).valueOf()-new Date(e[Wa]).valueOf():t}));for(const o of e.invoiceTypeParcel){const n=t.data.data.find((e=>e[xa]===o.parcelId&&e[Ha]===o.invoiceType));n?a.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,invoiceData:{...n[La],amount_paid:n[Ga]}}):a.push({parcelId:o.parcelId,invoiceType:o.invoiceType,contractName:e.contractNameByParcelId[o.parcelId],dueDate:o.dueDate,parcelData:e.parcelData[o.parcelId]})}return console.log(`[generateInvoiceParamForParcel] invoiceParams=${JSON.stringify(a)}`),a}(e);console.log(`[generateCashflow] form values=${JSON.stringify(c.value)}`);const o=await Promise.all(a.map((async e=>(console.log(`[generateCashflow] invoiceParam=${JSON.stringify(e)}`),await async function(e){var a,t,o,n,l,c,u,f,m,y,h,v,_,w,$,E,b,C,N,O,I,T,U,M,k,F,J,z,ne,De,Ca,Na,Oa,Ia,Ta,ja,qa,Ba,Ra;r.value="",i.value=!0;try{if(e.invoiceData){console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] using existing invoice=${JSON.stringify(e.invoiceData)}`);const a=e.invoiceData,t=await s.get(`/items/${Ua}`,{params:{filter:{[ka]:{_eq:a.buyer}},fields:[Ma]}});pt(t.data.data[0]);const o=await s.get(`/items/${x}`,{params:{filter:{[j]:{_eq:e.parcelId}},fields:[Y,Q,K]}});console.log(`[generateInvoice][invoice=${JSON.stringify(e.invoiceData.invoice_number)}::parcel=${e.invoiceData.parcel}] parcel date data=${JSON.stringify(o.data.data)}`);const n=o.data.data[0];return{Counterparty:t.data.data[0][Ma],Vessel:"N/A"===a.vessel?"Vessel TBA":a.vessel,"Shipment Date":a.bl_date,"Arrival Date":n[Q]?A(new Date(n[Q])):n[K]?A(new Date(n[K])):"N/A",Status:o[Y]?"Unfinalised":"Planned",Revision:"Original",Invoice:`${a.invoice_type}:Original`,Parcel:a.parcel,"Invoice Due Date":A(e.dueDate),"Dry Weight":`${p(a.dry_weight,4)} ${a.dry_weight_uom}`,"Total Revenues USD":p(a.total_revenue),"Total Penalties USD":p(a.total_deductions),...await lt(a.commodities,{dryWeight:a.dry_weight,dryWeightUom:a.dry_weight_uom}),"Total Adjustments USD":a.adjustments?p(a.adjustments.total_adjustments):"0.00","Parcel Value USD":p(a.invoice_value),"Parcel Payable Value(Below Line) USD":p(a.payable_amount),"Payments USD":a.amount_paid,"Due Total":p(a.balance_in_sellers_favor),metadata:{invoiceTypeRanking:Za[a.invoice_type]}}}if(void 0===e.parcelData)throw new tt(`Something went wrong, no parcel or invoice data for Invoice of parcel id ${e.parcelId.substring(0,5)} and invoice type ${e.invoiceType}`);const i=e.parcelId;if(!i)return void console.error(`[generateInvoice] A parcel id is not defined for invoice type ${e.invoiceType}`);const Wa=e.invoiceType,Ga=e.parcelData,Ha=e.contractName;console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] parcel data=${JSON.stringify(Ga)}`),function(e){if(!e)throw new Error("Parcel data not found, please ensure the selected parcel still exists");if(!e[te])throw new Error("One of the parcels does not have a shipment code, please ensure that all parcels have a shipment code");if(!e[L])throw new Error(`The parcel ${e[te]} does not have a contract, please ensure that the contract field for the parcel is not empty`);if(!e[W])throw new Error(`The parcel ${e[te]} does not havea counterparty, please ensure that the counterparty field for the parcel is not empty`);if(!e[G])throw new tt(`The parcel ${e[te]} does not have assay results`);if(!e[H])throw new tt(`The parcel ${e[te]} does not have weight results`);if(!e[ee])throw new Error(`The parcel ${e[te]} does not havean origin port`);if(!e[ae])throw new Error(`The parcel ${e[te]} does not havea destination port`)}(Ga);const Qa=Ga[G],Ka=Ga[H],Ya=Ga[L];if(!Ya)throw new Error(`Contract not found for parcel ${Ga[te]}`);const Xa=await s.get(`/items/${Ee}`,{params:{filter:{[be]:{_eq:Ya},[Pe]:{_eq:Wa}},fields:[Pe,Se,Ae,Ce,Ne,Oe,Ie,Te]}});if(Xa.data.data&&0===Xa.data.data.length)throw new Error(`No invoice type found for the contract ${Ha}`);const za=Xa.data.data.find((e=>e[Pe]===Wa));if(!za)throw new Error(`Cannot find payment information for ${Wa} in the contract ${Ha}, please ensure that data for it has been entered and saved`);const et=await s.get(`/items/${pe}?filter[${q}]=${Ka}&sort[]=${B}`,{params:{fields:[j,ye,he,R,ve,_e,ge]}});console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] weight lots data=${JSON.stringify(et.data.data)}`),function(e){if(!e||0===e.length)throw new tt("No weight lots found for the selected parcel")}(et.data.data);const at=function(e){console.log("[evaluateWeights]");const a={};for(const t of e)a[t.method]||(console.log(`adding method ${t.method} to weightData object`),a[t.method]=[]),console.log(`adding lot ${t.id} to weightData.${t.method} array`),a[t.method.toString()].push(t);const t=[];for(const e of Object.keys(a)){if(!a[e]){console.log(`method=${e} does not exist in weightData object`);continue}console.log(`adding lots and other values to weights for method=${e}`);const o=d(a[e]);o&&t.push(o)}return t}(et.data.data);let ot;if(ot||(ot=at.find((e=>"Outturn"===e.method))),ot||(ot=at.find((e=>"Inturn Final"===e.method))),ot||(ot=at.find((e=>"Inturn"===e.method))),ot||(ot=at.find((e=>"Estimated"===e.method))),ot||(ot=at.find((e=>"Planned"===e.method))),!ot)throw new Error(`No weight lots with valid method found for parcel ${Ga[te]}`);if(void 0===ot.dry_weight||null===ot.dry_weight||void 0===ot.wet_weight||null===ot.wet_weight||void 0===ot.moisture||null===ot.moisture||void 0===ot.dry_weight_uom||null===ot.dry_weight_uom||void 0===ot.wet_weight_uom||null===ot.wet_weight_uom||void 0===ot.method||null===ot.method)throw new Error(`One of the fields for the latest weight lots data is undefined for parcel ${Ga[te]}`);const st=await s.get(`/items/${Da}?filter[${ba}]=${ot.dry_weight_uom}`,{params:{fields:[Sa]}}),yt=await s.get(`/items/${Da}?filter[${Pa}]=${ot.wet_weight_uom}`,{params:{fields:[Aa]}});if(!st.data.data||!st.data.data[0]||!st.data.data[0][Sa])throw new Error(`Dry weight uom not found for symbol ${ot.dry_weight_uom} for parcel ${Ga[te]}`);if(!yt.data.data||!yt.data.data[0]||!yt.data.data[0][Aa])throw new Error(`Wet weight uom not found for symbol ${ot.wet_weight_uom} for parcel ${Ga[te]}`);const ht=await s.get(`/items/${re}?filter[${q}]=${Qa}&sort[]=${B}`,{params:{fields:[j,ie,R,le,se,ce,de,ue,me,fe]}});console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] assay lots data=${JSON.stringify(ht.data.data)}`),function(e){if(!e||0===e.length)throw new tt("No assay lots found for the selected parcel")}(ht.data.data);const vt=function(e){var a;console.log("[evaluateAnalyticalAssay]");const t={};for(const a of e)t[a.method]||(t[a.method]={}),t[a.method][a.commodity]||(t[a.method][a.commodity]=[]),null!==a.lot_number?(1===t[a.method][a.commodity].length&&null===t[a.method][a.commodity][0].lot_number&&(t[a.method][a.commodity]=[]),t[a.method][a.commodity].push(a)):null===a.lot_number&&0===t[a.method][a.commodity].length&&t[a.method][a.commodity].push(a);console.log(`[evaluateAnalyticalAssay] group: ${JSON.stringify(t)}}`);const o={};for(const e in t){console.log(`[evaluateAnalyticalAssay] methodKey: ${e}, group[methodKey]: ${JSON.stringify(t[e])}`);for(const n in t[e]){console.log(`[evaluateAnalyticalAssay] commodityKey: ${n}, group[methodKey][commodityKey]: ${JSON.stringify(t[e][n])}`),o[e]=null!=(a=o[e])?a:{},o[e][n]={};const i=t[e][n].reduce(((e,a)=>e+parseFloat(a.dry_weight)),0);if(console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${i} from ${JSON.stringify(t[e][n])}`),0===i||isNaN(i))throw r.value=`Please provide dry weight for ${n} commodity in ${e} method, total dry weight cannot be ${i}`,new Error("[evaluateAnalyticalAssay] totalDryWeight is 0");console.log(`[evaluateAnalyticalAssay] totalDryWeight: ${i}`),o[e][n].analytical_assay=t[e][n].reduce(((a,t)=>{var o,i,l;const s=parseFloat(null!=(i=t.final_assay)?i:null!=(o=t.seller_assay)?o:t.buyer_assay);if(null==s)throw r.value=`Please provide Final, Seller or Buyer assay value for ${n} commodity in ${e} method`,new Error("[evaluateAnalyticalAssay] assay value is not defined for assay lot");const c=a+s*parseFloat(null!=(l=t.dry_weight)?l:"0");return console.log(`[evaluateAnalyticalAssay] evaluated analytical assay: ${c} for method=${e}, commodity=${n}; with values accumulator=${a}, assayValue=${s}, dryWeight=${t.dry_weight}`),c}),0)/i,console.log(`[evaluateAnalyticalAssay] analytical assay: ${o[e][n].analytical_assay}`),t[e][n].length>0&&(o[e][n][fe]=t[e][n][0][fe])}}return console.log(`[evaluateAnalyticalAssay] analyticalAssay: ${JSON.stringify(o)}`),o}(ht.data.data);let _t;if(_t||(_t=vt.Outturn),_t||(_t=vt["Inturn Final"]),_t||(_t=vt.Inturn),_t||(_t=vt.Estimated),_t||(_t=vt.Planned),!_t)throw new Error(`No assay lot data with a valid method found for parcel ${Ga[te]}`);console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] weight lots for invoice evaluation=${JSON.stringify(ot)}`),console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] assay lots for invoice evaluation=${JSON.stringify(_t)}`);const gt=await s.get(`/items/${we}/${Ya}`,{params:{fields:[$e]}});!function(e){if(!e)throw new Error("Contract data not found, please ensure the selected contract still exists");if(!e[$e])throw new Error("The selected contract does not have a set currency, please ensure that the currency field for the contract is not empty")}(gt.data.data);const wt=await s.get(`/items/${wa}/${gt.data.data.contract_currency}`,{params:{fields:[$a]}});!function(e){if(!e)throw new Error("Currency data not found, please ensure the selected currency still exists");if(!e[$a])throw new Error("The selected currency in the contract is not valid")}(wt.data.data);const $t=wt.data.data.code,Dt=await s.get(`/items/${Ue}?filter[${Me}]=${Ya}`,{params:{fields:["id",ke,Fe,Ve,je,Re,Je,xe,Le,qe,Be]}});!function(e){if(!e||0===e.length)throw new Error("No commodity data found in selected contract for parcel");if(!e.every((e=>e[ke])))throw new Error("The selected contract has an undefined commodity, please ensure that the 'Commodity' field for all commodites in the contract is not empty");if(!e.every((e=>!e[Ve]||e[qe])))throw new Error("The selected contract has an undefined base price Uom for commodity, please ensure that the 'Base Price Uom' field for all commodites in the contract is not empty")}(Dt.data.data),console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] contract commodity data=${JSON.stringify(Dt.data.data)}`);const Et=[],bt=[];let Pt="";for(const{id:e,commodity:r,primary_commodity:i,price_method:d,quotational_periods:g,price_per_uom:q,penalty_per_uom:B,treatment_charge_per_uom:R}of Dt.data.data){const x=await s.get(`/items/${va}/${r}`,{params:{fields:[_a,ga,j]}});if(dt(x.data.data,r),!_t[x.data.data.code]){console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}::comm=${x.data.data[_a]}] no analytical assay for commodity ${x.data.data.code} found, skipping...`);continue}if(i&&(Pt=x.data.data[_a]),null!==g){const r=g;console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}::comm=${x.data.data[_a]}] qp=${JSON.stringify(r)}`);const i=Array.isArray(r)?r.find((e=>e.default)):null;if(!i)throw new Error(`No default quotational period found for commodity ${x.data.data.code}`);const S=r.filter((e=>!e.default)).map((e=>`${e.qp_period} ${e.qp_code}`)),B=[`${i.qp_period} ${i.qp_code}`,...S].join(", ");console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}::comm=${x.data.data[_a]}] evaluate payable assay for ${x.data.data.code} with an analytical assay=${null==(a=_t[x.data.data.code])?void 0:a.analytical_assay}`);const L=await s.get(`/items/${We}?filter[${ze}]=${e}`,{params:{fields:[Ze,ea,aa,ta,oa,na,ra,Ge,He,Qe,Ke,Ye,Xe]}}),{payableAssay:W,expression:G}=await D(null==(t=_t[x.data.data.code])?void 0:t.analytical_assay,null==(o=_t[x.data.data.code])?void 0:o.assay_uom,L.data.data,x.data.data[_a]);let H,Q;if("Final"!==Wa){const e=await nt(x.data.data.code,Ga,d,(async()=>rt(za,Ga,Wa,Ha)));if(null===e)throw new Error(`[generateInvoice] Provisional pricing dates not found for commodity ${x.data.data.code}`);if(null===e.provisionalPricingStartDate||!(e.provisionalPricingStartDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing start date for commodity ${x.data.data.code} of invoice type ${Wa}`);if(H=e.provisionalPricingStartDate,null===e.provisionalPricingEndDate||!(e.provisionalPricingEndDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing end date for commodity ${x.data.data.code} of invoice type ${Wa}`);Q=e.provisionalPricingEndDate}else{const e=await nt(x.data.data.code,Ga,d,(async()=>it(i,Ga,Ha,x.data.data[_a])),!0);if(null===e)throw new Error(`[generateInvoice] Provisional pricing dates not found for commodity ${x.data.data.code}`);if(null===e.provisionalPricingStartDate||!(e.provisionalPricingStartDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing start date for commodity ${x.data.data.code} of invoice type ${Wa}`);if(H=e.provisionalPricingStartDate,null===e.provisionalPricingEndDate||!(e.provisionalPricingEndDate instanceof Date))throw new Error(`[generateInvoice] Invalid provisional pricing end date for commodity ${x.data.data.code} of invoice type ${Wa}`);Q=e.provisionalPricingEndDate}console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}::comm=${x.data.data[_a]}] provisional pricing date range: ${H.toString()} - ${Q.toString()}`);const K=await ct(x.data.data.code,x.data.data[j],d,H,Q);let Y;const X=await s.get(`/items/${ia}?filter[${ua}]=${e}`,{params:{fields:[ea,aa,ta,oa,la,sa,ca,da,na]}});let Z,ee;if(void 0!==X.data.data&&null!==X.data.data&&X.data.data.length>0&&(Y=await P(K,null==(n=_t[x.data.data.code])||n.assay_uom,X.data.data,x.data.data[_a],"treatment charge")),Y){if(!R)throw new Error(`Charge Rate UOM is not defined for commodity ${x.data.data[_a]}`);const e=await s.get(`/items/${Da}/${R}`,{params:{fields:[Ea]}});ft(e.data.data,x.data.data[_a]),Z=e.data.data[Ea]}const ae=await s.get(`/items/${ia}?filter[${fa}]=${e}`,{params:{fields:[ea,aa,ta,oa,la,sa,ca,da,na]}});if(void 0!==ae.data.data&&null!==ae.data.data&&ae.data.data.length>0&&(ee=await P(K,null==(l=_t[x.data.data.code])||l.assay_uom,ae.data.data,x.data.data[_a],"refining charge")),ee){if(!R)throw new Error(`Charge Rate UOM is not defined for commodity ${x.data.data[_a]}`);const e=await s.get(`/items/${Da}/${R}`,{params:{fields:[Ea]}});ft(e.data.data,x.data.data[_a]),Z=e.data.data[Ea]}const oe=await s.get(`/items/${Da}/${q}`,{params:{fields:[Ea]}});ut(oe.data.data,x.data.data[_a]);const re=oe.data.data[Ea],ie=await V(re,ot.dry_weight_uom,null==(c=_t[x.data.data.code])?void 0:c.assay_uom);console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}::comm=${x.data.data[_a]}] payableMetalConversion for commodity ${x.data.data.name}: ${JSON.stringify(ie)}`),ie.initialConversion=1===(null==(u=ie.initialConversion)?void 0:u.conversionFactor)?void 0:ie.initialConversion,ie.finalConversion=1===(null==(f=ie.finalConversion)?void 0:f.conversionFactor)?void 0:ie.finalConversion,Et.push({commodity:x.data.data.name,analytical_assay:p(null==(m=_t[x.data.data.code])?void 0:m.analytical_assay,4),deduction_expression:G,payable_assay:p(W,4),assay_uom:null==(y=_t[x.data.data.code])?void 0:y.assay_uom,payable_metal:p(ot.dry_weight*(null!=(v=null==(h=ie.initialConversion)?void 0:h.conversionFactor)?v:1)*(null!=W?W:1)*(null!=(w=null==(_=ie.finalConversion)?void 0:_.conversionFactor)?w:1)*("%"!==(null==($=_t[x.data.data.code])?void 0:$.assay_uom)?1:.01),4),payable_metal_expression:`${p(ot.dry_weight,4)}${ot.dry_weight_uom}${ie.initialConversion?` * ${p(ie.initialConversion.conversionFactor,4)}${ie.initialConversion.conversionUom}`:""} * ${p(null!=W?W:1,4)}${"%"!==(null==(E=_t[x.data.data.code])?void 0:E.assay_uom)?`${null==(b=_t[x.data.data.code])?void 0:b.assay_uom}`:" / 100"}${ie.finalConversion?` * ${p(ie.finalConversion.conversionFactor,4)}${ie.finalConversion.conversionUom}`:""}`,payable_metal_uom:re,qp:B,qp_start_date:A(H),qp_end_date:A(Q),price_method:d,price_rate:p(K,4),price_per_uom:re,price:p(ot.dry_weight*(null!=(N=null==(C=ie.initialConversion)?void 0:C.conversionFactor)?N:1)*(null!=W?W:1)*(null!=(I=null==(O=ie.finalConversion)?void 0:O.conversionFactor)?I:1)*("%"!==(null==(T=_t[x.data.data.code])?void 0:T.assay_uom)?1:.01)*K),treatment_charge:Y?{rate:p(Y.baseTreatmentCharge,4),discount:p((null!=(U=Y.baseTreatmentCharge)?U:0)-(null!=(M=Y.finalValue)?M:0),4),final_rate:p(Y.finalValue,4),per_uom:Z,final_amount:p(ot.dry_weight*(null!=(k=Y.finalValue)?k:1))}:void 0,refining_charge:ee?{rate:p(ee.baseTreatmentCharge,4),discount:p((null!=(F=ee.baseTreatmentCharge)?F:0)-(null!=(J=ee.finalValue)?J:0),4),final_rate:p(ee.finalValue,4),per_uom:Z,final_amount:p(ot.dry_weight*(null!=(z=ee.finalValue)?z:1))}:void 0,final_total:p(ot.dry_weight*(null!=(De=null==(ne=ie.initialConversion)?void 0:ne.conversionFactor)?De:1)*(null!=W?W:1)*(null!=(Na=null==(Ca=ie.finalConversion)?void 0:Ca.conversionFactor)?Na:1)*("%"!==(null==(Oa=_t[x.data.data.code])?void 0:Oa.assay_uom)?1:.01)*K-(Y?1:0)*(ot.dry_weight*(null!=(Ia=null==Y?void 0:Y.finalValue)?Ia:1))-(ee?1:0)*(ot.dry_weight*(null!=(Ta=null==ee?void 0:ee.finalValue)?Ta:1)))})}const L=await s.get(`/items/${ma}?filter[${ze}]=${e}`,{params:{fields:[ea,aa,ta,oa,pa,ya,ha,na]}});if(L.data.data.length>0){if(null===B)throw new Error(`Please fill in the field for Penalty Per UOM in contract ${Ha} for commodity ${x.data.data[_a]}`);const e=await s.get(`/items/${Da}/${B}`,{params:{fields:[Ea]}});mt(e.data.data,x.data.data[_a]);const a=e.data.data[Ea],{penalty:t,expression:o,bracket:n}=await S(null==(ja=_t[x.data.data.code])?void 0:ja.analytical_assay,L.data.data,$t,a,x.data.data[_a]);console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}::comm=${x.data.data[_a]}] evaluated penalty with an analytical assay=${null==(qa=_t[x.data.data.code])?void 0:qa.analytical_assay}, penaltyRate=${null==n?void 0:n.rate}, finalPenaltyRate=${t}, expression='${o}'`),bt.push({commodity:x.data.data.name,analytical_assay:p(null==(Ba=_t[x.data.data.code])?void 0:Ba.analytical_assay,4),deduction_expression:o,assay_uom:null==(Ra=_t[x.data.data.code])?void 0:Ra.assay_uom,penalty_rate:p(null==n?void 0:n.rate,4),penalty_per_uom:a,final_penalty_rate:p(t,4),final_penalty:p((null!=t?t:1)*ot.dry_weight)})}}console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] evaluated commodities=${JSON.stringify(Et)}`),console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] evaluated penalties${JSON.stringify(bt)}`);const St=Et.reduce(((e,a)=>e+g(a.price)),0),At=Et.reduce(((e,a)=>{var t;return e+g(null==(t=a.treatment_charge)?void 0:t.final_amount)}),0),Ct=Et.reduce(((e,a)=>{var t;return e+g(null==(t=a.refining_charge)?void 0:t.final_amount)}),0),Nt=bt.reduce(((e,a)=>e+g(a.final_penalty)),0);console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] TOTAL_REVENUE=${St}, TOTAL_TREATMENT_CHARGE=${At}, TOTAL_REFINING_CHARGE=${Ct}, TOTAL_PENALTIES=${Nt}`);let Ot,It=0;const Tt=!!Ga[oe];Tt&&(It=Ga[oe].reduce(((e,a)=>e+a.amount),0),Ot={adjustments:Ga[oe].map((e=>({description:e.description,amount:p(e.amount)}))),total_adjustments:p(It)});const Ut=za[Se],Mt=St-At-Ct-Nt+It,kt=null!=Ut?Mt*Ut/100:void 0,Ft=await s.get(`/items/${Ua}/${Ga[W]}`,{params:{fields:[Ma]}});pt(Ft.data.data);const Vt=Ga[Z];let jt;Vt&&(jt=await s.get(`/items/${Fa}/${Vt}`,{params:{fields:[Va]}}),function(e){if(console.log("[validateVessel]"),!e)throw new Error("Vessel for parcel not found");if(!e[Va])throw new Error("No name defined for vessel of the selected parcel")}(jt.data.data));let qt=(await s.get(`/items/${Ja}?filter[${xa}]=${i}`,{params:{fields:["id",La]}})).data.data.reduce(((e,a)=>e+(a[La]?1:0)),0)+1,Bt=i;const Rt=qt.toString().padStart(2,"0"),Jt=(Ga[te],Bt.toString().padStart(2,"0")),xt={Counterparty:Ft.data.data[Ma],Vessel:jt?jt.data.data[Va]:"Vessel TBA","Shipment Date":Ga[Y]?A(new Date(Ga[Y])):Ga[X]?A(new Date(Ga[X])):"N/A","Arrival Date":Ga[Q]?A(new Date(Ga[Q])):Ga[K]?A(new Date(Ga[K])):"N/A",Status:Ga[Y]?"Unfinalised":"Planned",Revision:"Valuation",Invoice:`${Wa}:Valuation`,Parcel:`${Ga[te]} (#${Jt})`,"Invoice Due Date":A(e.dueDate),"Dry Weight":`${p(ot.dry_weight,4)} ${ot.dry_weight_uom}`,"Total Revenues USD":p(St),"Total Penalties USD":p(Nt+At+Ct),...await lt(Et,{dryWeight:ot.dry_weight,dryWeightUom:ot.dry_weight_uom}),"Total Adjustments USD":Tt?Ot.total_adjustments:"0.00","Parcel Value USD":p(Mt),"Parcel Payable Value(Below Line) USD":p(kt),"Payments USD":"-","Due Total":"-",metadata:{invoiceTypeRanking:Za[Wa]}};return console.log(`[generateInvoice][parcel=${Ga[te]}::invoice type=${Wa}] generated forecast invoice=${JSON.stringify(xt)}`),xt}catch(a){if(a instanceof tt)return void console.error(`[generateInvoice][parcel=${e.parcelId}::invoice type=${e.invoiceType}]Non-fatal error: ${a.message}`);throw a}}(e))))),n=function(e){const a=e.reduce(((e,a)=>(e[a.Parcel]||(e[a.Parcel]=[]),e[a.Parcel].push(a),e)),{});Object.keys(a).forEach((e=>{a[e].sort(((e,a)=>e.metadata.invoiceTypeRanking<a.metadata.invoiceTypeRanking?-1:e.metadata.invoiceTypeRanking>a.metadata.invoiceTypeRanking?1:0))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(a)}`),Object.keys(a).forEach((e=>{a[e].forEach(((t,o)=>{if(!t["Parcel Payable Value(Below Line) USD"]||"-"===t["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${t.Invoice} does not have a Parcel Payable Value(Below Line) USD`);const n=g(t["Parcel Payable Value(Below Line) USD"]);if(isNaN(n))throw new Error(`Parcel ${e} for invoice ${t.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${t["Parcel Payable Value(Below Line) USD"]}`);if(0===o){t["Payments USD"]=t["Payments USD"]&&"-"!==t["Payments USD"]?t["Payments USD"]:"0.00";const e=g(t["Payments USD"]);t["Due Total"]=p(n-e)}else{if(!a[e][o-1]["Parcel Payable Value(Below Line) USD"]||"-"===a[e][o-1]["Parcel Payable Value(Below Line) USD"])throw new Error(`Parcel ${e} for invoice ${t.Invoice} does not have a Parcel Payable Value(Below Line) USD for the previous invoice`);const r=g(a[e][o-1]["Parcel Payable Value(Below Line) USD"]);if(isNaN(r))throw new Error(`Parcel ${e} for invoice ${t.Invoice} has an invalid Parcel Payable Value(Below Line) USD of ${a[e][o-1]["Parcel Payable Value(Below Line) USD"]} for the previous invoice`);t["Due Total"]=p(n-r),t["Payments USD"]&&"-"!==t["Payments USD"]||(t["Payments USD"]=a[e][o-1]["Payments USD"])}}))})),console.log(`[evaluateDuePaymentsForCashflow] cashflowByParcel=${JSON.stringify(a)}`);const t=Object.keys(a).flatMap((e=>a[e]));return console.log(`[evaluateDuePaymentsForCashflow] cashflowAsJsonWithDueTotal=${JSON.stringify(t)}`),t}(o.filter((e=>!!e))),l=n.map((e=>(delete e.metadata,e))),u=et(l);t("input",l),console.log(`[generateCashflow] cashflow response: ${JSON.stringify(l)}`),console.log(`[generateCashflow] cashflow as csv: ${u}`),i.value=!1,ot(u)}catch(e){r.value=e.message}finally{i.value=!1}},downloadDoc:ot,copy:async function(){l.value=!0;const{id:e,user_created:a,date_created:t,user_updated:o,date_updated:n,cashflow:i,forecast_price:d,...u}=c.value,f=await s.get(`/items/${Qa}`,{params:{filter:{[j]:d},fields:[Ka,Xa,za,Ya]}}),m=await s.post(`items/${Qa}`,f.data.data);if(200!==m.status)return console.log(`[cashflow::copy] duplicate forecast prices response status: ${m.status}`),void(r.value=`Failed to duplicate forecast prices with status ${m.status}`);const p=m.data.data.map((e=>e.id));console.log(`[cashflow::copy] duplicated forecast prices id=${JSON.stringify(p)}`),console.log(`[cashflow::copy] requestBody=${JSON.stringify(u)}`);const y=await s.post("/items/"+J,{forecast_price:p,...u});if(200!==y.status)return console.log(`[cashflow::copy] copy response status: ${y.status}`),void(r.value=`Failed to duplicate cashflow with status ${y.status}`);l.value=!1,window.open(`/admin/content/${J}/${y.data.data.id}`)},isCopying:l,failureReason:r};function ot(e){let a;a=m(e)?et(c.value.cashflow):e,console.log(`[downloadDoc] csvData=${a}`),at(a)}async function nt(e,a,t,o,n=!1){if(m(a[z])||m(a[z][e]))return await o();const r=await async function(e,a,t,o){if(o&&!e.declared)return null;const n=null==e?void 0:e.qp_selected;if(!n)return null;const r=n.split(" "),i={qp_period:parseInt(r[0]),qp_code:r[1]};let l,c,d,u;switch(i.qp_code){case"MAMA":l=Q,c="Actual Arrival Date";break;case"MOSS":l=X,c="Estimated Shipment Date";break;case"MOS":case"MOAS":l=Y,c="B/L Date";break;default:throw new Error(`Unsupported QP code ${i.qp_code} in the contract commodities, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}const f=new Date(a[l]);if(null==f)throw new Error(`[generateInvoice] Invalid reference day for ${c} from ${i.qp_code}`);if(d=T(f,i.qp_period),d.valueOf()>Date.now())return null;if(u=U(f,i.qp_period),u.valueOf()>Date.now())return null;if(u.valueOf()<=Date.now()){const e=await s.get(`/items/${ja}`,{params:{filter:{_and:[{date:{_eq:C(u)}},{price_method:{_eq:t}}]},fields:[qa,Ba]}});if(!e.data.data||0===e.data.data.length)return null}return{provisionalPricingStartDate:d,provisionalPricingEndDate:u}}(a[z][e],a,t,n);return r||await o()}async function rt(e,a,t,o){var n,r,i;let l,s,c;const d={invoice_type:t,days:e[Oe],day_type:e[Ie],ref_day:e[Te]};if(!d)throw new Error(`No provisional pricing found for invoice type ${t} for parcel ${a[te]}`);let u;switch(d.ref_day){case"Arrival Date":u=null!=(n=a[Q])?n:a[K],l="Actual Arrival Date from the Parcel form";break;case"B/L Date":u=null!=(r=a[Y])?r:a[X],l="B/L Date from the Parcel form";break;case"Invoice Date":u=null!=(i=a[Y])?i:a[X],l="B/L Date (or Estimated Date) as Invoice Date";break;case"Estimated Shipment Date":u=a[X],l="Estimated Shipment Date from the Parcel form";break;default:throw new Error(`Invalid reference day for invoice pricing: ${d.ref_day}; please contact Navarch for support`)}if(null==u)throw new Error(`Reference day for invoice pricing ${l} is empty`);c=new Date(u);const f=parseInt(d.days),m=d.day_type;switch(m){case"Business Day(s)":s=N(c,f),(0===c.getDay()||6===c.getDay())&&(c=N(c,1,!0));break;case"Calendar Day(s)":s=new Date(c.valueOf()),s.setDate(s.getDate()-f);break;default:throw new Error(`Invalid day type ${m} from contract ${o} for invoice type ${t}`)}return{provisionalPricingStartDate:s,provisionalPricingEndDate:c}}async function it(e,a,t,o){var n,r;let i,l,s,c;switch(e.qp_code){case"MAMA":c=new Date(null!=(n=a[Q])?n:a[K]),i="Actual Arrival Date";break;case"MOSS":case"MOS":case"MOAS":c=new Date(null!=(r=a[Y])?r:a[X]),i="Estimated Shipment Date";break;default:throw new Error(`Unsupported QP code ${e.qp_code} in the contract ${t}, please ensure all commodity QP codes are MAMA, MOS, MOSS, or MOAS`)}if(null==c)throw new Error(`Invalid reference day for ${i} from contract ${t} for commodity ${o}`);return l=T(c,e.qp_period),s=U(c,e.qp_period),{provisionalPricingStartDate:l,provisionalPricingEndDate:s}}async function lt(e,a){console.log(`[mapOutCommoditiesForCashflow] commodities=${JSON.stringify(e)};;containedMetalParam=${JSON.stringify(a)}`);return(await Promise.all(e.map((async e=>{var t,o,n,r,i,l,s;const c=await V(e.payable_metal_uom,a.dryWeightUom,e.assay_uom);console.log(`[mapOutCommoditiesForCashflow] commodity=${e.commodity}, containedMetalUnitConversion=${JSON.stringify(c)}`);const d=(null!=(o=null==(t=c.initialConversion)?void 0:t.conversionFactor)?o:1)*(null!=(r=null==(n=c.finalConversion)?void 0:n.conversionFactor)?r:1),u=("%"===e.assay_uom?.01:1)*e.analytical_assay;return{[`${e.commodity} Payable Metal (${e.payable_metal_uom})`]:e.payable_metal,[`${e.commodity} Contained Metal (${e.payable_metal_uom})`]:p(a.dryWeight*u*d),[`${e.commodity} Revenue (USD)`]:e.price,[`${e.commodity} QP Month`]:st(new Date(e.qp_start_date)),[`${e.commodity} Price (USD/${e.price_per_uom})`]:e.price_rate,[`${e.commodity} TC (USD)`]:null==(i=e.treatment_charge)?void 0:i.final_amount,[`${e.commodity} TC (USD/${null==(l=e.treatment_charge)?void 0:l.per_uom})`]:null==(s=e.treatment_charge)?void 0:s.final_rate}})))).reduce(((e,a)=>({...e,...a})),{})}function st(e){return`${["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]} ${e.getFullYear()}`}async function ct(e,a,t,o,n,r=1){var i;if(console.log(`[getCommodityAvgPrice] commodity=${e}, commodityId=${a}, source=${t}, startDate=${o}, endDate=${n}, currency=${r}`),m(e))throw new Error(`Commodity ${e} is not defined for price calcualtion`);if(m(t))throw new Error(`Price method for commodity ${e} is not defined for price calcualtion`);if(m(o))throw new Error(`Start date is not defined for price calcualtion with Price Method #${t} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);if(m(n))throw new Error(`End date is not defined for price calcualtion with Price Method #${t} has not been properly defined, please ensure that contract QP for commodity ${e} is properly defined`);const l=await s.get(`/items/${ja}?filter[_and][0][price_method][_eq]=${t}&filter[_and][0][currency][_eq]=${r}&filter[_and][1][date][_between][0]=${C(o)}&filter[_and][1][date][_between][1]=${C(n)}&sort=date`,{params:{fields:[qa,Ba,Ra,"price_method"]}});if((null==(i=l.data)?void 0:i.data)&&Array.isArray(l.data.data)&&l.data.data.length>0){const a=l.data.data[l.data.data.length-1],r=new Date(a[Ra]);if(console.log(`[getCommodityAvgPrice] commodity prices=${JSON.stringify(l.data.data)}`),r>=n){const a=l.data.data.reduce(((a,o)=>{if(!o[Ba]&&!o[qa])throw new Error(`Commodity ${e} for Price Method #${t} on the date of ${o[Ra]} does not have a price, please contact Navarch for assistance`);let n;if(null!==o[Ba]&&(n=Number(o[Ba])),null===o[qa])throw new Error(`The commodity price for ${e} of Price Method #${t} for the date of ${o[Ra]} is not a valid number, please contact Navarch for assistance`);return n=Number(o[qa]),a+n}),0)/l.data.data.length;return console.log(`[getCommodityAvgPrice] average price=${a} for commodity ${e} between ${C(o)} and ${C(n)}`),a}console.log(`[getCommodityAvgPrice] latest comm price date=${r} is before end date=${n}, getting forecast price`)}if(!c.value[j])throw new Error("Please save the Cashflow form first before generating the cashflow doc");const d=await s.get(`/items/${Qa}`,{params:{filter:{[Ka]:{_eq:a},cashflow_forecast_id:{_eq:c.value[j]}},fields:[Ya,Ka,Xa,za]}});!function(e,a){if(!e||!Array.isArray(e)||0===e.length)throw new Error(`No forecast price found for ${a}, please ensure prices have been provided`)}(d.data.data,e);const u=d.data.data.find((e=>{const a=new Date(e[Xa]),t=new Date(e[za]);return a<=o&&t>=n}));if(!u)throw new Error(`No single forecast price found for commodity ${e} between ${C(o)} and ${C(n)}, please ensure there is only one price value for this range`);return console.log(`[getCommodityAvgPrice] forecast price=${u[Ya]} for commodity ${e} between ${C(o)} and ${C(n)}`),u[Ya]}function dt(e,a){var t,o,n;if(console.log("[validateCommodityData]"),!e)throw new Error("commodity data response is null");if(!e[_a])throw new Error(`Commodity name for commodity ${null!=(t=e[ga])?t:a} is undefined, please contact Navarch for assistance`);if(!e[ga])throw new Error(`Commodity code for commodity ${null!=(o=e[_a])?o:a} is not defined, please contact Navarch for assistance`);if(!e[j])throw new Error(`Commodity ID for commodity ${null!=(n=e[_a])?n:a} is not defined, please contact Navarch for assistance`)}function ut(e,a){if(!e)throw new Error(`Price per UOM for commodity ${a} is not a valid`);if(!e[Ea])throw new Error(`Price per UOM for commodity ${a} does not have a valid unit symbol, please contact Navarch for assistance`)}function ft(e,a){if(!e)throw new Error(`Charge per UOM for commodity ${a} is not a valid`);if(!e[Ea])throw new Error(`Charge per UOM for commodity ${a} does not have a valid unit symbol, please contact Navarch for assistance`)}function mt(e,a){if(!e)throw new Error(`Penalty per UOM for commodity ${a} is not a valid`);if(!e[Ea])throw new Error(`Penalty per UOM for commodity ${a} does not have a valid unit symbol, please contact Navarch for assistance`)}function pt(e){if(console.log("[validateCounterparty]"),!e)throw new Error("Counterparty for parcel not found");if(!e[Ma])throw new Error("No codename defined for counterparty of the selected parcel")}}});const w={key:0},$={key:1};var D=[],E=[];!function(e,a){if(e&&"undefined"!=typeof document){var t,o=!0===a.prepend?"prepend":"append",n=!0===a.singleTag,r="string"==typeof a.container?document.querySelector(a.container):document.getElementsByTagName("head")[0];if(n){var i=D.indexOf(r);-1===i&&(i=D.push(r)-1,E[i]={}),t=E[i]&&E[i][o]?E[i][o]:E[i][o]=l()}else t=l();65279===e.charCodeAt(0)&&(e=e.substring(1)),t.styleSheet?t.styleSheet.cssText+=e:t.appendChild(document.createTextNode(e))}function l(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),a.attributes)for(var t=Object.keys(a.attributes),n=0;n<t.length;n++)e.setAttribute(t[n],a.attributes[t[n]]);var i="prepend"===o?"afterbegin":"beforeend";return r.insertAdjacentElement(i,e),e}}(".margin-top-16px[data-v-64969d30] {\n  margin-top: 16px;\n}",{}),g.render=function(e,a,t,o,n,y){const h=r("v-button"),v=r("v-notice");return i(),l(s,null,[c(' <input :value="value" @input="handleChange($event.target.value)" /> '),c(" create a button only interface for Directus"),e.value?(i(),l("div",$,[d(h,{onClick:a[1]||(a[1]=()=>e.downloadDoc())},{default:u((()=>[f("Download Cashflow ")])),_:1})])):(i(),l("div",w,[d(h,{onClick:a[0]||(a[0]=()=>e.generateCashflow()),loading:e.isGeneraingDoc},{default:u((()=>[f("Generate Cashflow")])),_:1},8,["loading"]),e.failureReason?(i(),m(v,{key:0},{default:u((()=>[f(p(e.failureReason),1)])),_:1})):c("v-if",!0)])),d(h,{class:"margin-top-16px",onClick:a[2]||(a[2]=()=>e.copy()),loading:e.isCopying},{default:u((()=>[f("Copy")])),_:1},8,["loading"])],64)},g.__scopeId="data-v-64969d30",g.__file="src/interface.vue";var b=a({id:"navarch-docgen-cashflow",name:"Navarch Cashflow Generator Button",icon:"receipt_long",description:"This is my custom interface for Navarch's Cashflow Doc!",component:g,options:null,types:["json"],group:"standard"});export{b as default};
